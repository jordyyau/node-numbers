/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

import { ApiResponse } from '../apiResponse';
import { ApiError } from '../errors/apiError';
import { FileWrapper } from '../fileWrapper';
import { RequestOptions } from '../http/requestBuilder';
import {
  AccountDisconnectedNumbersResponse,
  accountDisconnectedNumbersResponseSchema,
} from '../models/accountDisconnectedNumbersResponse';
import {
  AccountHttpFeatureResponse,
  accountHttpFeatureResponseSchema,
} from '../models/accountHttpFeatureResponse';
import {
  AccountMessagingRoutesResponse,
  accountMessagingRoutesResponseSchema,
} from '../models/accountMessagingRoutesResponse';
import {
  AccountMmsFeatureResponse,
  accountMmsFeatureResponseSchema,
} from '../models/accountMmsFeatureResponse';
import {
  AccountMmsFeatureSettingsResponse,
  accountMmsFeatureSettingsResponseSchema,
} from '../models/accountMmsFeatureSettingsResponse';
import {
  AccountProductResponse,
  accountProductResponseSchema,
} from '../models/accountProductResponse';
import {
  AccountProductsResponse,
  accountProductsResponseSchema,
} from '../models/accountProductsResponse';
import {
  AccountSipAuthSettingsResponse,
  accountSipAuthSettingsResponseSchema,
} from '../models/accountSipAuthSettingsResponse';
import {
  AccountSipCredentials,
  accountSipCredentialsSchema,
} from '../models/accountSipCredentials';
import {
  AccountSipCredentialsCreateResponse,
  accountSipCredentialsCreateResponseSchema,
} from '../models/accountSipCredentialsCreateResponse';
import {
  AccountSmsFeatureResponse,
  accountSmsFeatureResponseSchema,
} from '../models/accountSmsFeatureResponse';
import {
  AccountTelephoneNumbersHistoryResponse,
  accountTelephoneNumbersHistoryResponseSchema,
} from '../models/accountTelephoneNumbersHistoryResponse';
import {
  AccountTerminationConfigurationResponse,
  accountTerminationConfigurationResponseSchema,
} from '../models/accountTerminationConfigurationResponse';
import {
  AddressesResponse,
  addressesResponseSchema,
} from '../models/addressesResponse';
import {
  AdminParametersPayload,
  adminParametersPayloadSchema,
} from '../models/adminParametersPayload';
import {
  AdminParametersResponse,
  adminParametersResponseSchema,
} from '../models/adminParametersResponse';
import {
  AlternateEndUserIdentifierResponse,
  alternateEndUserIdentifierResponseSchema,
} from '../models/alternateEndUserIdentifierResponse';
import {
  AlternateEndUserIdentifiersResponse,
  alternateEndUserIdentifiersResponseSchema,
} from '../models/alternateEndUserIdentifiersResponse';
import {
  AnalyticsResponse,
  analyticsResponseSchema,
} from '../models/analyticsResponse';
import {
  ApplicationPayload,
  applicationPayloadSchema,
} from '../models/applicationPayload';
import {
  ApplicationResponse,
  applicationResponseSchema,
} from '../models/applicationResponse';
import {
  ApplicationsSettings,
  applicationsSettingsSchema,
} from '../models/applicationsSettings';
import {
  AssociatedSipPeersResponse,
  associatedSipPeersResponseSchema,
} from '../models/associatedSipPeersResponse';
import {
  BdrArchiveCreationDescriptor,
  bdrArchiveCreationDescriptorSchema,
} from '../models/bdrArchiveCreationDescriptor';
import {
  BdrArchiveRetrievalResponse,
  bdrArchiveRetrievalResponseSchema,
} from '../models/bdrArchiveRetrievalResponse';
import {
  BillingReportArchiveRetrievalResponse,
  billingReportArchiveRetrievalResponseSchema,
} from '../models/billingReportArchiveRetrievalResponse';
import {
  BillingReportCreationPayload,
  billingReportCreationPayloadSchema,
} from '../models/billingReportCreationPayload';
import {
  BillingReportCreationResponse,
  billingReportCreationResponseSchema,
} from '../models/billingReportCreationResponse';
import {
  BillingReportRetrievalResponse,
  billingReportRetrievalResponseSchema,
} from '../models/billingReportRetrievalResponse';
import {
  BillingReportsRetrievalResponse,
  billingReportsRetrievalResponseSchema,
} from '../models/billingReportsRetrievalResponse';
import { BulkPortin, bulkPortinSchema } from '../models/bulkPortin';
import { BulkPortinList, bulkPortinListSchema } from '../models/bulkPortinList';
import {
  BulkPortinPatch,
  bulkPortinPatchSchema,
} from '../models/bulkPortinPatch';
import { BulkTnList, bulkTnListSchema } from '../models/bulkTnList';
import {
  CitySearchResults,
  citySearchResultsSchema,
} from '../models/citySearchResults';
import {
  CoveredRateCenter,
  coveredRateCenterSchema,
} from '../models/coveredRateCenter';
import {
  CoveredRateCenterSearchResponse,
  coveredRateCenterSearchResponseSchema,
} from '../models/coveredRateCenterSearchResponse';
import { Csr, csrSchema } from '../models/csr';
import {
  DisconnectTelephoneNumberOrder,
  disconnectTelephoneNumberOrderSchema,
} from '../models/disconnectTelephoneNumberOrder';
import {
  DldaOrderPayload,
  dldaOrderPayloadSchema,
} from '../models/dldaOrderPayload';
import { DomainResponse, domainResponseSchema } from '../models/domainResponse';
import {
  E911OrderPayload,
  e911OrderPayloadSchema,
} from '../models/e911OrderPayload';
import {
  E911SettingsResponse,
  e911SettingsResponseSchema,
} from '../models/e911SettingsResponse';
import {
  EdgeManagementConfigurationResponse,
  edgeManagementConfigurationResponseSchema,
} from '../models/edgeManagementConfigurationResponse';
import {
  EmergencyNotificationGroupEndpointAssociationPayload,
  emergencyNotificationGroupEndpointAssociationPayloadSchema,
} from '../models/emergencyNotificationGroupEndpointAssociationPayload';
import {
  EmergencyNotificationGroupEndpointAssociationResponse,
  emergencyNotificationGroupEndpointAssociationResponseSchema,
} from '../models/emergencyNotificationGroupEndpointAssociationResponse';
import {
  EmergencyNotificationGroupRecipientOrderPayload,
  emergencyNotificationGroupRecipientOrderPayloadSchema,
} from '../models/emergencyNotificationGroupRecipientOrderPayload';
import {
  EmergencyNotificationGroupRecipientOrderResponse,
  emergencyNotificationGroupRecipientOrderResponseSchema,
} from '../models/emergencyNotificationGroupRecipientOrderResponse';
import {
  EmergencyNotificationGroupsEndpointAssociationResponse,
  emergencyNotificationGroupsEndpointAssociationResponseSchema,
} from '../models/emergencyNotificationGroupsEndpointAssociationResponse';
import {
  EmergencyNotificationRecipientPayload,
  emergencyNotificationRecipientPayloadSchema,
} from '../models/emergencyNotificationRecipientPayload';
import {
  EnrNotificationTypeEnum,
  enrNotificationTypeEnumSchema,
} from '../models/enrNotificationTypeEnum';
import {
  ExternalTnsOrderPayload,
  externalTnsOrderPayloadSchema,
} from '../models/externalTnsOrderPayload';
import {
  FileMetaDataPayload,
  fileMetaDataPayloadSchema,
} from '../models/fileMetaDataPayload';
import {
  GeocodeRequestAddress,
  geocodeRequestAddressSchema,
} from '../models/geocodeRequestAddress';
import {
  GeocodeRequestResponse,
  geocodeRequestResponseSchema,
} from '../models/geocodeRequestResponse';
import {
  HolidayResponse,
  holidayResponseSchema,
} from '../models/holidayResponse';
import {
  ImportTnCheckerPayload,
  importTnCheckerPayloadSchema,
} from '../models/importTnCheckerPayload';
import {
  ImportTnOrdersPayload,
  importTnOrdersPayloadSchema,
} from '../models/importTnOrdersPayload';
import {
  ImportToAccountNumberOrder,
  importToAccountNumberOrderSchema,
} from '../models/importToAccountNumberOrder';
import {
  ImportToAccountNumberOrderResponse,
  importToAccountNumberOrderResponseSchema,
} from '../models/importToAccountNumberOrderResponse';
import {
  IrisAccountResponse,
  irisAccountResponseSchema,
} from '../models/irisAccountResponse';
import {
  IrisAccountsResponse,
  irisAccountsResponseSchema,
} from '../models/irisAccountsResponse';
import {
  LdapAccountsDto,
  ldapAccountsDtoSchema,
} from '../models/ldapAccountsDto';
import {
  LdapPermissionResponse,
  ldapPermissionResponseSchema,
} from '../models/ldapPermissionResponse';
import {
  LdapPermissionsResponse,
  ldapPermissionsResponseSchema,
} from '../models/ldapPermissionsResponse';
import {
  LdapRolePermissionsXrefResponse,
  ldapRolePermissionsXrefResponseSchema,
} from '../models/ldapRolePermissionsXrefResponse';
import {
  LdapRolePermissionXrefResponse,
  ldapRolePermissionXrefResponseSchema,
} from '../models/ldapRolePermissionXrefResponse';
import {
  LdapRoleResponse,
  ldapRoleResponseSchema,
} from '../models/ldapRoleResponse';
import { LdapRoles, ldapRolesSchema } from '../models/ldapRoles';
import { LdapUser, ldapUserSchema } from '../models/ldapUser';
import {
  LdapUserPasswordResponse,
  ldapUserPasswordResponseSchema,
} from '../models/ldapUserPasswordResponse';
import {
  LdapUserPreference,
  ldapUserPreferenceSchema,
} from '../models/ldapUserPreference';
import {
  LdapUserPreferences,
  ldapUserPreferencesSchema,
} from '../models/ldapUserPreferences';
import {
  LdapUserPreferenceXrefResponse,
  ldapUserPreferenceXrefResponseSchema,
} from '../models/ldapUserPreferenceXrefResponse';
import {
  LdapUserResponse,
  ldapUserResponseSchema,
} from '../models/ldapUserResponse';
import {
  LdapUserRolesXrefResponse,
  ldapUserRolesXrefResponseSchema,
} from '../models/ldapUserRolesXrefResponse';
import {
  LdapUserRoleXrefResponse,
  ldapUserRoleXrefResponseSchema,
} from '../models/ldapUserRoleXrefResponse';
import {
  LdapUsersResponse,
  ldapUsersResponseSchema,
} from '../models/ldapUsersResponse';
import {
  LineOptionOrderPayload,
  lineOptionOrderPayloadSchema,
} from '../models/lineOptionOrderPayload';
import {
  LineOptionOrderResponse,
  lineOptionOrderResponseSchema,
} from '../models/lineOptionOrderResponse';
import {
  LnpAvailabilityCheckResponse,
  lnpAvailabilityCheckResponseSchema,
} from '../models/lnpAvailabilityCheckResponse';
import { LnpOrder, lnpOrderSchema } from '../models/lnpOrder';
import {
  LnpOrderResponse,
  lnpOrderResponseSchema,
} from '../models/lnpOrderResponse';
import { LnpOrderSupp, lnpOrderSuppSchema } from '../models/lnpOrderSupp';
import {
  LnpResponseListWrapper,
  lnpResponseListWrapperSchema,
} from '../models/lnpResponseListWrapper';
import { LongXMLWrapper, longXMLWrapperSchema } from '../models/longXMLWrapper';
import {
  LsrOrderPayload,
  lsrOrderPayloadSchema,
} from '../models/lsrOrderPayload';
import {
  LsrOrderResponse,
  lsrOrderResponseSchema,
} from '../models/lsrOrderResponse';
import {
  ManualPortOutRequest,
  manualPortOutRequestSchema,
} from '../models/manualPortOutRequest';
import {
  ManualPortOutResponse,
  manualPortOutResponseSchema,
} from '../models/manualPortOutResponse';
import {
  MessagingSettingsResponse,
  messagingSettingsResponseSchema,
} from '../models/messagingSettingsResponse';
import {
  MmsFeatureMm4SettingsResponse,
  mmsFeatureMm4SettingsResponseSchema,
} from '../models/mmsFeatureMm4SettingsResponse';
import {
  MmsFeatureMmsSettingsResponse,
  mmsFeatureMmsSettingsResponseSchema,
} from '../models/mmsFeatureMmsSettingsResponse';
import {
  MmsFeatureResponse,
  mmsFeatureResponseSchema,
} from '../models/mmsFeatureResponse';
import { Note, noteSchema } from '../models/note';
import { NoteResponse, noteResponseSchema } from '../models/noteResponse';
import { NotesResponse, notesResponseSchema } from '../models/notesResponse';
import {
  NumberPortabilityRequest,
  numberPortabilityRequestSchema,
} from '../models/numberPortabilityRequest';
import {
  NumberPortabilityResponse,
  numberPortabilityResponseSchema,
} from '../models/numberPortabilityResponse';
import { Order, orderSchema } from '../models/order';
import {
  OrderHistoryWrapper,
  orderHistoryWrapperSchema,
} from '../models/orderHistoryWrapper';
import {
  OriginationConfigurationResponse,
  originationConfigurationResponseSchema,
} from '../models/originationConfigurationResponse';
import {
  PortinLosingCarrierResponse,
  portinLosingCarrierResponseSchema,
} from '../models/portinLosingCarrierResponse';
import {
  ProductsResponse,
  productsResponseSchema,
} from '../models/productsResponse';
import {
  ProductTnHistoryResponse,
  productTnHistoryResponseSchema,
} from '../models/productTnHistoryResponse';
import {
  RateCenterSearchResults,
  rateCenterSearchResultsSchema,
} from '../models/rateCenterSearchResults';
import {
  RemoveImportedTnOrdersPayload,
  removeImportedTnOrdersPayloadSchema,
} from '../models/removeImportedTnOrdersPayload';
import { ReportInstance, reportInstanceSchema } from '../models/reportInstance';
import {
  ReportInstanceResponse,
  reportInstanceResponseSchema,
} from '../models/reportInstanceResponse';
import {
  ReportInstancesResponse,
  reportInstancesResponseSchema,
} from '../models/reportInstancesResponse';
import { ReportResponse, reportResponseSchema } from '../models/reportResponse';
import {
  ReportsResponse,
  reportsResponseSchema,
} from '../models/reportsResponse';
import { Reservation, reservationSchema } from '../models/reservation';
import {
  ReservationResponse,
  reservationResponseSchema,
} from '../models/reservationResponse';
import { SbcNodeGroups, sbcNodeGroupsSchema } from '../models/sbcNodeGroups';
import { SearchResult, searchResultSchema } from '../models/searchResult';
import {
  SearchResultForAvailableNpaNxx,
  searchResultForAvailableNpaNxxSchema,
} from '../models/searchResultForAvailableNpaNxx';
import { SipCredential, sipCredentialSchema } from '../models/sipCredential';
import {
  SipCredentialResponse,
  sipCredentialResponseSchema,
} from '../models/sipCredentialResponse';
import {
  SipPeerGatewayAttributeResponse,
  sipPeerGatewayAttributeResponseSchema,
} from '../models/sipPeerGatewayAttributeResponse';
import {
  SipPeerGatewayAttributesResponse,
  sipPeerGatewayAttributesResponseSchema,
} from '../models/sipPeerGatewayAttributesResponse';
import {
  SipPeerGatewayIpResponse,
  sipPeerGatewayIpResponseSchema,
} from '../models/sipPeerGatewayIpResponse';
import {
  SipPeerGatewayIpsResponse,
  sipPeerGatewayIpsResponseSchema,
} from '../models/sipPeerGatewayIpsResponse';
import {
  SipPeerMessagingSettings,
  sipPeerMessagingSettingsSchema,
} from '../models/sipPeerMessagingSettings';
import {
  SipPeerMessagingSettingsResponse,
  sipPeerMessagingSettingsResponseSchema,
} from '../models/sipPeerMessagingSettingsResponse';
import {
  SipPeerMmsFeature,
  sipPeerMmsFeatureSchema,
} from '../models/sipPeerMmsFeature';
import {
  SipPeerOriginationSettings,
  sipPeerOriginationSettingsSchema,
} from '../models/sipPeerOriginationSettings';
import {
  SipPeerOriginationSettingsResponse,
  sipPeerOriginationSettingsResponseSchema,
} from '../models/sipPeerOriginationSettingsResponse';
import {
  SipPeerProductsResponse,
  sipPeerProductsResponseSchema,
} from '../models/sipPeerProductsResponse';
import {
  SipPeerSmsFeature,
  sipPeerSmsFeatureSchema,
} from '../models/sipPeerSmsFeature';
import {
  SipPeerSmsFeatureResponse,
  sipPeerSmsFeatureResponseSchema,
} from '../models/sipPeerSmsFeatureResponse';
import {
  SipPeersResponse,
  sipPeersResponseSchema,
} from '../models/sipPeersResponse';
import {
  SipPeerTelephoneNumber,
  sipPeerTelephoneNumberSchema,
} from '../models/sipPeerTelephoneNumber';
import {
  SipPeerTelephoneNumberBulk,
  sipPeerTelephoneNumberBulkSchema,
} from '../models/sipPeerTelephoneNumberBulk';
import {
  SipPeerTelephoneNumberBulkResponse,
  sipPeerTelephoneNumberBulkResponseSchema,
} from '../models/sipPeerTelephoneNumberBulkResponse';
import {
  SipPeerTelephoneNumberResponse,
  sipPeerTelephoneNumberResponseSchema,
} from '../models/sipPeerTelephoneNumberResponse';
import {
  SipPeerTelephoneNumbersCountResponse,
  sipPeerTelephoneNumbersCountResponseSchema,
} from '../models/sipPeerTelephoneNumbersCountResponse';
import {
  SipPeerTelephoneNumbersResponse,
  sipPeerTelephoneNumbersResponseSchema,
} from '../models/sipPeerTelephoneNumbersResponse';
import {
  SipPeerTerminationProductsResponse,
  sipPeerTerminationProductsResponseSchema,
} from '../models/sipPeerTerminationProductsResponse';
import {
  SipPeerTerminationSettings,
  sipPeerTerminationSettingsSchema,
} from '../models/sipPeerTerminationSettings';
import {
  SipPeerTerminationSettingsResponse,
  sipPeerTerminationSettingsResponseSchema,
} from '../models/sipPeerTerminationSettingsResponse';
import {
  SipPeerTollFreeTotalsResponse,
  sipPeerTollFreeTotalsResponseSchema,
} from '../models/sipPeerTollFreeTotalsResponse';
import { Site, siteSchema } from '../models/site';
import { SiteResponse, siteResponseSchema } from '../models/siteResponse';
import { SitesResponse, sitesResponseSchema } from '../models/sitesResponse';
import {
  SiteTnTotalResponse,
  siteTnTotalResponseSchema,
} from '../models/siteTnTotalResponse';
import { SmsHost, smsHostSchema } from '../models/smsHost';
import {
  SmsSmppHostsResponse,
  smsSmppHostsResponseSchema,
} from '../models/smsSmppHostsResponse';
import { Subscription, subscriptionSchema } from '../models/subscription';
import {
  SubscriptionResponse,
  subscriptionResponseSchema,
} from '../models/subscriptionResponse';
import {
  TelephoneNumberAvailableNnRoutesResponse,
  telephoneNumberAvailableNnRoutesResponseSchema,
} from '../models/telephoneNumberAvailableNnRoutesResponse';
import {
  TelephoneNumberDetailHistoryResponse,
  telephoneNumberDetailHistoryResponseSchema,
} from '../models/telephoneNumberDetailHistoryResponse';
import {
  TelephoneNumberListWrapper,
  telephoneNumberListWrapperSchema,
} from '../models/telephoneNumberListWrapper';
import {
  TelephoneNumbersAssignmentOrderPayload,
  telephoneNumbersAssignmentOrderPayloadSchema,
} from '../models/telephoneNumbersAssignmentOrderPayload';
import {
  TelephoneNumbersDetailsHistory,
  telephoneNumbersDetailsHistorySchema,
} from '../models/telephoneNumbersDetailsHistory';
import {
  TelephoneNumbersHistoryResponse,
  telephoneNumbersHistoryResponseSchema,
} from '../models/telephoneNumbersHistoryResponse';
import {
  TelephoneNumbersPayload,
  telephoneNumbersPayloadSchema,
} from '../models/telephoneNumbersPayload';
import {
  TelephoneNumberStatusWrapper,
  telephoneNumberStatusWrapperSchema,
} from '../models/telephoneNumberStatusWrapper';
import {
  TelephoneNumberTotalsHistory,
  telephoneNumberTotalsHistorySchema,
} from '../models/telephoneNumberTotalsHistory';
import {
  TnActivationStatus,
  tnActivationStatusSchema,
} from '../models/tnActivationStatus';
import {
  TnActivationStatusResponse,
  tnActivationStatusResponseSchema,
} from '../models/tnActivationStatusResponse';
import {
  TnE911AddressResponse,
  tnE911AddressResponseSchema,
} from '../models/tnE911AddressResponse';
import {
  TnOptionOrderPayload,
  tnOptionOrderPayloadSchema,
} from '../models/tnOptionOrderPayload';
import {
  TnPortOutPasscodesResponse,
  tnPortOutPasscodesResponseSchema,
} from '../models/tnPortOutPasscodesResponse';
import { TnSipPeer, tnSipPeerSchema } from '../models/tnSipPeer';
import {
  TnSipPeerResponse,
  tnSipPeerResponseSchema,
} from '../models/tnSipPeerResponse';
import { TokenResponse, tokenResponseSchema } from '../models/tokenResponse';
import { TokenScope, tokenScopeSchema } from '../models/tokenScope';
import { TokensResponse, tokensResponseSchema } from '../models/tokensResponse';
import {
  TollFreeSettingsResponse,
  tollFreeSettingsResponseSchema,
} from '../models/tollFreeSettingsResponse';
import {
  UcTrunkingCloudConfigurationPayload,
  ucTrunkingCloudConfigurationPayloadSchema,
} from '../models/ucTrunkingCloudConfigurationPayload';
import {
  UcTrunkingCloudConfigurationResponse,
  ucTrunkingCloudConfigurationResponseSchema,
} from '../models/ucTrunkingCloudConfigurationResponse';
import {
  UcTrunkingPremiseTrunksResponse,
  ucTrunkingPremiseTrunksResponseSchema,
} from '../models/ucTrunkingPremiseTrunksResponse';
import {
  UserAccountResponse,
  userAccountResponseSchema,
} from '../models/userAccountResponse';
import {
  UserAccountsResponse,
  userAccountsResponseSchema,
} from '../models/userAccountsResponse';
import {
  UserActivityEventDetailsResponse,
  userActivityEventDetailsResponseSchema,
} from '../models/userActivityEventDetailsResponse';
import {
  UserActivityEventLogResponse,
  userActivityEventLogResponseSchema,
} from '../models/userActivityEventLogResponse';
import { UserProfile, userProfileSchema } from '../models/userProfile';
import {
  UserProfileResponse,
  userProfileResponseSchema,
} from '../models/userProfileResponse';
import { UserSettings, userSettingsSchema } from '../models/userSettings';
import {
  UserSettingsResponse,
  userSettingsResponseSchema,
} from '../models/userSettingsResponse';
import { array, boolean, number, optional, string, unknown } from '../schema';
import { BaseController } from './baseController';

export class ExternalController extends BaseController {
  /**
   * discover what is currently enabled on the account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getProducts(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountProductsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products`;
    return req.callAsXml(
      'AccountProductsResponse',
      accountProductsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param productName
   * @return Response from the API call
   */
  async getAccountProduct(
    accountId: number,
    productName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productName: [productName, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/${mapped.productName}`;
    return req.callAsXml(
      'AccountProductResponse',
      accountProductResponseSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve all addresses.
   *
   * @param accountId
   * @param page
   * @param size
   * @param type
   * @param e911locationid
   * @param suggestions
   * @return Response from the API call
   */
  async getAddresses(
    accountId: number,
    page?: string,
    size?: number,
    type?: string,
    e911locationid?: string,
    suggestions?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AddressesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      type: [type, optional(string())],
      e911locationid: [e911locationid, optional(string())],
      suggestions: [suggestions, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('type', mapped.type);
    req.query('e911locationid', mapped.e911locationid);
    req.query('suggestions', mapped.suggestions);
    req.appendTemplatePath`/accounts/${mapped.accountId}/addresses`;
    req.throwOn(404, ApiError, 'Not Found - if the account specified does not exist or is locked or there are no addresses for specified search criteria it will result in a not found.');
    return req.callAsXml(
      'AddressesResponse',
      addressesResponseSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve a detailed information of Alternate end user identifier by acid.
   *
   * @param accountId
   * @param identifier
   * @return Response from the API call
   */
  async getAEUI(
    accountId: number,
    identifier: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AlternateEndUserIdentifierResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      identifier: [identifier, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/aeuis/${mapped.identifier}`;
    req.throwOn(404, ApiError, 'Not Found - if the account specified does not exist or is locked or there are no AEUI that corresponds to specified acid it will result in a "NOT FOUND" response.');
    return req.callAsXml(
      'AlternateEndUserIdentifierResponse',
      alternateEndUserIdentifierResponseSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve all Alternate end user identifiers.
   *
   * @param accountId
   * @param page
   * @param size
   * @param aeui
   * @param callback
   * @param pidfloenabledonly
   * @param suggestions
   * @param callername
   * @param locationId
   * @param e911addressId
   * @return Response from the API call
   */
  async getAEUIS1(
    accountId: number,
    page?: string,
    size?: number,
    aeui?: string,
    callback?: string,
    pidfloenabledonly?: boolean,
    suggestions?: string,
    callername?: string,
    locationId?: string,
    e911addressId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AlternateEndUserIdentifiersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      aeui: [aeui, optional(string())],
      callback: [callback, optional(string())],
      pidfloenabledonly: [pidfloenabledonly, optional(boolean())],
      suggestions: [suggestions, optional(string())],
      callername: [callername, optional(string())],
      locationId: [locationId, optional(string())],
      e911addressId: [e911addressId, optional(number())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('aeui', mapped.aeui);
    req.query('callback', mapped.callback);
    req.query('pidfloenabledonly', mapped.pidfloenabledonly);
    req.query('suggestions', mapped.suggestions);
    req.query('callername', mapped.callername);
    req.query('locationId', mapped.locationId);
    req.query('e911addressId', mapped.e911addressId);
    req.appendTemplatePath`/accounts/${mapped.accountId}/aeuis`;
    req.throwOn(404, ApiError, 'Not Found - if the account specified does not exist or is locked or there are no AEUIs for specified search criteria it will result in a "NOT FOUND" response.');
    return req.callAsXml(
      'AlternateEndUserIdentifiersResponse',
      alternateEndUserIdentifiersResponseSchema,
      requestOptions
    );
  }

  /**
   * Lists all Applications<br><p><br>  <ul>    <li> CallbackCreds Password is not returned in response
   * for security reasons </li>  </ul></p>
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAllApplications(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Create an Application, CallbackUrl field is deprecated field, use MsgCallbackUrl instead
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createApplication(
    accountId: number,
    body?: ApplicationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Application', optional(applicationPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve an Application
   *
   * @param accountId
   * @param applicationId
   * @return Response from the API call
   */
  async getApplicationById(
    accountId: number,
    applicationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      applicationId: [applicationId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications/${mapped.applicationId}`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Update an Application. <br> <ul>    <li> ServiceType can have value of Voice-V2 or Messaging-V2 but
   * it can't be changed for existing application </li> </ul>     <p>For ServiceType of Messaging-V2 <br>
   * <ul>         <li> MsgCallbackUrl (CallbackUrl - is deprecated) is required </li>       </ul>
   * </p>     <p>For ServiceType of Voice-V2       <ul>         <li> CallInitiatedCallbackUrl -
   * required for voice </li>         <li> CallInitiatedMethod - optional for voice [POST|GET] default is
   * POST if not specified</li>         <li> CallStatusCallbackUrl - optional for voice </li>
   * <li> CallStatusMethod - optional for voice [POST|GET] default is POST if not specified </li>
   * <li> CallInitiatedFallbackUrl - optional for voice </li>         <li> CallInitiatedFallbackMethod -
   * optional for voice [POST|GET] default is POST if not specified </li>         <li> CallbackTimeout -
   * optional for voice. Range from 1 to 25 seconds. </li>       </ul>     </p>     <p>CallbackCreds -
   * can only be specified by External users       <ul>          <li> CallbackCreds with same UserId but
   * different Password will change password</li>          <li> If you want credentials, both UserId and
   * Password must be specified.</li>          <li> If you do not want passwords, CallbackCreds should be
   * omitted entirely.</li>          <li> UserId and Password should have length between 6 and 63 symbols.
   * </li>       </ul>     </p>     <p>CallInitiatedFallbackCreds - can only be specified by External
   * users      <ul>         <li> If you want credentials, both UserId and Password must be specified.
   * </li>         <li> If you do not want passwords, CallInitiatedFallbackCreds should be omitted
   * entirely.</li>         <li> UserId and Password should have length between 6 and 63 symbols.</li>
   * </ul>     </p>
   *
   * @param accountId
   * @param applicationId
   * @param body
   * @return Response from the API call
   */
  async updateApplication(
    accountId: number,
    applicationId: string,
    body?: ApplicationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      applicationId: [applicationId, string()],
    });
    req.xml('body', body, 'Application', optional(applicationPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications/${mapped.applicationId}`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete an Application. <br>An Application cannot be removed from an account if that Application is
   * referenced by any Location associated with the account.<br>
   *
   * @param accountId
   * @param applicationId
   * @return Response from the API call
   */
  async deleteApplication(
    accountId: number,
    applicationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      applicationId: [applicationId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications/${mapped.applicationId}`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Patch update an Application<br> <ul>  <li> CallStatusCallbackUrl can be removed by settings its
   * value to 'remove'  </li> </ul>
   *
   * @param accountId
   * @param applicationId
   * @param body
   * @return Response from the API call
   */
  async patchApplication(
    accountId: number,
    applicationId: string,
    body?: ApplicationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ApplicationResponse>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      applicationId: [applicationId, string()],
    });
    req.xml('body', body, 'Application', optional(applicationPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications/${mapped.applicationId}`;
    return req.callAsXml(
      'ApplicationProvisioningResponse',
      applicationResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve a list of sippeers, associated with application
   *
   * @param accountId
   * @param applicationId
   * @return Response from the API call
   */
  async getAssociatedSippeersByApplicationIdId(
    accountId: number,
    applicationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AssociatedSipPeersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      applicationId: [applicationId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/applications/${mapped.applicationId}/associatedsippeers`;
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(404, ApiError, 'Not Found');
    return req.callAsXml(
      'AssociatedSipPeersResponse',
      associatedSipPeersResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve the information for a specific Campaign ID.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/a2pcampaignids/${mapped.id}`;
    req.throwOn(404, ApiError, 'Campaign ID not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/a2pcampaignids');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get A2P Class.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData1(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/a2pclasses/${mapped.id}`;
    req.throwOn(404, ApiError, 'A2P Class not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all A2P Classes.
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData1(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/a2pclasses');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData6(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/${mapped.id}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all bwspids
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData3(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/bwspids');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get Bwspid
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData3(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/bwspids/${mapped.id}`;
    req.throwOn(404, ApiError, 'Bwspid not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * This resource retrieves information about pom.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAdminData7(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/admin/data/blockedaccount/${mapped.accountId}`;
    req.throwOn(404, ApiError, 'Account does not have a POM configuration.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve the information for a specific proxy sippeer.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData9(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/proxypeers/${mapped.id}`;
    req.throwOn(404, ApiError, 'proxy sippeer not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all proxy sippeers (they should be sippeers of catapult accounts)
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData8(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/proxypeers');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async getAllAdminData9(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SbcNodeGroups>> {
    const req = this.createRequest('GET', '/admin/data/sbcnodegroups');
    return req.callAsXml('SbcNodeGroups', sbcNodeGroupsSchema, requestOptions);
  }

  /**
   * TODO
   *
   * @param sbcGroupId
   * @param accountId
   * @return Response from the API call
   */
  async getAdminData10(
    sbcGroupId: string,
    accountId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      sbcGroupId: [sbcGroupId, string()],
      accountId: [accountId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.sbcGroupId}/sbcnodegroups/${mapped.accountId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * get SystemEventSubscription.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData11(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/systemeventsubscriptions/${mapped.id}`;
    req.throwOn(404, ApiError, 'SystemEventSubscription not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData10(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest(
      'GET',
      '/admin/data/systemeventsubscriptions'
    );
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get Vendor.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData14(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/vendors/${mapped.id}`;
    req.throwOn(404, ApiError, 'Vendor not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all vendors and filter by name
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData12(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/vendors');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param property
   * @return Response from the API call
   */
  async getAdminOptionErrorWithParameter(
    property: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ property: [property, string()] });
    req.appendTemplatePath`/${mapped.property}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param sippeerId
   * @return Response from the API call
   */
  async getAdminData16(
    sippeerId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ sippeerId: [sippeerId, string()] });
    req.appendTemplatePath`/${mapped.sippeerId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * The GET returns the current settings, indicating the user ID, and the result from attempted
   * authentication with the stored credentials.  If the Authentication fails subsequent attempts will be
   * made using default credentials until the issue is resolved.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getE911Configuration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<E911SettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/e911/settings`;
    req.throwOn(404, ApiError, 'NOT FOUNDIf the E911 product exists on the account, but settings are missing, then the 404 not found response is used.If the E911 product does not exist on the account then the 404 will indicate that the E911 products resource cannot be found.');
    return req.callAsXml(
      'E911SettingsResponse',
      e911SettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * There are three primary settings that are provided as part of the Edge Management product: The SBC
   * settings that are associated with the account,SipAuthentication that provide settings for SIP
   * authentication and ProductSpecificAccessRestrictions that can restrict Termination traffic for
   * sipCredendital.    <br>    <b>SbcSettings:</b>    <table>
   * <tr><th>Parameter</th><th>Description</th></tr>    <tr><td>TrunkGroupId</td><td>element defines id
   * of the trunk group associated with the Account in TGA</td></tr>
   * <tr><td>NodeGroupName</td><td>element are the node group name set up in TGA</td></tr>    </table>
   * <br>    <b>SipAuthentication:</b>     <table>     <tr><th>Parameter</th><th>Description</th></tr>
   * <tr><td>Enabled</td><td>enable SIP Authentication on account. Values that can be accepted: true,
   * false</td></tr>     <tr><td>Status</td><td>provide information about processing status. This field
   * cannot be updated.</td></tr>     <tr><td>Errors</td><td>List of errors that happened during sip auth
   * provisioning. This field cannot be updated.</td></tr>     </table>    <br><br>
   * <b>ProductSpecificAccessRestrictions</b>(requires existence of SipCredentialSettings)<b>:</b>
   * <table>    <tr><th>Parameter</th><th>Description</th></tr>
   * <tr><td>RestrictedProduct</td><td>Product to restrict. Values that can be accepted:
   * Termination</td></tr>    <tr><td>RestrictedAccessType</td><td>Type of restriction. Values that can
   * be accepted: SipCredentials</td></tr>    </table>
   *
   * @param accountId
   * @return Response from the API call
   */
  async getEdgeManagementConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EdgeManagementConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/edgemanagement/settings`;
    req.throwOn(404, ApiError, 'If the settings are not present for the EdgeManagement product a 404 NOT FOUND is returned with an explanatory payload.');
    return req.callAsXml(
      'EdgeManagementSettingsResponse',
      edgeManagementConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * Gets all SIP Authentication settings
   *
   * @param accountId
   * @return Response from the API call
   */
  async getSipAuthenticationConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSipAuthSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/edgemanagement/settings/sipauthentication`;
    req.throwOn(404, ApiError, 'If the configuration is not present a 404 NOT FOUND is returned with an explanatory payload.');
    return req.callAsXml(
      'SipAuthenticationResponse',
      accountSipAuthSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * POST is used to validate address as geocode-able one. Request payload is the address to geocode. If
   * decomposed elements are provided for AddressLine 1 then AddressLine1 is ignored. At least
   * HouseNumber and StreetName are required to use them as replacement of AddressLine1. If at least
   * HouseNumber or StreetName is absent then AddressLine1 is used. AddressLine1 information is required
   * in either way. City and StateCode fields are required.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createGetAddresses1(
    accountId: number,
    body?: GeocodeRequestAddress,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<GeocodeRequestResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'RequestAddress',
      optional(geocodeRequestAddressSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/geocoderequest`;
    req.throwOn(400, ApiError, 'Bad request - service cannot geocode address or validation rules were violated.');
    req.throwOn(409, ApiError, 'Conflict - address is close to one that can be geocoded.');
    req.throwOn(500, ApiError, 'System error - internal error which cannot be fixed by changing payload etc.');
    req.throwOn(503, ApiError, 'Service unavailable - for some reason service is temporary unavailable.');
    return req.callAsXml(
      'GeocodeRequestResponse',
      geocodeRequestResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param holidayDate
   * @return Response from the API call
   */
  async getHoliday(
    holidayDate: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<HolidayResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ holidayDate: [holidayDate, string()] });
    req.appendTemplatePath`/${mapped.holidayDate}`;
    return req.callAsXml(
      'HolidayResponse',
      holidayResponseSchema,
      requestOptions
    );
  }

  /**
   * The GET returns the current settings, indicating is Messaging product enabled now and if yes will
   * Messaging feature be enabled on each new telephone number.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getMessagingSettings(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MessagingSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/settings`;
    req.throwOn(404, ApiError, 'NOT FOUNDIf the Messaging product exists on the account, but settings are missing, then the 404 not found response is used.If the Messaging product does not exist on the account then the 404 will indicate that the Messaging products resource cannot be found.');
    return req.callAsXml(
      'MessagingSettingsResponse',
      messagingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * The GET returns the current list of routes associated with the various types of TNs that can be
   * assigned messaging routes.Zero or more routes can be returned for each type of TN; each one of these
   * routes is identified by an NNID, or an ESPID while we transition from ESPIDs to NNIDs.For reference
   * the various types of TNs that can be assigned differentiated routes are...<table>    <tr><th>XML
   * element</th><th>Type of TN description</th></tr>    <tr><td>OnNetTns</td><td>On Net Bandwidth owned
   * TNs</td></tr>    <tr><td>OffNetTns</td><td>Off-net TNs in Bandwidth's inventory</td></tr>
   * <tr><td>OffNetCanadianTns</td><td>Canadian TNs in Bandwidth's inventory</td></tr>
   * <tr><td>TollFreeTns</td><td>TollFree TNs in Bandwidth's inventory</td></tr>
   * <tr><td>ExternalCustomerOwnedTns</td><td>TNs owned by the customer in NPAC, and imported into
   * Bandwidth's inventory for the customer's use</td></tr>    <tr><td>ExternalThirdPartyTns</td><td>TNs
   * owned by a 3rd party in NPAC, and imported into Bandwidth's inventory for the customer's
   * use</td></tr>    <tr><td>ExternalCanadianTns</td><td>Canadian TNs eh, imported into Bandwidth's
   * inventory for the customer's use</td></tr>    <tr><td>ExternalTollFreeTns</td><td>Toll Free TNs
   * imported into Bandwidth's inventory for the customer's use</td></tr>
   * <tr><td>A2pTollFreeTns</td><td>A2P Non Toll Free NNID</td></tr>
   * <tr><td>A2pNonTollFreeTns</td><td>A2P Toll Free NNID</td></tr></table>If a single route is returned
   * that implies that all of the TNs of the associated type will use the listed NNID for routing.If no
   * route values are returnet that implies that Bandwidth is not involved in setting up routes - that
   * must be done using other means.It also implies that Messages sent to TNs of that type will be routed
   * off-net.If there are multiple route values configured it means that the customer is empowered to
   * assign one of the NNIDs to any of the messaging enabled TNs on their account.In the multiple routes
   * case the only one route per Tn Type in the list is taken to be the default value assigned to TNs
   * when provisioned.
   *
   * @param accountId
   * @param details
   * @return Response from the API call
   */
  async getAccountRoutes(
    accountId: number,
    details?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMessagingRoutesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      details: [details, optional(boolean())],
    });
    req.query('details', mapped.details);
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/routes`;
    return req.callAsXml(
      'AccountMessagingRoutesResponse',
      accountMessagingRoutesResponseSchema,
      requestOptions
    );
  }

  /**
   * Get sms settings for account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getSmsFeature(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSmsFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/sms`;
    return req.callAsXml(
      'AccountSmsFeatureResponse',
      accountSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Get http settings for account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getHttpFeature(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountHttpFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/http`;
    return req.callAsXml(
      'AccountHttpFeatureResponse',
      accountHttpFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async retrieveMmsFeatureSettings(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMmsFeatureSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms/settings`;
    return req.callAsXml(
      'AccountMmsFeatureSettingsResponse',
      accountMmsFeatureSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Get mm4 settings for account
   *
   * @param accountId
   * @return Response from the API call
   */
  async retrieveMmsFeatureMm4Settings(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureMm4SettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms/mm4settings`;
    return req.callAsXml(
      'MmsFeatureMm4AdminSettingsResponse',
      mmsFeatureMm4SettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Get mms settings for account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getMmsFeature(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMmsFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms`;
    return req.callAsXml(
      'AccountMmsFeatureResponse',
      accountMmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param propertyName
   * @return Response from the API call
   */
  async getProperty(
    propertyName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ propertyName: [propertyName, string()] });
    req.appendTemplatePath`/${mapped.propertyName}`;
    return req.callAsXml(
      'ProductsResponse',
      productsResponseSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve all SIP credentials for the account.
   *
   * @param accountId
   * @param page
   * @param size
   * @param usernamefragment
   * @param domainfragment
   * @return Response from the API call
   */
  async getSipCredentials(
    accountId: number,
    page?: string,
    size?: number,
    usernamefragment?: string,
    domainfragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSipCredentials>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      usernamefragment: [usernamefragment, optional(string())],
      domainfragment: [domainfragment, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('usernamefragment', mapped.usernamefragment);
    req.query('domainfragment', mapped.domainfragment);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sipcredentials`;
    req.throwOn(404, ApiError, 'Not Found - if the account specified does not exist or is locked or there are no SIP credentials associated with specified account it will result in a not found.');
    return req.callAsXml(
      'SipCredentials',
      accountSipCredentialsSchema,
      requestOptions
    );
  }

  /**
   * POST is used to create SIP credentials and associate its with the account.The key data elements in
   * the submission are - <table style="text-align: left; width: 80%;" border="1" cellpadding="2"
   * cellspacing="2">  <tbody>    <tr>      <td>UserName</td>      <td>This is subscriber name or
   * aggregated name and domain value(ex: John@bw.com). Field is required. Max length - 32 characters.
   * </td>    </tr>    <tr>      <td>Domain</td>      <td>This is subscriber domain. Domain is optional
   * and if present will be appended to the UserName with an '@'. Max length - 32 characters.</td>
   * </tr>    <tr>      <td>Hash1</td>      <td>This is hash value #1 in MD5 representation. Field is
   * required. Max length - 64 characters.</td>    </tr>    <tr>      <td>Hash1b</td>      <td>This is
   * hash value #2 in MD5 representation. Field is optional. Max length - 64 characters.</td>    </tr>
   * </tbody></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createSipCredentials(
    accountId: number,
    body?: AccountSipCredentials,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSipCredentialsCreateResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'SipCredentials',
      optional(accountSipCredentialsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sipcredentials`;
    req.throwOn(400, ApiError, 'Bad Request - If all credential entries in specified list are invalid it will result in bad request with list of errors.');
    return req.callAsXml(
      'SipCredentialsResponse',
      accountSipCredentialsCreateResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param aggregatedusername
   * @return Response from the API call
   */
  async getSipCredential(
    accountId: number,
    aggregatedusername: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipCredentialResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      aggregatedusername: [aggregatedusername, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sipcredentials/${mapped.aggregatedusername}`;
    return req.callAsXml(
      'SipCredentialResponse',
      sipCredentialResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param aggregatedusername
   * @param body
   * @return Response from the API call
   */
  async updateSipCredential(
    accountId: number,
    aggregatedusername: string,
    body?: SipCredential,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipCredentialResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      aggregatedusername: [aggregatedusername, string()],
    });
    req.xml('body', body, 'SipCredential', optional(sipCredentialSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sipcredentials/${mapped.aggregatedusername}`;
    return req.callAsXml(
      'SipCredentialResponse',
      sipCredentialResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param aggregatedusername
   * @return Response from the API call
   */
  async deleteSipCredential(
    accountId: number,
    aggregatedusername: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      aggregatedusername: [aggregatedusername, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sipcredentials/${mapped.aggregatedusername}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * retrieves the information associated with the site id
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSite(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}`;
    req.throwOn(404, ApiError, 'the site id entered does not exist');
    return req.callAsXml('SiteResponse', siteResponseSchema, requestOptions);
  }

  /**
   * updates the contents of a site id
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async updateSite(
    accountId: number,
    siteId: number,
    body?: Site,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'Site', optional(siteSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}`;
    req.throwOn(400, ApiError, 'Information essential to the site id is missing');
    req.throwOn(409, ApiError, 'Address needs some changes');
    return req.callAsXml('SiteResponse', siteResponseSchema, requestOptions);
  }

  /**
   * deletes the site - sites can only be deleted if there are no SIP Peers attached to it
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async deleteSite(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}`;
    req.throwOn(400, ApiError, 'DELETE request is invalid given the current state of the site');
    return req.callAsXml('SiteResponse', siteResponseSchema, requestOptions);
  }

  /**
   * retrieve a list of all the sites associated with the account
   *
   * @param accountId
   * @param tnCounts       Example: false
   * @param sipPeerDetails Example: false
   * @param summary        Example: false
   * @return Response from the API call
   */
  async getSites(
    accountId: number,
    tnCounts?: boolean,
    sipPeerDetails?: boolean,
    summary?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SitesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      tnCounts: [tnCounts, optional(boolean())],
      sipPeerDetails: [sipPeerDetails, optional(boolean())],
      summary: [summary, optional(boolean())],
    });
    req.query('tnCounts', mapped.tnCounts);
    req.query('sipPeerDetails', mapped.sipPeerDetails);
    req.query('summary', mapped.summary);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites`;
    return req.callAsXml('SitesResponse', sitesResponseSchema, requestOptions);
  }

  /**
   * Add a site to the account
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createSite(
    accountId: number,
    body?: Site,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Site', optional(siteSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites`;
    req.throwOn(400, ApiError, 'Information is missing from the body of the add site request');
    req.throwOn(409, ApiError, 'Address needs some changes');
    return req.callAsXml('SiteResponse', siteResponseSchema, requestOptions);
  }

  /**
   * These are the settings associated with the provisioning of Termination settings. The current values
   * represented below detail the legacy Termination settings appropriate for customers currently on
   * Bandwidth Dashboard API.  In the future Bandwidth Dashboard API customers will use the Roger
   * Termination Product manager, and define the set of Roger parameters using an extension of this
   * interface.  A parameter 'RogerUsedForTerminationSettings' is used to control this behavior...
   * <ul>    <li>If RogerUsedForTerminationSettings is false, then the LegacyTerminationSettings will be
   * used, RogerTerminationSettings will be empty</li>    <li>If RogerUsedForTerminationSettings is
   * transition, then both LegacyTerminationSettings and RogerTerminationSettings elements are used</li>
   * <li>If RogerUsedForTerminationSettings is true, then the RogerTerminationSettings element will be
   * used.  LegacyTerminationSettings will be empty.</li>    </ul>    <ul>    <li>HttpVoiceProxyTermHost
   * is created automatically when the first voice application is created for HTTP Voice V2 for this
   * account, and deleted when the last voice application for HTTP Voice V2 is removed from this account.
   * </li>    <li>HttpVoiceProxyTermHost is only displayed for internal users.</li>    </ul>
   *
   * @param accountId
   * @return Response from the API call
   */
  async getTerminationConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTerminationConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/settings`;
    req.throwOn(404, ApiError, 'If the settings are not present for the Termination product a 404 NOT FOUND is returned with an explanatory payload.');
    return req.callAsXml(
      'TerminationSettingResponse',
      accountTerminationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve Toll Free Settings for this account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getTollFreeConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TollFreeSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/tollfree/settings`;
    req.throwOn(400, ApiError, 'Failure to parse the request, or inconsistent provisioned data, such as no related product associated with the account.');
    return req.callAsXml(
      'TollFreeSettingsResponse',
      tollFreeSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * These are the settings associated with the provisioning of UC Trunking settings.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getUcTrunkingHostedConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingCloudConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunks`;
    req.throwOn(404, ApiError, 'If the settings are not present for the UC Trunking product a 404 NOT FOUND is returned with an explanatory payload.');
    return req.callAsXml(
      'UcTrunkingCloudSettingsResponse',
      ucTrunkingCloudConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this UC Trunking are described in the section on
   * POST.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateUcTrunkingHostedConfiguration(
    accountId: number,
    body?: UcTrunkingCloudConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingCloudConfigurationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'UcTrunkingCloudSettings',
      optional(ucTrunkingCloudConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunks`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the UC Trunking settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'UcTrunkingCloudSettingsResponse',
      ucTrunkingCloudConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * Creates a UC Trunking hosted (cloud) configuration
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createUcTrunkingHostedConfiguration(
    accountId: number,
    body?: UcTrunkingCloudConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingCloudConfigurationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'UcTrunkingCloudSettings',
      optional(ucTrunkingCloudConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunks`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the UC Trunking settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'UcTrunkingCloudSettingsResponse',
      ucTrunkingCloudConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * These are the settings associated with the provisioning of UC Trunking settings.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getUcTrunkingConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OriginationConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunking/settings`;
    req.throwOn(404, ApiError, 'If the settings are not present for the UC Trunking product a 404 NOT FOUND is returned with an explanatory payload.');
    return req.callAsXml(
      'OriginationSettingResponse',
      originationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param accounts
   * @param suggestions
   * @param page
   * @param size
   * @return Response from the API call
   */
  async getLdapAccounts(
    domainName: string,
    accounts: string,
    suggestions?: string,
    page?: string,
    size?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<IrisAccountsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      accounts: [accounts, string()],
      suggestions: [suggestions, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(string())],
    });
    req.query('suggestions', mapped.suggestions);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.appendTemplatePath`/${mapped.domainName}/${mapped.accounts}`;
    return req.callAsXml(
      'LdapAccountsResponse',
      irisAccountsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about account by unique account id.
   *
   * @param accountId
   * @param domainName
   * @param accounts
   * @return Response from the API call
   */
  async getLdapAccount(
    accountId: number,
    domainName: string,
    accounts: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<IrisAccountResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.appendTemplatePath`/${mapped.accountId}/${mapped.domainName}/${mapped.accounts}`;
    req.throwOn(404, ApiError, 'The account does not exist.');
    return req.callAsXml(
      'LdapAccountResponse',
      irisAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about domain with some name.
   *
   * @param domainName
   * @return Response from the API call
   */
  async getDomain(
    domainName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<DomainResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ domainName: [domainName, string()] });
    req.appendTemplatePath`/${mapped.domainName}`;
    req.throwOn(404, ApiError, 'Domain name not found.');
    return req.callAsXml(
      'DomainResponse',
      domainResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param permissions
   * @return Response from the API call
   */
  async getLdapPermissions(
    domainName: string,
    permissions: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapPermissionsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      permissions: [permissions, string()],
    });
    req.appendTemplatePath`/${mapped.domainName}/${mapped.permissions}`;
    return req.callAsXml(
      'LdapPermissionsResponse',
      ldapPermissionsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about permission by unique permission name.
   *
   * @param permissionId
   * @param domainName
   * @param permissions
   * @return Response from the API call
   */
  async getLdapPermission(
    permissionId: string,
    domainName: string,
    permissions: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapPermissionResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      permissionId: [permissionId, string()],
      domainName: [domainName, string()],
      permissions: [permissions, string()],
    });
    req.appendTemplatePath`/${mapped.permissionId}/${mapped.domainName}/${mapped.permissions}`;
    req.throwOn(404, ApiError, 'The permission does not exist.');
    return req.callAsXml(
      'LdapPermissionResponse',
      ldapPermissionResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about role by unique role name.
   *
   * @param roleId
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async getLdapRole(
    roleId: string,
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapRoleResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      roleId: [roleId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.roleId}/${mapped.domainName}/${mapped.roles}`;
    req.throwOn(404, ApiError, 'The role does not exist.');
    return req.callAsXml(
      'LdapRoleResponse',
      ldapRoleResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async getLdapRoles(
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapRoleResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.domainName}/${mapped.roles}`;
    return req.callAsXml(
      'LdapRoleResponse',
      ldapRoleResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about permission by unique name, related to specific role.
   *
   * @param roleId
   * @param permissionId
   * @param domainName
   * @param roles
   * @param permissions
   * @return Response from the API call
   */
  async getLdapRolePermissions(
    roleId: string,
    permissionId: string,
    domainName: string,
    roles: string,
    permissions: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapRolePermissionXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      roleId: [roleId, string()],
      permissionId: [permissionId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
      permissions: [permissions, string()],
    });
    req.appendTemplatePath`/${mapped.roleId}/${mapped.permissionId}/${mapped.domainName}/${mapped.roles}/${mapped.permissions}`;
    req.throwOn(404, ApiError, 'The role or permission does not exist.');
    return req.callAsXml(
      'LdapRolePermissionResponse',
      ldapRolePermissionXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param roleId
   * @param domainName
   * @param roles
   * @param permissions
   * @return Response from the API call
   */
  async getLdapRolePermissions1(
    roleId: string,
    domainName: string,
    roles: string,
    permissions: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapRolePermissionsXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      roleId: [roleId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
      permissions: [permissions, string()],
    });
    req.appendTemplatePath`/${mapped.roleId}/${mapped.domainName}/${mapped.roles}/${mapped.permissions}`;
    return req.callAsXml(
      'LdapRolePermissionsResponse',
      ldapRolePermissionsXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param accountScope
   * @return Response from the API call
   */
  async listTokens(
    domainName: string,
    accountScope?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TokensResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      accountScope: [accountScope, optional(number())],
    });
    req.query('accountScope', mapped.accountScope);
    req.appendTemplatePath`/${mapped.domainName}/tokens`;
    return req.callAsXml(
      'TokensResponse',
      tokensResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param body
   * @return Response from the API call
   */
  async createTokenSecretPair(
    domainName: string,
    body?: TokenScope,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TokenResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ domainName: [domainName, string()] });
    req.xml('body', body, 'TokenScope', optional(tokenScopeSchema));
    req.appendTemplatePath`/${mapped.domainName}/tokens`;
    return req.callAsXml('TokenResponse', tokenResponseSchema, requestOptions);
  }

  /**
   * TODO
   *
   * @param tokenId
   * @param domainName
   * @param accountScope
   * @return Response from the API call
   */
  async retrieveToken(
    tokenId: string,
    domainName: string,
    accountScope?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TokenResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      tokenId: [tokenId, string()],
      domainName: [domainName, string()],
      accountScope: [accountScope, optional(number())],
    });
    req.query('accountScope', mapped.accountScope);
    req.appendTemplatePath`/${mapped.tokenId}/tokens/${mapped.domainName}`;
    return req.callAsXml('TokenResponse', tokenResponseSchema, requestOptions);
  }

  /**
   * TODO
   *
   * @param tokenId
   * @param domainName
   * @param accountScope
   * @return Response from the API call
   */
  async deleteToken(
    tokenId: string,
    domainName: string,
    accountScope?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TokenResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      tokenId: [tokenId, string()],
      domainName: [domainName, string()],
      accountScope: [accountScope, optional(number())],
    });
    req.query('accountScope', mapped.accountScope);
    req.appendTemplatePath`/${mapped.tokenId}/tokens/${mapped.domainName}`;
    return req.callAsXml('TokenResponse', tokenResponseSchema, requestOptions);
  }

  /**
   * Retrieves the information about user.
   *
   * @param userId
   * @param domainName
   * @return Response from the API call
   */
  async getUser(
    userId: string,
    domainName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}`;
    req.throwOn(400, ApiError, 'User ID is not correct.');
    req.throwOn(404, ApiError, 'User not found.');
    return req.callAsXml(
      'LdapUserResponse',
      ldapUserResponseSchema,
      requestOptions
    );
  }

  /**
   * Allows the user update.
   *
   * @param userId
   * @param domainName
   * @param body
   * @return Response from the API call
   */
  async updateUser(
    userId: string,
    domainName: string,
    body?: LdapUser,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
    });
    req.xml('body', body, 'User', optional(ldapUserSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}`;
    req.throwOn(400, ApiError, 'Some information is not correct.');
    req.throwOn(403, ApiError, 'User has access for users in accounts that they control.');
    req.throwOn(404, ApiError, 'User not found.');
    return req.callAsXml(
      'LdapUserResponse',
      ldapUserResponseSchema,
      requestOptions
    );
  }

  /**
   * Allows to create a new user.
   *
   * @param userId
   * @param domainName
   * @param body
   * @return Response from the API call
   */
  async createUser(
    userId: string,
    domainName: string,
    body?: LdapUser,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
    });
    req.xml('body', body, 'User', optional(ldapUserSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}`;
    req.throwOn(400, ApiError, 'Some information is not correct.');
    return req.callAsXml(
      'LdapUserResponse',
      ldapUserResponseSchema,
      requestOptions
    );
  }

  /**
   * Determine whether the current user has named permission
   *
   * @param domainName
   * @param permission
   * @return Response from the API call
   */
  async getValidateUserPermission(
    domainName: string,
    permission?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUsersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      permission: [permission, optional(string())],
    });
    req.query('permission', mapped.permission);
    req.appendTemplatePath`/${mapped.domainName}/users/permittedaccess`;
    req.throwOn(404, ApiError, 'User does not have the named permission in their set of named permissions');
    return req.callAsXml(
      'LdapUsersResponse',
      ldapUsersResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about  all users.
   *
   * @param domainName
   * @param suggestions
   * @param page
   * @param size
   * @param scope
   * @param isActive
   * @return Response from the API call
   */
  async getUsers(
    domainName: string,
    suggestions?: string,
    page?: string,
    size?: string,
    scope?: string,
    isActive?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUsersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      suggestions: [suggestions, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(string())],
      scope: [scope, optional(string())],
      isActive: [isActive, optional(boolean())],
    });
    req.query('suggestions', mapped.suggestions);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('scope', mapped.scope);
    req.query('isActive', mapped.isActive);
    req.appendTemplatePath`/${mapped.domainName}/users`;
    return req.callAsXml(
      'LdapUsersResponse',
      ldapUsersResponseSchema,
      requestOptions
    );
  }

  /**
   * Update user's password. Only logged user can change your password.
   *
   * @param userId
   * @param domainName
   * @param password
   * @param body
   * @return Response from the API call
   */
  async updatePassword(
    userId: string,
    domainName: string,
    password: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPasswordResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      password: [password, string()],
    });
    req.xml('body', body, 'Password', optional(unknown()));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.password}`;
    req.throwOn(400, ApiError, 'Password is not correct.');
    req.throwOn(403, ApiError, 'Access Denied');
    return req.callAsXml(
      'LdapUserPasswordResponse',
      ldapUserPasswordResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param userId
   * @param accountId
   * @param domainName
   * @param accounts
   * @return Response from the API call
   */
  async getUserAccount(
    userId: string,
    accountId: number,
    domainName: string,
    accounts: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserAccountResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      accountId: [accountId, number()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.accountId}/${mapped.domainName}/${mapped.accounts}`;
    return req.callAsXml(
      'UserAccountResponse',
      userAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param userId
   * @param accountId
   * @param domainName
   * @param accounts
   * @return Response from the API call
   */
  async addUserAccount(
    userId: string,
    accountId: number,
    domainName: string,
    accounts: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserAccountResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      accountId: [accountId, number()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.accountId}/${mapped.domainName}/${mapped.accounts}`;
    return req.callAsXml(
      'UserAccountResponse',
      userAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param userId
   * @param accountId
   * @param domainName
   * @param accounts
   * @return Response from the API call
   */
  async deleteUserAccount(
    userId: string,
    accountId: number,
    domainName: string,
    accounts: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserAccountResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      accountId: [accountId, number()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.accountId}/${mapped.domainName}/${mapped.accounts}`;
    return req.callAsXml(
      'UserAccountResponse',
      userAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about accounts associated with user.
   *
   * @param userId
   * @param domainName
   * @param accounts
   * @return Response from the API call
   */
  async getUserAccounts(
    userId: string,
    domainName: string,
    accounts: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserAccountsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.accounts}`;
    req.throwOn(403, ApiError, 'User has system-wide scope.');
    req.throwOn(404, ApiError, 'User not found.');
    return req.callAsXml(
      'UserAccountsResponse',
      userAccountsResponseSchema,
      requestOptions
    );
  }

  /**
   * Allows the user replace associated accounts.
   *
   * @param userId
   * @param domainName
   * @param accounts
   * @param body
   * @return Response from the API call
   */
  async updateReplaceUserAccounts(
    userId: string,
    domainName: string,
    accounts: string,
    body?: LdapAccountsDto,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserAccountsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      accounts: [accounts, string()],
    });
    req.xml('body', body, 'AccountList', optional(ldapAccountsDtoSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.accounts}`;
    req.throwOn(403, ApiError, 'Account scope user can add just own accounts.');
    req.throwOn(404, ApiError, 'User not found.');
    req.throwOn(422, ApiError, 'Some information is not correct.');
    return req.callAsXml(
      'UserAccountsResponse',
      userAccountsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the details of a change, with prior and new values as appropriate.
   *
   * @param userid
   * @param eventId
   * @param domainName
   * @return Response from the API call
   */
  async getUserEventDetails(
    userid: string,
    eventId: number,
    domainName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserActivityEventDetailsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userid: [userid, string()],
      eventId: [eventId, number()],
      domainName: [domainName, string()],
    });
    req.appendTemplatePath`/${mapped.userid}/users/${mapped.eventId}/logs/${mapped.domainName}`;
    req.throwOn(404, ApiError, 'Event is not associated with impacted user or does not exist.');
    return req.callAsXml(
      'UserActivityEventDetailsResponse',
      userActivityEventDetailsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about user access activity in date range.
   *
   * @param userid
   * @param domainName
   * @param page
   * @param size
   * @param startDate
   * @param endDate
   * @return Response from the API call
   */
  async getUserEventsLog(
    userid: string,
    domainName: string,
    page?: string,
    size?: number,
    startDate?: string,
    endDate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserActivityEventLogResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userid: [userid, string()],
      domainName: [domainName, string()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      startDate: [startDate, optional(string())],
      endDate: [endDate, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('startDate', mapped.startDate);
    req.query('endDate', mapped.endDate);
    req.appendTemplatePath`/${mapped.userid}/users/${mapped.domainName}/logs`;
    req.throwOn(400, ApiError, 'Incorrect date range.');
    return req.callAsXml(
      'UserEventLog',
      userActivityEventLogResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves all user preferences.
   *
   * @param userId
   * @param domainName
   * @param preferences
   * @return Response from the API call
   */
  async getLdapUserPreferencesXref(
    userId: string,
    domainName: string,
    preferences: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.preferences}`;
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates preference list for single user.
   *
   * @param userId
   * @param domainName
   * @param preferences
   * @param body
   * @return Response from the API call
   */
  async updateLdapUserPreferencesXref(
    userId: string,
    domainName: string,
    preferences: string,
    body?: LdapUserPreferences,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.xml(
      'body',
      body,
      'UserPreferences',
      optional(ldapUserPreferencesSchema)
    );
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.preferences}`;
    req.throwOn(422, ApiError, 'The information was not processed and error appeared.');
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Creates user-preference relation if it doesn't exist.
   *
   * @param userId
   * @param domainName
   * @param preferences
   * @param body
   * @return Response from the API call
   */
  async createGetLdapUserPreferenceXref(
    userId: string,
    domainName: string,
    preferences: string,
    body?: LdapUserPreference,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.xml('body', body, 'UserPreference', optional(ldapUserPreferenceSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.preferences}`;
    req.throwOn(409, ApiError, 'User preference already exists.');
    req.throwOn(422, ApiError, 'Provided data in payload is incorrect.');
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves user preference by name if it exists.
   *
   * @param userId
   * @param preferenceName
   * @param domainName
   * @param preferences
   * @return Response from the API call
   */
  async getLdapUserPreferenceXref2(
    userId: string,
    preferenceName: string,
    domainName: string,
    preferences: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      preferenceName: [preferenceName, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.preferenceName}/${mapped.domainName}/${mapped.preferences}`;
    req.throwOn(404, ApiError, 'The preference does not exist.');
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates user-preference relation.
   *
   * @param userId
   * @param preferenceName
   * @param domainName
   * @param preferences
   * @param body
   * @return Response from the API call
   */
  async updateGetLdapUserPreferenceXref1(
    userId: string,
    preferenceName: string,
    domainName: string,
    preferences: string,
    body?: LdapUserPreference,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      preferenceName: [preferenceName, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.xml('body', body, 'UserPreference', optional(ldapUserPreferenceSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.preferenceName}/${mapped.domainName}/${mapped.preferences}`;
    req.throwOn(422, ApiError, 'Provided data in payload is incorrect.');
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Removes user-preference relation.
   *
   * @param userId
   * @param preferenceName
   * @param domainName
   * @param preferences
   * @return Response from the API call
   */
  async deleteLdapUserPreferenceXref(
    userId: string,
    preferenceName: string,
    domainName: string,
    preferences: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferenceXrefResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      preferenceName: [preferenceName, string()],
      domainName: [domainName, string()],
      preferences: [preferences, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.preferenceName}/${mapped.domainName}/${mapped.preferences}`;
    req.throwOn(404, ApiError, 'User preference does not exist.');
    return req.callAsXml(
      'LdapUserPreferenceResponse',
      ldapUserPreferenceXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about first name, last name, company name, contact telephone numbers and
   * address by unique user name.
   *
   * @param userId
   * @param domainName
   * @param profile
   * @return Response from the API call
   */
  async getUserProfile(
    userId: string,
    domainName: string,
    profile: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserProfileResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      profile: [profile, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.profile}`;
    req.throwOn(404, ApiError, 'The user does not exist.');
    return req.callAsXml(
      'UserProfileResponse',
      userProfileResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates the information about user profile by unique user name. Note, that empty fields will work
   * like delete.
   *
   * @param userId
   * @param domainName
   * @param profile
   * @param body
   * @return Response from the API call
   */
  async updateUpsertUserProfile(
    userId: string,
    domainName: string,
    profile: string,
    body?: UserProfile,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserProfileResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      profile: [profile, string()],
    });
    req.xml('body', body, 'UserProfile', optional(userProfileSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.profile}`;
    req.throwOn(400, ApiError, 'The user don\'t put telephone number.');
    return req.callAsXml(
      'UserProfileResponse',
      userProfileResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about permission by unique name, related to specific user.
   *
   * @param userId
   * @param roleId
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async getLdapUserRoles(
    userId: string,
    roleId: string,
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserRoleXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      roleId: [roleId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.roleId}/${mapped.domainName}/${mapped.roles}`;
    req.throwOn(404, ApiError, 'The user, role or user-to-role association does not exist.');
    return req.callAsXml(
      'LdapUserRoleResponse',
      ldapUserRoleXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Adds role to user.
   *
   * @param userId
   * @param roleId
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async createLdapUserRoleXref(
    userId: string,
    roleId: string,
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserRoleXrefResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      roleId: [roleId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.roleId}/${mapped.domainName}/${mapped.roles}`;
    req.throwOn(403, ApiError, 'Create failed, role cannot be associated to certain user.');
    return req.callAsXml(
      'LdapUserRoleResponse',
      ldapUserRoleXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Removes specified role from user.
   *
   * @param userId
   * @param roleId
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async deleteLdapUserRoleXref(
    userId: string,
    roleId: string,
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserRoleXrefResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      roleId: [roleId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.roleId}/${mapped.domainName}/${mapped.roles}`;
    req.throwOn(404, ApiError, 'The role is not related to certain user.');
    return req.callAsXml(
      'LdapUserRoleResponse',
      ldapUserRoleXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param userId
   * @param domainName
   * @param roles
   * @return Response from the API call
   */
  async getLdapUserRoles1(
    userId: string,
    domainName: string,
    roles: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserRolesXrefResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.roles}`;
    return req.callAsXml(
      'LdapUserRolesResponse',
      ldapUserRolesXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Rewrites all existing roles, related to user.
   *
   * @param userId
   * @param domainName
   * @param roles
   * @param body
   * @return Response from the API call
   */
  async updateLdapUserRoles(
    userId: string,
    domainName: string,
    roles: string,
    body?: LdapRoles,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserRolesXrefResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      roles: [roles, string()],
    });
    req.xml('body', body, 'RoleList', optional(ldapRolesSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.roles}`;
    req.throwOn(400, ApiError, 'Data in body formed in wrong way, validation error appears.');
    req.throwOn(403, ApiError, 'Update failed, some of roles cannot be associated with user.');
    req.throwOn(422, ApiError, 'Some of roles cannot be found.');
    return req.callAsXml(
      'LdapUserRolesResponse',
      ldapUserRolesXrefResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information about scope and active status by unique user name.
   *
   * @param userId
   * @param domainName
   * @param settings
   * @return Response from the API call
   */
  async getUserSettings(
    userId: string,
    domainName: string,
    settings: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      settings: [settings, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.settings}`;
    req.throwOn(400, ApiError, 'The user has more then one scope.');
    req.throwOn(404, ApiError, 'The user does not exist.');
    return req.callAsXml(
      'UserSettingsResponse',
      userSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates the information about scope and active by unique user name.
   *
   * @param userId
   * @param domainName
   * @param settings
   * @param body
   * @return Response from the API call
   */
  async updateUpsertUserSettings(
    userId: string,
    domainName: string,
    settings: string,
    body?: UserSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UserSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
      settings: [settings, string()],
    });
    req.xml('body', body, 'UserSettings', optional(userSettingsSchema));
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}/${mapped.settings}`;
    req.throwOn(400, ApiError, 'The user try setup scope that higher than his own.');
    req.throwOn(403, ApiError, 'The user try activate another user having no accoounts assigned to it.');
    return req.callAsXml(
      'UserSettingsResponse',
      userSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param dataType
   * @return Response from the API call
   */
  async getNumberAssignmentAnalytics(
    accountId: number,
    dataType: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AnalyticsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      dataType: [dataType, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/analytics/${mapped.dataType}`;
    return req.callAsXml(
      'AnalyticsResult',
      analyticsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAnalytics(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/analytics`;
    req.throwOn(404, ApiError, 'Not Found - if the API call does not specify the type of data.');
    return req.call(requestOptions);
  }

  /**
   * Retrieve a list of the TelephoneNumbersAssignment orders that are associated with the account. <p>A
   * maximum of 1,000 orders can be retrieved per request. If no date range or specific query parameter
   * (marked by <b class="required">*</b> below) is provided, the order results will be limited to the
   * last two years.</p>
   *
   * @param accountId
   * @param status
   * @param tn
   * @param customerOrderId
   * @param activityState
   * @param createdDateFrom
   * @param createdDateTo
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param orderIdFragment
   * @param action
   * @return Response from the API call
   */
  async getOrders(
    accountId: number,
    status?: string[],
    tn?: string,
    customerOrderId?: string,
    activityState?: string[],
    createdDateFrom?: string,
    createdDateTo?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    orderIdFragment?: string,
    action?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(array(string()))],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      activityState: [activityState, optional(array(string()))],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      action: [action, optional(string())],
    });
    req.query('status', mapped.status);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('activityState', mapped.activityState);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('action', mapped.action);
    req.appendTemplatePath`/accounts/${mapped.accountId}/numbersAssignment`;
    req.throwOn(400, ApiError, 'Bad Request.  If any errors are found in the processing of the query string a 400 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'TelephoneNumbersAssignmentOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Create a TelephoneNumbersAssignment order to register the assignment status of a list of telephone
   * numbers.  The telephone numbers can be declared to be either ASSIGNED or UNASSIGNED.The key data
   * elements in the submission are - <table style="text-align: left; width: 80%;" border="1"
   * cellpadding="2" cellspacing="2">  <tbody>    <tr>      <td>CustomerOrderID</td>      <td>An order ID
   * created by the customer for their tracking purposes. Only alphanumeric values, dashes and spaces are
   * allowed. Max length is 40 characters.</td>    </tr>    <tr>      <td>Action</td>      <td>(Required)
   * Declare whether the listed Telephone Numbers are to be ASSIGNED or UNASSIGNED</td>    </tr>
   * </tbody></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOrder(
    accountId: number,
    body?: TelephoneNumbersAssignmentOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TelephoneNumbersAssignmentOrder',
      optional(telephoneNumbersAssignmentOrderPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/numbersAssignment`;
    req.throwOn(400, ApiError, 'Bad Request <br> A 400 response Indicates that the order could not be created.Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Creates a csr order.<br>Upon a successfully-submitted payload, the order will have a status of
   * "RECEIVED".<br><br><br>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createCsrOrder(
    accountId: number,
    body?: Csr,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Csr', optional(csrSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/csrs`;
    req.throwOn(400, ApiError, 'The order failed. One of the input parameters is invalid.');
    req.throwOn(409, ApiError, 'Action can not be performed because account does not have CSR product feature enabled.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the information associated with the specified csr order ID number.
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async retrieveCsrOrder(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/csrs/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Order ID has invalid format.');
    req.throwOn(404, ApiError, 'Order does not exists or belongs to different account.');
    req.throwOn(409, ApiError, 'Action can not be performed because account does not have CSR product feature enabled.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Replaces the existing csr conditional data with specificed csr conditional data. To cancel CSR order
   * need provide Status tag with REQUESTED_CANCEL value. Note that csr order must be a non-real time
   * with PROCESSING or ACTION_REQUIRED status.
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async updateCsrOrder(
    accountId: number,
    orderid: string,
    body?: Csr,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'Csr', optional(csrSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/csrs/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'There was an error replacing the conditional data for the order.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve a list of the DLDA orders that are associated with the account. <p>A maximum of 1,000
   * orders can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param lastModifiedAfter
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @return Response from the API call
   */
  async getDldaOrder2(
    accountId: number,
    lastModifiedAfter?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
    });
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.appendTemplatePath`/accounts/${mapped.accountId}/dldas`;
    req.throwOn(404, ApiError, 'Not Found <br> If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Create DLDA order to associate the street address with the telephone number.The key data elements in
   * the submission are - <table style="text-align: left; width: 80%;" border="1" cellpadding="2"
   * cellspacing="2">  <tbody>    <tr>      <td>TelephoneNumbers</td>      <td>A list of telephone
   * numbers you need to bind information from payload.</td>    </tr>    <tr>
   * <td>SubscriberType</td>      <td>Can be RESIDENTIAL or BUSINESS.  The element is required.</td>
   * </tr>    <tr>      <td>ListingType</td>      <td>Can be LISTED, NON_LISTED or NON_PUBLISHED. The
   * element is required</td>    </tr>    <tr>      <td>ListingName</td>      <td>This field is required.
   * Inner fields: FirstName (this field is required in case RESIDENTIAL SubscriberType is chosen),
   * FirstName2, LastName (this field is required), Designation, TitleOfLineage, TitleOfAddress,
   * TitleOfAddress2, TitleOfLineageName2, TitleOfAddressName2, TitleOfAddress2Name2, and PlaceListingAs
   * are optional<br>Please see the note below on sorting of Business Listings.</td>    </tr>    <tr>
   * <td>ListAddress</td>      <td>Can be true or false. The element is required.</td>    </tr>    <tr>
   * <td>Address</td>      <td>This field is required. Inner fields: HousePrefix, HouseNumber,
   * HouseSuffix, PreDirectional, StreetName, StreetSuffix, PostDirectional, AddressLine2, City,
   * StateCode, Zip, PlusFour and AddressType=DLDA.<br>City, HouseNumber, StreetName, City, State and
   * Zipcode are required fields.</td>    </tr>    <tr>      <td>CustomerOrderId</td>      <td>The
   * Customer Order ID is an ID assigned by the account owner to provide a reference number for the Order.
   * The element is optional. Only alphanumeric values, dashes and spaces are allowed. Max length is 40
   * characters.</td>    </tr>  </tbody></table><b>Business Listings...</b> <br>Business Listings sort
   * differently than Residential Listings, and must be submitted accordingly.  Since Business Listings
   * sort starting at the beginning of the name, where Residential Listings sort on Last Name, the parts
   * of the business name that will govern the sorting need to be entered in the LastName field.  For
   * example, Joe's Pizza sorts starting with Joe, so the entire business name would be entered in the
   * LastName field, and the Firstname could be left blank.  If there was a portion of the name that was
   * not important from a sorting perspective (perhaps "the best pizza in town"), that portion could be
   * placed in the FirstName field.<br>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createDldaOrder(
    accountId: number,
    body?: DldaOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'DldaOrder', optional(dldaOrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/dldas`;
    req.throwOn(400, ApiError, 'Bad Request <br> A 400 response Indicates that the order could not be created.Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a DLDA Order with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getDldaOrder1(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/dldas/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Update DLDA order to associate the street address with the telephone number.The key data elements in
   * the submission are -     <table style="text-align: left; width: 80%;"     border="1" cellpadding="2"
   * cellspacing="2">      <tbody>        <tr>          <td>TelephoneNumbers</td>          <td>A list of
   * telephone numbers you need to bind information from payload.</td>        </tr>        <tr>
   * <td>AccountType</td>          <td>Can be RESIDENTIAL or BUSINESS.  The element is required.</td>
   * </tr>        <tr>          <td>ListingType</td>          <td>Can be LISTED, NON_LISTED or
   * NON_PUBLISHED. The element is required</td>        </tr>        <tr>          <td>ListingName</td>
   * <td>Inner fields: FirstName, FirstName2, LastName, Designation, TitleOfLineage,
   * TitleOfAddress, TitleOfAddress2, TitleOfLineageName2, TitleOfAddressName2, TitleOfAddress2Name2,
   * PlaceListingAs.</td>        </tr>        <tr>          <td>ListAddress</td>          <td>Can be true
   * or false. The element is required.</td>        </tr>        <tr>          <td>Address</td>
   * <td>This field is required. Inner fields: HousePrefix, HouseNumber, HouseSuffix, PreDirectional,
   * StreetName, StreetSuffix, PostDirectional, AddressLine2, City, StateCode, Zip, PlusFour,
   * AddressType</td>        </tr>        <tr>          <td>CustomerOrderId</td>          <td>The
   * Customer Order ID is an ID assigned by the account owner to provide a reference number for the Order.
   * The element is optional. Only alphanumeric values, dashes and spaces are allowed. Max length is 40
   * characters.</td>        </tr>      </tbody>    </table>
   *
   * @param accountId
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async updateDldaOrder(
    accountId: number,
    orderId: string,
    body?: DldaOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.xml('body', body, 'DldaOrder', optional(dldaOrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/dldas/${mapped.orderId}`;
    req.throwOn(400, ApiError, 'Bad Request <br> A 400 response Indicates that the order could not be modified. The payload is echoed with the Errors identified.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the e911 information associated with that telephone number.
   *
   * @param tn
   * @return Response from the API call
   */
  async getUcTrunkingConfiguration1(
    tn: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnE911AddressResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ tn: [tn, string()] });
    req.appendTemplatePath`/tns/${mapped.tn}/e911`;
    return req.callAsXml(
      'TnE911AddressResponse',
      tnE911AddressResponseSchema,
      requestOptions
    );
  }

  /**
   * The GET operation is used to fetch the emergency notification recipient specified by its identifier.
   * <br>URI parameters:<ul>  <li>  <b>accountId</b> - the account id of the account to which the
   * emergency notification recipient belongs  </li>  <li>  <b>enrId</b> - the identifier assigned to the
   * emergency notification recipient when it was created  </li></ul>
   *
   * @param accountId
   * @param recipientId
   * @return Response from the API call
   */
  async getEmergencyNotificationRecipient(
    accountId: number,
    recipientId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      recipientId: [recipientId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencyNotificationRecipients/${mapped.recipientId}`;
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to view emergency notification recipients, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p><b>Condition:</b> The emergency notification recipient identifier does not exist, or does not exist for the specified account id. <br> <b>Error Description:</b> The resource does not exist </p> <br>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * <p> Retrieve a list of emergency notification recipients configured for this account. <br> Results
   * can be paginated and filtered using the following query parameters. </p><p> <b>Query parameters:
   * </b></p><p> The GET operation has no request payload, but the accountId must be specified in the URI
   * parameter.Results are returned by default in the order of newest to oldest modification date of the
   * Emergency Notification Recipient.  This default order is reversed from oldest to newest when the
   * ModifiedAfterDate query parameter is included in the query.</p><p>Query parameters act as filters on
   * the data. If more than one query parameter is provided, the results will be the intersection of the
   * results from each query parameter. In other words, the query parameters are logically ANDed.Query
   * parameters are appended to the end of the endpoint, separated by a '?' and in the format
   * parameter=value.  If you wish to specify more than one query parameter, separate them using an '&'
   * character.  The order of query parameters does not matter.  For example:GET
   * /accounts/{accountId}/emergencyNotificationRecipients?EnrDescription=front
   * desk&EnrNotificationType=TTS...will return all Emergency Notification Recipients having a
   * description field including the string "front desk", and having a notification type of TTS.The
   * following query parameters are supported.  All query parameters are optional. </p> <table>
   * <tr>           <th>Parameter Name</th>           <th>Example</th>           <th>Default</th>
   * <th>Usage</th>         </tr>         <tr>             <td valign="top">                 <p>
   * ModifiedAfterDate                 </p>             </td>             <td  valign="top">
   * <p>                     ModifiedAfterDate=                     2020-03-23T17:34:00Z
   * </p>             </td>             <td valign="top">                 <p>
   * No filter                 </p>             </td>             <td valign="top">
   * <p>                     Include results only for orders having order last modified date and
   * time after the date and time specified in this parameter. Note that inclusion of this parameter
   * reverses the default sort order of the results to ascending in date/time (i.e. from oldest to
   * newest). If you are looking for the ModifiedBeforeDate query parameter, please see the Page
   * parameter.                 </p>             </td>         </tr>         <tr>             <td
   * valign="top">                 <p>                     ModifiedByUser                 </p>
   * </td>             <td valign="top">                 <p>                     ModifiedByUser=jgilmore
   * </p>             </td>             <td  valign="top">                 <p>
   * No filter                 </p>             </td>             <td valign="top">
   * <p>                     Include results only for orders last modified by the user specified in
   * this parameter.                 </p>             </td>         </tr>         <tr>             <td
   * valign="top">                 <p>                     EnrDescription                 </p>
   * </td>             <td  valign="top">                 <p>                     EnrDescription=front
   * desk                 </p>             </td>             <td  valign="top">                 <p>
   * No filter                 </p>             </td>             <td  valign="top">
   * <p>                     A substring that will exist in all Emergency Notification Recipient
   * Descriptions returned.                 </p>             </td>         </tr>         <tr>
   * <td valign="top">                 <p>                     EnrNotificationType                 </p>
   * </td>             <td valign="top">                 <p>
   * EnrNotificationType=SMS                 </p>             </td>             <td  valign="top">
   * <p>                     No filter                 </p>             </td>             <td
   * valign="top">                 <p>                     The type of notification (EMAIL, SMS, TTS, or
   * CALLBACK) specified for Emergency Notification Recipients returned.                 </p>
   * </td>         </tr>         <tr>             <td valign="top">                 <p>
   * EnrSmsTn                 </p>             </td>             <td valign="top">                 <p>
   * EnrSmsTn=9195551212                 </p>             </td>             <td
   * valign="top">                 <p>                     No filter                 </p>
   * </td>             <td  valign="top">                 <p>                     The Short Message
   * Service telephone number in all SMS type Emergency Notification Recipients returned.
   * </p>             </td>         </tr>         <tr>             <td valign="top">                 <p>
   * EnrTtsTn                 </p>             </td>             <td valign="top">
   * <p>                     EnrTtsTn=7045553777                 </p>             </td>
   * <td valign="top">                 <p>                     No filter                 </p>
   * </td>             <td valign="top">                 <p>                     The Text To Speech
   * telephone number in all TTS type Emergency Notification Recipients returned.                 </p>
   * </td>         </tr>         <tr>             <td valign="top">                 <p>
   * EnrEmailAddress                 </p>             </td>             <td valign="top">
   * <p>                     EnrEmailAddress=                     fred9982@gmail.com
   * </p>             </td>             <td valign="top">                 <p>
   * No filter                 </p>             </td>             <td  valign="top">                 <p>
   * The email address in all EMAIL type Emergency Notification Recipients returned.
   * </p>             </td>         </tr>         <tr>             <td valign="top">
   * <p>                     EnrCallbackUrl                 </p>             </td>
   * <td  valign="top">                 <p>                     EnrCallbackUrl=                     https:
   * //not.company.com                 </p>             </td>             <td valign="top">
   * <p>                     No filter                 </p>             </td>             <td
   * valign="top">                 <p>                     The callback URL in all CALLBACK type
   * Emergency Notification Recipients returned.                 </p>             </td>         </tr>
   * <tr>             <td valign="top">                 <p>                     EnrCallbackUsername
   * </p>             </td>             <td valign="top">                 <p>
   * EnrCallbackUsername=                     jgilmore                 </p>             </td>
   * <td valign="top">                 <p>                     No filter                 </p>
   * </td>             <td valign="top">                 <p>                     The callback
   * username in all CALLBACK type Emergency Notification Recipients returned.                 </p>
   * </td>         </tr>         <tr>             <td valign="top">                 <p>
   * Page                 </p>             </td>             <td valign="top">
   * <p>                     Page=                     2020-03-15T14:00:00.000-04:00                 </p>
   * </td>             <td valign="top">                 <p>                     Now
   * </p>             </td>             <td valign="top">                 <p>
   * This represents the position in the data set from which you want your output to begin.  If this
   * parameter is omitted, results will include Emergency Notification Recipients last modified on or
   * before the current date and time.  If a date and time is provided, results will include Emergency
   * Notification Recipients last modified on or before that date and time.  Date/time format is YYYY-MM-
   * DDTHH:MM:SS.mmmZ, where the Z indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm"
   * represents the local time offset, plus or minus, from UTC time.                 </p>
   * </td>         </tr>         <tr>             <td  valign="top">                 <p>
   * Size                 </p>             </td>             <td  valign="top">                 <p>
   * Size=20                 </p>             </td>             <td  valign="top">
   * <p>                     100                 </p>             </td>             <td
   * valign="top">                 <p>                     The maximum number of Emergency Notification
   * Recipient results to include in the response payload.  This value may be between 1 and 500.
   * </p>             </td>         </tr> </table>
   *
   * @param accountId
   * @param page
   * @param size                Example: 100
   * @param modifiedAfterDate
   * @param modifiedByUser
   * @param enrDescription
   * @param enrNotificationType
   * @param enrSmsTn
   * @param enrTtsTn
   * @param enrEmailAddress
   * @param enrCallbackUrl
   * @param enrCallbackUsername
   * @return Response from the API call
   */
  async getAllEmergencyNotificationRecipientForAccount(
    accountId: number,
    page?: string,
    size?: number,
    modifiedAfterDate?: string,
    modifiedByUser?: string,
    enrDescription?: string,
    enrNotificationType?: string,
    enrSmsTn?: string,
    enrTtsTn?: string,
    enrEmailAddress?: string,
    enrCallbackUrl?: string,
    enrCallbackUsername?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      modifiedAfterDate: [modifiedAfterDate, optional(string())],
      modifiedByUser: [modifiedByUser, optional(string())],
      enrDescription: [enrDescription, optional(string())],
      enrNotificationType: [enrNotificationType, optional(string())],
      enrSmsTn: [enrSmsTn, optional(string())],
      enrTtsTn: [enrTtsTn, optional(string())],
      enrEmailAddress: [enrEmailAddress, optional(string())],
      enrCallbackUrl: [enrCallbackUrl, optional(string())],
      enrCallbackUsername: [enrCallbackUsername, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('ModifiedAfterDate', mapped.modifiedAfterDate);
    req.query('ModifiedByUser', mapped.modifiedByUser);
    req.query('EnrDescription', mapped.enrDescription);
    req.query('EnrNotificationType', mapped.enrNotificationType);
    req.query('EnrSmsTn', mapped.enrSmsTn);
    req.query('EnrTtsTn', mapped.enrTtsTn);
    req.query('EnrEmailAddress', mapped.enrEmailAddress);
    req.query('EnrCallbackUrl', mapped.enrCallbackUrl);
    req.query('EnrCallbackUsername', mapped.enrCallbackUsername);
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationrecipients`;
    req.throwOn(400, ApiError, 'Bad request <br> <p><b>Condition:</b> Unrecognized query parameter <br> <b>Error Description:</b>Query parameter xxx is not recognized. </p> <br> <p><b>Condition:</b>Unsupported value for query parameter <br> <b>Error Description:</b>Invalid value xxx for query parameter yyy. Supported values are aaa, bbb, etc. </p>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b>User does not have permission to view emergency notification recipients, either due to Role/Permission or because the account is not configured for Emergency Notification Config.<br> <b>Error Description:</b>Access Denied </p>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * <p> Create a new emergency notification recipient.  <br>URI Parameters: <b>accountId</b> - the
   * bandwidth Dashboard account that this emergency notification recipient is to belong to
   * </p><p><b>Emergency notification recipient request elements</b></p><table border="1" cellspacing="0"
   * cellpadding="0" width="624">        <tbody>            <tr>                <td valign="top">
   * <p>                        <strong>Parameter</strong>                    </p>
   * </td>                <td width="351" valign="top">                    <p>
   * <strong>Description</strong>                    </p>                </td>            </tr>
   * <tr>                <td valign="top">                    <p>                        Description
   * </p>                </td>                <td width="351" valign="top">
   * <p>                        A mandatory 200 character description of the Emergency Notification
   * Recipient.  The contents of this field are freeform, but ideally should describe who is being
   * notified and by what means.  E.g. Voice notification to building 5 front desk.
   * </p>                </td>            </tr>            <tr>                <td valign="top">
   * <p>                        Type                    </p>                </td>
   * <td width="351" valign="top">                    <p>                        A mandatory field
   * indicating the means by which the emergency call notification will be made.  The choices are":"
   * EMAIL, SMS, TTS, and CALLBACK.  EMAIL sends an email to the specified email address.  SMS sends a
   * text message to the specified telephone number.  TTS sends a voice call with a text-to-speech
   * announcement to the specified telephone number.  CALLBACK causes invocation of a specified HTTPS URL.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        EmailAddress                    </p>
   * </td>                <td width="351" valign="top">                    <p>
   * An email address that must be specified when the Type is set to EMAIL.  The value must be
   * formatted like a valid email address.  E.g. FredJones@gmail.com.  An email address can be up to 254
   * characters long.                    </p>                </td>            </tr>            <tr>
   * <td valign="top">                    <p>                        Sms TelephoneNumber
   * </p>                </td>                <td width="351" valign="top">
   * <p>                        A telephone number capable of receiving text messages that must be
   * specified when Type is set to SMS.  Format is 11 digits":" 1NPANXXXXXX.                    </p>
   * </td>            </tr>            <tr>                <td valign="top">
   * <p>                        Tts TelephoneNumber                    </p>                </td>
   * <td width="351" valign="top">                    <p>                        A telephone number
   * capable of receiving voice calls that must be specified when Type is set to TTS.  Format is 11
   * digits":" 1NPANXXXXXX.                    </p>                </td>            </tr>            <tr>
   * <td valign="top">                    <p>                        Callback Url
   * </p>                </td>                <td width="351" valign="top">
   * <p>                        An https URL that must be provided when Type is set to CALLBACK.
   * The URL may optionally include one or mory query parameters.  E.g. https://foo.com/bar?
   * param=value.  The URL may be up to 256 characters.                    </p>                </td>
   * </tr>            <tr>                <td valign="top">                    <p>
   * Callback Username                    </p>                </td>                <td width="351"
   * valign="top">                    <p>                        A username to be used in Basic
   * Authentication of the callback that must be specified when Type is CALLBACK.  The username may be up
   * to 32 characters.                    </p>                </td>            </tr>            <tr>
   * <td valign="top">                    <p>                        Callback Password
   * </p>                </td>                <td width="351" valign="top">
   * <p>                        A password to be used in Basic Authentication of the callback that must
   * be specified when Type is CALLBACK.  Passwords may be up to 256 characters.  Passwords are not
   * included in GET responses.                    </p>                </td>            </tr>
   * </tbody>    </table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createEmergencyNotificationRecipient(
    accountId: number,
    body?: EmergencyNotificationRecipientPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'EmergencyNotificationRecipient',
      optional(emergencyNotificationRecipientPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationrecipients`;
    req.throwOn(400, ApiError, 'Bad request <br> <table border="1" cellspacing="0" cellpadding="0" width="624"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="351" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Missing or empty description </p> </td> <td width="351" valign="top"> <p> Description must be present and non-empty. </p> </td> </tr> <tr> <td valign="top"> <p> Missing type </p> </td> <td width="351" valign="top"> <p> Type is a mandatory element. </p> </td> </tr> <tr> <td valign="top"> <p> Unrecognized type value </p> </td> <td width="351" valign="top"> <p> Type value must be one of \'EMAIL\', \'SMS\', \'TTS\', or \'CALLBACK\'. </p> </td> </tr> <tr> <td valign="top"> <p> Missing data required for type - for example, type is EMAIL, but no EmailAddress element is present. </p> </td> <td width="351" valign="top"> <p> When Type xxx is specified, yyy must be included., where xxx is one of the type values and yyy is the element that is missing. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed email </p> </td> <td width="351" valign="top"> <p> Invalid EmailAddress.  Format should be foo@bar.com.  Max length is 254 characters. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed telephone number </p> </td> <td width="351" valign="top"> <p> Invalid TelephoneNumber.  Telephone number must be 11 digits in format 1NPANXXXXXX. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed url </p> </td> <td width="351" valign="top"> <p> Invalid Url.  Format should be https://foo.bar[?param=val]. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed username </p> </td> <td width="351" valign="top"> <p> Invalid Username.  Username must be between 1 and 32 characters. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed password </p> </td> <td width="351" valign="top"> <p> Invalid Password.  Password must be between 1 and 256 characters. </p> </td> </tr> </tbody> </table>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to configure emergency notification recipients, either due to Role/Permission or because the account is not enabled for Emergency Notifications. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(409, ApiError, 'Conflict <br> <p> <b>Condition:</b> Duplicate entry <br> <b>Error Description:</b> An entry with an identical recipient already exists. Identifier xxx., where xxx is replaced with the emergency notification recipient Identifier of the existing entry.</p>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * <p>The PUT operation is used to replace an emergency notification recipient without changing its
   * identifier value.  All emergency notification recipient fields must be specified, even if they are
   * not changing.URI parameters: The account id of the account to which the emergency notification
   * recipient belongs.  The identifier assigned to the emergency notification recipient when it was
   * created. </p><p>Emergency notification recipient request elements:</p><b>Description</b> - A
   * mandatory 200 character description of the Emergency Notification Recipient.  The contents of this
   * field are freeform, but ideally should describe who is being notified and by what means.  E.g. Voice
   * notification to building 5 front desk.<br><br><b>Type</b> - A mandatory field indicating the means
   * by which the emergency call notification will be made.  The choices are: EMAIL, SMS, TTS, and
   * CALLBACK.  EMAIL sends an email to the specified email address.  SMS sends a text message to the
   * specified telephone number.  TTS sends a voice call with a text-to-speech announcement to the
   * specified telephone number.  CALLBACK causes invocation of a specified HTTPS URL.
   * <br><br><b>EmailAddress</b> - An email address that must be specified when the Type is set to EMAIL.
   * The value must be formatted like a valid email address.  E.g. FredJones@gmail.com.  An email
   * address can be up to 254 characters long.<br><br><b>Sms TelephoneNumber</b> - A telephone number
   * capable of receiving text messages that must be specified when Type is set to SMS.  Format is 11
   * digits: 1NPANXXXXXX.<br><br><b>Tts TelephoneNumber</b> - A telephone number capable of receiving
   * voice calls that must be specified when Type is set to TTS.  Format is 11 digits: 1NPANXXXXXX.
   * <br><br><b>Callback Url</b> - An https URL that must be provided when Type is set to CALLBACK.  The
   * URL may optionally include one or mory query parameters.  E.g. https://foo.com/bar?param=value.  The
   * URL may be up to 256 characters.<br><br><b>Callback Username</b> - A username to be used in Basic
   * Authentication of the callback that must be specified when Type is CALLBACK.  The username may be up
   * to 32 characters.<br><br><b>Callback Password</b> - A password to be used in Basic Authentication of
   * the callback that must be specified when Type is CALLBACK.  Passwords may be up to 256 characters.
   * Passwords are not included in GET responses.<br><br>
   *
   * @param accountId
   * @param enrId
   * @param body
   * @return Response from the API call
   */
  async updateEmergencyNotificationRecipient(
    accountId: number,
    enrId: string,
    body?: EmergencyNotificationRecipientPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      enrId: [enrId, string()],
    });
    req.xml(
      'body',
      body,
      'EmergencyNotificationRecipient',
      optional(emergencyNotificationRecipientPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationrecipients/${mapped.enrId}`;
    req.throwOn(400, ApiError, 'Bad request <br> <table border="1" cellspacing="0" cellpadding="0" width="624"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="351" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Missing or empty description </p> </td> <td width="351" valign="top"> <p> Description must be present and non-empty. </p> </td> </tr> <tr> <td valign="top"> <p> Missing type </p> </td> <td width="351" valign="top"> <p> Type is a mandatory element. </p> </td> </tr> <tr> <td valign="top"> <p> Unrecognized type value </p> </td> <td width="351" valign="top"> <p> Type value must be one of \'EMAIL\', \'SMS\', \'TTS\', or \'CALLBACK\'. </p> </td> </tr> <tr> <td valign="top"> <p> Missing data required for type - for example, type is EMAIL, but no EmailAddress element is present. </p> </td> <td width="351" valign="top"> <p> When Type xxx is specified, yyy must be included., where xxx is one of the type values and yyy is the element that is missing. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed email </p> </td> <td width="351" valign="top"> <p> Invalid EmailAddress.  Format should be foo@bar.com.  Max length is 254 characters. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed telephone number </p> </td> <td width="351" valign="top"> <p> Invalid TelephoneNumber.  Telephone number must be 11 digits in format 1NPANXXXXXX. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed url </p> </td> <td width="351" valign="top"> <p> Invalid Url.  Format should be https://foo.bar[?param=val]. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed username </p> </td> <td width="351" valign="top"> <p> Invalid Username.  Username must be between 1 and 32 characters. </p> </td> </tr> <tr> <td valign="top"> <p> Malformed password </p> </td> <td width="351" valign="top"> <p> Invalid Password.  Password must be between 1 and 256 characters. </p> </td> </tr> </tbody> </table>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to configure emergency notification recipients, either due to Role/Permission or because the account is not enabled for Emergency Notifications. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p> <b>Condition:</b> Specified emergency notification recipient ID does not exist for this account <br> <b>Error Description:</b> The resource does not exist </p>');
    req.throwOn(409, ApiError, '<p> <b>Condition:</b> Duplicate entry <br> <b>Error Description:</b> An entry with an identical recipient already exists. Identifier xxx., where xxx is replaced with the emergency notification recipient Identifier of the existing entry. </p> <br>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * The DELETE operation is used to remove the emergency notification recipient specified by its
   * identifier. <br><br>An emergency notification recipient cannot be removed if it is still used by an
   * emergency notification group. If you wish to remove an emergency notification recipient that is
   * associated with an emergency notificaiton group, use the
   * /account/{accountId}/emergencyNotificationGroupOrders endpoint to remove the group or modify the
   * group to no longer use this emergency notification recipient.URI parameters:    <ul>      <li>
   * <b>accountId</b> - the account id of the account to which the emergency notification recipient
   * belongs      </li>      <li>      <b>enrId</b> - the identifier assigned to the emergency
   * notification recipient when it was created      </li>    </ul>
   *
   * @param accountId
   * @param enrId
   * @return Response from the API call
   */
  async deleteEmergencyNotificationRecipient(
    accountId: number,
    enrId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      enrId: [enrId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationrecipients/${mapped.enrId}`;
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to configure emergency notification recipients, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p><b>Condition:</b> The emergency notification recipient identifier does not exist, or does not exist for the specified account id. <br> <b>Error Description:</b> The resource does not exist </p> <br>');
    req.throwOn(409, ApiError, 'Conflict <br> <p> <b>Condition:</b> Attempt to delete an emergency notification recipient that is referenced by an emergency notification group. <br> <b>Error Description:</b> Emergency notification recipient with identifier xxx is being used by emergency notification group with identifier yyy. Please remove the recipient reference from the group prior to removing the recipient., where xxx is replaced by the emergency notification recipient ID and yyy is replaced by the emergency notification group ID. </p>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * <p> The GET operation provides a means of fetching all of the emergency notification group order
   * history for an account. <br>A number of query parameters are provided to filter the results. <br>URI
   * Parameters: <b>accountId</b> - the account id of the account to which the emergency notification
   * recipient belongs </p><p>The GET operation has no payload, although the accountId URI parameter is
   * mandatory and a number of optional query parameters may be added.Results are returned by default in
   * the order of newest to oldest creation date of the Emergency Notification Group Order. This default
   * order is reversed from oldest to newest when the CreatedAfterDate query parameter is included in the
   * query.Query parameters are appended to the end of the endpoint, separated by a '?' and in the format
   * parameter=value. If you wish to specify more than one query parameter, separate them using an '&'
   * character. The order of query parameters does not matter. For example: <br>GET
   * /accounts/{accountId}/emergencyNotificationGroupOrders?EnrDescription=front desk&EnrType=SMS <br>...
   * will return all Emergency Notification Group Orders associated with Emergency Notification
   * Recipients having a description field including the string "front desk" and a notification type of
   * SMS. The results will be sorted from newest order to oldest order. <br>This endpoint supports the
   * following query parameters. All query parameters are optional.<table>        <tr>
   * <th>Parameter Name</th>          <th>Example</th>          <th>Default</th>          <th>Usage</th>
   * </tr>        <tr>            <td valign="top">                <p>
   * CreatedAfterDate                </p>            </td>            <td  valign="top">
   * <p>                    CreatedAfterDate=                    2020-04-03T00:00:00.000-04:00
   * </p>            </td>            <td valign="top">                <p>                    Results
   * are returned in order from newest to oldest order creation date                </p>            </td>
   * <td valign="top">                <p>                  Include results only for orders
   * having order creation date and time after the date and time specified in this parameter.  Note that
   * inclusion of this parameter reverses the default sort order of the results to ascending in date/time
   * (i.e. from oldest to newest).  If you are looking for the CreatedBeforeDate query parameter, please
   * see the Page parameter.  Date/time format is YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z indicate UTC time,
   * or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm" represents the local time offset, plus or minus,
   * from UTC time.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    CreatedByUser                </p>
   * </td>            <td valign="top">                <p>                     CreatedByUser=catlee
   * </p>            </td>            <td  valign="top">                <p>
   * No filter                </p>            </td>            <td valign="top">                <p>
   * Include results only for orders created by the user specified in this parameter.
   * </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    EnrOperation                </p>            </td>            <td
   * valign="top">                <p>                    EnrOperation=AddedEnr                </p>
   * </td>            <td  valign="top">                <p>                    No filter
   * </p>            </td>            <td  valign="top">                <p>                    Include
   * results only for orders requesting one of the following emergency notification recipient operations:
   * AddedEnr or DeletedEnr.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    ProcessingStatus                </p>
   * </td>            <td valign="top">                <p>                    ProcessingStatus=FAILED
   * </p>            </td>            <td  valign="top">                <p>
   * No filter                </p>            </td>            <td  valign="top">                <p>
   * Include results only for orders having one of the following processing status values:
   * FAILED or COMPLETED.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    CustomerOrderId                </p>
   * </td>            <td valign="top">                <p>                    CustomerOrderId=j3jljkd8
   * </p>            </td>            <td valign="top">                <p>
   * No filter                </p>            </td>            <td  valign="top">                <p>
   * Include results only for orders having the specified customer order id value.
   * </p>            </td>        </tr>        <tr>            <td valign="top">                <p>
   * EngId                </p>            </td>            <td valign="top">
   * <p>                    EngId=                    63865500-0904-46b1-9b4f-7bd237a26363
   * </p>            </td>            <td valign="top">                <p>                    No
   * filter                </p>            </td>            <td valign="top">                <p>
   * The Identifier of an Emergency Notification Group that was altered by an order.
   * </p>            </td>        </tr>        <tr>            <td valign="top">                <p>
   * EngDescription                </p>            </td>            <td valign="top">
   * <p>                    EngDesription=3rd floor                </p>            </td>
   * <td valign="top">                <p>                    No filter                </p>
   * </td>            <td  valign="top">                <p>                    A substring that will
   * exist in the emergency notification group Description for all returned Emergency Notification Group
   * Orders.                </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    EnrId                </p>            </td>            <td
   * valign="top">                <p>                    EnrId=                    63865500-0904-46b1-
   * 9b4f-7bd237a26363                </p>            </td>            <td valign="top">
   * <p>                    No filter                </p>            </td>            <td  valign="top">
   * <p>                    The Identifier of an Emergency Notification Recipient that is
   * associated with the Emergency Notification Groups in all orders returned.                </p>
   * </td>        </tr>        <tr>            <td valign="top">                <p>
   * EnrDescription                </p>            </td>            <td valign="top">                <p>
   * EnrDescription=front desk                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td valign="top">                <p>                    A substring that will exist in all
   * Emergency Notification Recipient Descriptions associated with the Emergency Notification Groups in
   * all orders returned.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    EnrNotificationType                </p>
   * </td>            <td valign="top">                <p>                    EnrNotificationType=TTS
   * </p>            </td>            <td valign="top">                <p>
   * No filter                </p>            </td>            <td valign="top">                <p>
   * The type of notification (EMAIL, SMS, TTS, or CALLBACK) specified for Emergency
   * Notification Recipients associated with the Emergency Notification Groups in all orders returned.
   * </p>            </td>        </tr>        <tr>            <td  valign="top">
   * <p>                    EnrSmsTn                </p>            </td>            <td
   * valign="top">                <p>                    EnrSmsTn=3037458827                </p>
   * </td>            <td  valign="top">                <p>                    No filter
   * </p>            </td>            <td  valign="top">                <p>                    The Short
   * Message Service telephone number in all SMS type Emergency Notification Recipients associated with
   * the Emergency Notification Groups in all orders returned.                </p>            </td>
   * </tr>        <tr>            <td  valign="top">                <p>                    EnrTtsTn
   * </p>            </td>            <td  valign="top">                <p>
   * EnrTtsTn=402288875                </p>            </td>            <td  valign="top">
   * <p>                    No filter                </p>            </td>            <td  valign="top">
   * <p>                    The Text To Speech telephone number in all TTS type Emergency
   * Notification Recipients associated with the Emergency Notification Groups in all orders returned.
   * </p>            </td>        </tr>        <tr>            <td  valign="top">
   * <p>                    EnrEmailAddress                </p>            </td>            <td
   * valign="top">                <p>                    EnrEmailAddress=fred@aol.com                </p>
   * </td>            <td  valign="top">                <p>                    No filter
   * </p>            </td>            <td  valign="top">                <p>
   * The email address in all EMAIL type Emergency Notification Recipients associated with the Emergency
   * Notification Groups in all orders returned.                </p>            </td>        </tr>
   * <tr>            <td  valign="top">                <p>                    EnrCallbackUrl
   * </p>            </td>            <td  valign="top">                <p>
   * EnrCallbackUrl=                    https://e911.callback.mycompany.com                </p>
   * </td>            <td  valign="top">                <p>                    No filter
   * </p>            </td>            <td  valign="top">                <p>                    The
   * callback URL in all CALLBACK type Emergency Notification Recipients associated with the Emergency
   * Notification Groups in all orders returned.                </p>            </td>        </tr>
   * <tr>            <td  valign="top">                <p>                    EnrCallbackUsername
   * </p>            </td>            <td  valign="top">                <p>
   * EnrCallbackUsername=ljames                </p>            </td>            <td  valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    The callback username in all CALLBACK type
   * Emergency Notification Recipients associated with the Emergency Notification Groups in all orders
   * returned.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    Page                </p>            </td>
   * <td  valign="top">                <p>                    Page=2019-08-01Z                </p>
   * </td>            <td  valign="top">                <p>                    Now
   * </p>            </td>            <td  valign="top">                <p>                  This
   * represents the position in the data set from which you want your output to begin.  If this parameter
   * is omitted, results will include Emergency Notification Group Orders created on or before the
   * current date and time.  If a date and time is provided, results will include Emergency Notification
   * Group Orders created on or before that date and time.  Date/time format is YYYY-MM-DDTHH:MM:SS.mmmZ,
   * where the Z indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm" represents the local
   * time offset, plus or minus, from UTC time.                </p>            </td>        </tr>
   * <tr>            <td  valign="top">                <p>                    Size                </p>
   * </td>            <td  valign="top">                <p>                    Size=200
   * </p>            </td>            <td  valign="top">                <p>                    100
   * </p>            </td>            <td  valign="top">                <p>
   * The maximum number of Emergency Notification Group Order results to include in the response payload.
   * This value may be between 1 and 500.                </p>            </td>        </tr></table>
   *
   * @param accountId
   * @param page
   * @param size                Example: 100
   * @param createdAfterDate
   * @param createdByUser
   * @param engOperation
   * @param enrOperation
   * @param processingStatus
   * @param customerOrderId
   * @param engId
   * @param engDescription
   * @param enrId
   * @param enrDescription
   * @param enrNotificationType
   * @param enrSmsTn
   * @param enrTtsTn
   * @param enrEmailAddress
   * @param enrCallbackUrl
   * @param enrCallbackUsername
   * @param expandErrors        Example: false
   * @param enrDetails          Example: false
   * @return Response from the API call
   */
  async getGroupOrders(
    accountId: number,
    page?: string,
    size?: number,
    createdAfterDate?: string,
    createdByUser?: string,
    engOperation?: string,
    enrOperation?: string,
    processingStatus?: string,
    customerOrderId?: string,
    engId?: string,
    engDescription?: string,
    enrId?: string,
    enrDescription?: string,
    enrNotificationType?: string,
    enrSmsTn?: string,
    enrTtsTn?: string,
    enrEmailAddress?: string,
    enrCallbackUrl?: string,
    enrCallbackUsername?: string,
    expandErrors?: string,
    enrDetails?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupRecipientOrderResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      createdAfterDate: [createdAfterDate, optional(string())],
      createdByUser: [createdByUser, optional(string())],
      engOperation: [engOperation, optional(string())],
      enrOperation: [enrOperation, optional(string())],
      processingStatus: [processingStatus, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      engId: [engId, optional(string())],
      engDescription: [engDescription, optional(string())],
      enrId: [enrId, optional(string())],
      enrDescription: [enrDescription, optional(string())],
      enrNotificationType: [enrNotificationType, optional(string())],
      enrSmsTn: [enrSmsTn, optional(string())],
      enrTtsTn: [enrTtsTn, optional(string())],
      enrEmailAddress: [enrEmailAddress, optional(string())],
      enrCallbackUrl: [enrCallbackUrl, optional(string())],
      enrCallbackUsername: [enrCallbackUsername, optional(string())],
      expandErrors: [expandErrors, optional(string())],
      enrDetails: [enrDetails, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('CreatedAfterDate', mapped.createdAfterDate);
    req.query('CreatedByUser', mapped.createdByUser);
    req.query('EngOperation', mapped.engOperation);
    req.query('EnrOperation', mapped.enrOperation);
    req.query('ProcessingStatus', mapped.processingStatus);
    req.query('CustomerOrderId', mapped.customerOrderId);
    req.query('EngId', mapped.engId);
    req.query('EngDescription', mapped.engDescription);
    req.query('EnrId', mapped.enrId);
    req.query('EnrDescription', mapped.enrDescription);
    req.query('EnrNotificationType', mapped.enrNotificationType);
    req.query('EnrSmsTn', mapped.enrSmsTn);
    req.query('EnrTtsTn', mapped.enrTtsTn);
    req.query('EnrEmailAddress', mapped.enrEmailAddress);
    req.query('EnrCallbackUrl', mapped.enrCallbackUrl);
    req.query('EnrCallbackUsername', mapped.enrCallbackUsername);
    req.query('ExpandErrors', mapped.expandErrors);
    req.query('EnrDetails', mapped.enrDetails);
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationgrouporders`;
    req.throwOn(400, ApiError, 'Bad request <br> <p><b>Condition:</b> Unrecognized query parameter <br> <b>Error Description:</b>Query parameter xxx is not recognized. </p> <br> <p><b>Condition:</b>Unsupported value for query parameter <br> <b>Error Description:</b>Invalid value xxx for query parameter yyy. Supported values are aaa, bbb, etc. </p>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b>User does not have permission to view emergency notification group orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config.<br> <b>Error Description:</b>Access Denied </p>');
    return req.callAsXml(
      'EmergencyNotificationGroupOrderResponse',
      emergencyNotificationGroupRecipientOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * <p> The POST operation is used to create an order to create, update, or delete an emergency
   * notification group. <br>URI Parameters: <b>accountId</b> - the account id of the account to which
   * the emergency notification recipient belongs </p><p><b>Emergency notification group order request
   * elements</b></p><table border="1" cellspacing="0" cellpadding="0" width="724">        <tbody>
   * <tr>                <td valign="top">                    <p>
   * <strong>Parameter</strong>                    </p>                </td>                <td
   * width="451" valign="top">                    <p>                        <strong>Description</strong>
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        CustomerOrderId                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * An optional customer-defined order identifier that is stored with the Bandwidth order.
   * This value is opaque to Bandwidth.                    </p>                </td>            </tr>
   * <tr>                <td valign="top">                    <p>
   * (emergency notification group) Identifier                    </p>                </td>
   * <td width="451" valign="top">                    <p>                        A mandatory identifier
   * of the Emergency Notification Group to be deleted or updated.                    </p>
   * </td>            </tr>            <tr>                <td valign="top">                    <p>
   * AddedEmergencyNotificationGroup                    </p>                </td>
   * <td width="451" valign="top">                    <p>                        Indicates that
   * the order is to add an emergency notification group.                    </p>                </td>
   * </tr>            <tr>                <td valign="top">                    <p>
   * DeletedEmergencyNotificationGroup                    </p>                </td>
   * <td width="451" valign="top">                    <p>                        Indicates that the
   * order is to delete an emergency notification group.                    </p>                </td>
   * </tr>            <tr>                <td valign="top">                    <p>
   * UpdatedEmergencyNotificationGroup                    </p>                </td>
   * <td width="451" valign="top">                    <p>                        Indicates that the order
   * is to modify an emergency notification group.                    </p>                </td>
   * </tr>            <tr>                <td valign="top">                    <p>
   * Description                    </p>                </td>                <td width="451"
   * valign="top">                    <p>                        A mandatory 200 character description of
   * the Emergency Notification Group.                        The contents of this field are freeform,
   * but ideally should describe the set of endpoints                        that are being grouped
   * together for the purpose of having the same emergency notification recipients.  E.g. Occupants of
   * building 5 main campus.                    </p>                </td>            </tr>
   * <tr>                <td valign="top">                    <p>
   * AddedEmergencyNotificationRecipients                    </p>                </td>                <td
   * width="451" valign="top">                    <p>                        Indicates that emergency
   * notification recipients are being added to the emergency notification group.                    </p>
   * </td>            </tr>            <tr>                <td valign="top">
   * <p>                        DeletedEmergencyNotificationRecipients                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * Indicates that emergency notification recipients are being removed from the emergency
   * notification group.                    </p>                </td>            </tr>            <tr>
   * <td valign="top">                    <p>
   * EmergencyNotificationRecipients                    </p>                </td>                <td
   * width="451" valign="top">                    <p>                        A list of one to three
   * emergency notification recipients being associated with this emergency notification group.
   * </p>                </td>            </tr>            <tr>                <td valign="top">
   * <p>                        EmergencyNotificationRecipient                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * One of up to three emergency notification recipients belonging to this emergency
   * notification group.                    </p>                </td>            </tr>            <tr>
   * <td valign="top">                    <p>                        (emergency notification
   * recipient) Identifier                    </p>                </td>                <td width="451"
   * valign="top">                    <p>                        The identifier that uniquely identifies
   * an emergency notification recipient.  This identifier was assigned when the emergency notification
   * recipient was created.  A given emergency notification recipient may be associated with only one
   * emergency notification group.                    </p>                </td>            </tr>
   * </tbody>    </table><br><br>    <p><b>Creating a new emergency notification group</b> <br>    An
   * emergency notification group must have one to three emergency notification recipients.  This means
   * that the emergency notification recipients must be created before the emergency notification group.
   * </p>    <p><b>Deleting an emergency notification group</b> <br>    An emergency notification group
   * may be deleted if there are no emergency endpoints associated with the group.  Deleting an emergency
   * notification group that is configured with emergency notification recipients will successfully
   * delete the group, but will not delete the emergency notification recipients.    </p>
   * <p><b>Updating an emergency notification group</b> <br>    You may remove emergency notification
   * recipients from the emergency notification group, provided the total number remaining is at least
   * one.    </p>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createGroupOrder(
    accountId: number,
    body?: EmergencyNotificationGroupRecipientOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupRecipientOrderResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'EmergencyNotificationGroupOrder',
      optional(emergencyNotificationGroupRecipientOrderPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationgrouporders`;
    req.throwOn(400, ApiError, 'Bad request <br> <table border="1" cellspacing="0" cellpadding="0" width="724"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="451" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Order payload does not indicate whether the emergency notification group is being created, modified, or deleted </p> </td> <td width="451" valign="top"> <p> Order payload must include one of "AddedEmergencyNotificationGroup", "DeletedEmergencyNotificationGroup", or "ModifiedEmergencyNotificationGroup". </p> </td> </tr> <tr> <td valign="top"> <p> Order is creating a new emergency notification group, but does not indicate that emergency notification recipients are being added </p> </td> <td width="451" valign="top"> <p> When creating an emergency notification group, "AddedEmergencyNotificationRecipients" must be included to indicate that emergency notification recipients are being added. </p> </td> </tr> <tr> <td valign="top"> <p> Missing or empty emergency notification group description </p> </td> <td width="451" valign="top"> <p> Emergency Notification Group Description must be present and non-empty. </p> </td> </tr> <tr> <td valign="top"> <p> No emergency notification recipients listed </p> </td> <td width="451" valign="top"> <p> An Emergency Notification Group must have 1, 2, or 3 Emergency Notification Recipients.  Note:<b></b> This can be used for missing list or empty list. </p> </td> </tr> <tr> <td valign="top"> <p> Too many emergency notification recipients listed </p> </td> <td width="451" valign="top"> <p> An Emergency Notification Group must have 1, 2, or 3 Emergency Notification Recipients. </p> </td> </tr> <tr> <td valign="top"> <p> Order does not include an emergency notification group </p> </td> <td width="451" valign="top"> <p> </p> </td> </tr> <tr> <td valign="top"> <p> The specified emergency notification group does not exist </p> </td> <td width="451" valign="top"> <p> ENG Identifier xxx does not exist., where xxx is replaced by the emergency notification group identifier supplied in the request. </p> </td> </tr> <tr> <td valign="top"> <p> The specified emergency notification recipient identifier does not exist </p> </td> <td width="451" valign="top"> <p> ENR Identifier xxx does not exist., where xxx is replaced by the emergency notification recipient identifier supplied in the request. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to update an emergency notification group, but none of "Description", "AddedEmergencyNotificationRecipients", or "DeletedEmergencyNotificationRecipients" included </p> </td> <td width="451" valign="top"> <p> Update of ENG did not specify any of:<b></b> new description, added ENRs, or deleted ENRs. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to update an emergency notification group with both "AddedEmergencyNotificationRecipients" and "DeletedEmergencyNotificationRecipients" included </p> </td> <td width="451" valign="top"> <p> Update of ENG supports added ENRs or deleted ENRs, but not both. </p> </td> </tr> </tbody> </table>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to configure emergency notification group orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(409, ApiError, 'Conflict <br> <table border="1" cellspacing="0" cellpadding="0" width="724"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="451" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Invalid emergency notification recipient identifier </p> </td> <td width="451" valign="top"> <p> Emergency Notification Recipient Identifier xxx does not exist., where xxx is replaced by the emergency notification recipient identifier supplied in the request.  Note:<b></b> This error can be used also for the case where the emergency notification recipient ID exists, but not for this Iris account. </p> </td> </tr> <tr> <td valign="top"> <p> Specified emergency notification recipient is already associated with another emergency notification group </p> </td> <td width="451" valign="top"> <p> The Emergency Notification Recipient with identifier xxx is already associated with Emergency Notification Group with identifier yyy., where xxx is replaced with the emergency notification recipient ID supplied in the request, and yyy is replaced by the emergency notification group ID of the emergency notification group that the supplied emergency notification recipient ID is associated with.  Note:<b></b> The emergency notification group must also belong to this account. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to remove an emergency notification group that has emergency endpoints associated with it </p> </td> <td width="451" valign="top"> <p> ENG xxx cannot be removed until emergency endpoint associations are removed., where xxx is replaced by the emergency notification group identifier supplied in the request. </p> </td> </tr> <tr> <td valign="top"> <p> Removal of ENRs would leave the emergency notification group with no emergency notification recipient associations </p> </td> <td width="451" valign="top"> <p> An Emergency Notification Group must have 1, 2, or 3 Emergency Notification Recipients. </p> </td> </tr> <tr> <td valign="top"> <p> Addition of emergency notification recipients would leave the emergency notification group with too many emergency notification recipient associations </p> </td> <td width="451" valign="top"> <p> An Emergency Notification Group must have 1, 2, or 3 Emergency Notification Recipients. </p> </td> </tr> </tbody> </table>');
    return req.callAsXml(
      'EmergencyNotificationGroupOrderResponse',
      emergencyNotificationGroupRecipientOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * This endpoint is used to query the status of a specified emergency notification group order, using
   * the order-id that was assigned in the 201 response to the order creation. <br>When you query an
   * order-id, look for the "ProcessingStatus" element in the 200 response.  Values may be: PROCESSING,
   * COMPLETED, or FAILED.  PROCESSING means that the system is still processing the order.  Please wait
   * a couple of minutes and fetch the order results again.  COMPLETED means that the order has been
   * successfully completed.  FAILED means that errors occurred while processing the order, and that the
   * order did not make any changes to the system.  Look for the "ErrorList" element to see what type of
   * error occurred. <br>URI parameters:<ul>  <li>  <b>accountId</b> - the account id of the account to
   * which the emergency notification group order belongs.  </li>  <li>  <b>orderId</b> - the order
   * identifier assigned to the emergency notification group order when it was created.  </li></ul>
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getGroupOrder(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupRecipientOrderResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationgrouporders/${mapped.orderId}`;
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to view emergency notification group orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p><b>Condition:</b> Specified emergency notification group order-id does not exist for this account. <br> <b>Error Description:</b> The resource does not exist </p> <br>');
    return req.callAsXml(
      'EmergencyNotificationGroupOrderResponse',
      emergencyNotificationGroupRecipientOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * <p> The GET operation provides a means to query any Emergency Notification Endpoint Order associated
   * with the account. This endpoint is for querying "orders", not the emergency endpoint to emergency
   * notification group associations themselves. <br>URI Parameters: <b>accountId</b> - the account id of
   * the account to which the emergency notification recipient belongs. </p><p>The GET operation has no
   * payload, although the accountId URI parameter is mandatory and a number of optional query parameters
   * may be added. The query parameters are described in this section.   Results are returned by default
   * in the order of newest to oldest creation date of the Emergency Notification Endpoint Order. This
   * default order is reversed from oldest to newest when the CreatedAfterDate query parameter is
   * included in the query.   Query parameters act as filters on the data. If more than one query
   * parameter is provided, the results will be the intersection of the results from each query parameter.
   * In other words, the query parameters are logically ANDed.   Query parameters are appended to the
   * end of the endpoint, separated by a '?' and in the format parameter=value. If you wish to specify
   * more than one query parameter, separate them using an '&' character. The order of query parameters
   * does not matter. For example:<br>   GET /accounts/{accountId}/emergencyNotificationEndpointOrders?
   * EngDescription=3rd Floor&EndpointOperation=Dissociated <br>   ...will return all Emergency
   * Notification Endpoint Orders associated with Emergency Notification Groups having a description
   * field including the string "3rd Floor" and where endpoints were dissociated from emergency
   * notification groups. The results will be sorted from newest order to oldest order.<br>    This
   * endpoint supports the following query parameters. All query parameters are optional.</p><table>
   * <tr>          <th>Parameter Name</th>          <th>Example</th>          <th>Default</th>
   * <th>Usage</th>        </tr>        <tr>            <td valign="top">                <p>
   * CreatedAfterDate                </p>            </td>            <td  valign="top">
   * <p>                    CreatedAfterDate=                    2020-03-30T14:00:00Z
   * </p>            </td>            <td valign="top">                <p>                    No filter
   * </p>            </td>            <td valign="top">                <p>
   * Include results only for orders having order creation date and time after the date and time
   * specified in this parameter.  Note that inclusion of this parameter reverses the default sort order
   * of the results to ascending in date/time (i.e. from oldest to newest).  If you are looking for the
   * CreatedBeforeDate query parameter, please see the Page parameter.                </p>
   * </td>        </tr>        <tr>            <td valign="top">                <p>
   * CreatedByUser                </p>            </td>            <td valign="top">                <p>
   * CreatedByUser=catlee                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td valign="top">                <p>                    Include results only for orders
   * created by the user specified in this parameter.                </p>            </td>        </tr>
   * <tr>            <td valign="top">                <p>                    ProcessingStatus
   * </p>            </td>            <td valign="top">                <p>
   * ProcessingStatus=FAILED                </p>            </td>            <td  valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    Include results only for orders having one of
   * the following processing status values: FAILED or COMPLETED.                </p>            </td>
   * </tr>        <tr>            <td valign="top">                <p>
   * CustomerOrderId                </p>            </td>            <td valign="top">                <p>
   * CustomerOrderId=j3jljkd8                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td  valign="top">                <p>                    Include results only for orders
   * having the specified customer order id value.                </p>            </td>        </tr>
   * <tr>            <td valign="top">                <p>                    EngId                </p>
   * </td>            <td valign="top">                <p>                    EngId=
   * 63865500-0904-46b1-9b4f-7bd237a26363                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td valign="top">                <p>                    The Identifier of an Emergency
   * Notification Group that was altered by an order.                </p>            </td>        </tr>
   * <tr>            <td valign="top">                <p>                    EngDescription
   * </p>            </td>            <td valign="top">                <p>
   * EngDesription=3rd floor                </p>            </td>            <td valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    A substring that will exist in the emergency
   * notification group Description for all returned Emergency Notification Endpoint Orders.
   * </p>            </td>        </tr>        <tr>            <td valign="top">                <p>
   * EepTns                </p>            </td>            <td  valign="top">
   * <p>                    EepTns=404                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td  valign="top">                <p>                    Include results only for orders
   * having EepTns that start with the specified digit string.  The digit string may be from 1 to 11
   * digits.                </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    EepAeuiIds                </p>            </td>            <td
   * valign="top">                <p>                    EepAeuiIds=Joe                </p>
   * </td>            <td valign="top">                <p>                    No filter
   * </p>            </td>            <td valign="top">                <p>                    Include
   * results only for orders having EepAeuiIds that start with the specified character string.  The
   * string may be from 1 to 30 characters.                </p>            </td>        </tr>        <tr>
   * <td  valign="top">                <p>                    Page                </p>
   * </td>            <td  valign="top">                <p>                    Page=2019-08-01Z
   * </p>            </td>            <td  valign="top">                <p>
   * Now                </p>            </td>            <td  valign="top">                <p>
   * This represents the position in the data set from which you want your output to begin.  If
   * this parameter is omitted, results will include Emergency Notification Endpoint Orders created on or
   * before the current date and time.  If a date and time is provided, results will include Emergency
   * Notification Endpoint Orders created on or before that date and time.  Date/time format is YYYY-MM-
   * DDTHH:MM:SS.mmmZ, where the Z indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm, where "-hh:mm"
   * represents the local time offset, plus or minus, from UTC time.                </p>            </td>
   * </tr>        <tr>            <td  valign="top">                <p>                    Size
   * </p>            </td>            <td  valign="top">                <p>
   * Size=5                </p>            </td>            <td  valign="top">                <p>
   * 100                </p>            </td>            <td  valign="top">
   * <p>                  The maximum number of Emergency Notification Endpoint Order results to include
   * in the response payload.  This value may be between 1 and 500.                </p>            </td>
   * </tr></table>
   *
   * @param accountId
   * @param page
   * @param size              Example: 100
   * @param createdAfterDate
   * @param createdByUser
   * @param endpointOperation
   * @param processingStatus
   * @param customerOrderId
   * @param engId
   * @param engDescription
   * @param eepTns
   * @param eepAeuiIds
   * @param expandErrors      Example: false
   * @param enrDetails        Example: false
   * @return Response from the API call
   */
  async retrieveGroupsAssociationOrder(
    accountId: number,
    page?: string,
    size?: number,
    createdAfterDate?: string,
    createdByUser?: string,
    endpointOperation?: string,
    processingStatus?: string,
    customerOrderId?: string,
    engId?: string,
    engDescription?: string,
    eepTns?: string,
    eepAeuiIds?: string,
    expandErrors?: string,
    enrDetails?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupsEndpointAssociationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      createdAfterDate: [createdAfterDate, optional(string())],
      createdByUser: [createdByUser, optional(string())],
      endpointOperation: [endpointOperation, optional(string())],
      processingStatus: [processingStatus, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      engId: [engId, optional(string())],
      engDescription: [engDescription, optional(string())],
      eepTns: [eepTns, optional(string())],
      eepAeuiIds: [eepAeuiIds, optional(string())],
      expandErrors: [expandErrors, optional(string())],
      enrDetails: [enrDetails, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('CreatedAfterDate', mapped.createdAfterDate);
    req.query('CreatedByUser', mapped.createdByUser);
    req.query('EndpointOperation', mapped.endpointOperation);
    req.query('ProcessingStatus', mapped.processingStatus);
    req.query('CustomerOrderId', mapped.customerOrderId);
    req.query('EngId', mapped.engId);
    req.query('EngDescription', mapped.engDescription);
    req.query('EepTns', mapped.eepTns);
    req.query('EepAeuiIds', mapped.eepAeuiIds);
    req.query('ExpandErrors', mapped.expandErrors);
    req.query('EnrDetails', mapped.enrDetails);
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationendpointorders`;
    req.throwOn(400, ApiError, 'Bad request <br> <p><b>Condition:</b> Unrecognized query parameter <br> <b>Error Description:</b>Query parameter xxx is not recognized. </p> <br> <p><b>Condition:</b>Unsupported value for query parameter <br> <b>Error Description:</b>Invalid value xxx for query parameter yyy. Supported values are aaa, bbb, etc. </p>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b>User does not have permission to view Endpoint orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config.<br> <b>Error Description:</b>Access Denied </p>');
    return req.callAsXml(
      'EmergencyNotificationEndpointOrderResponse',
      emergencyNotificationGroupsEndpointAssociationResponseSchema,
      requestOptions
    );
  }

  /**
   * <p> The POST operation creates a new order to request that an emergency endpoint be added to or
   * removed from an emergency notification group.  A given order may either add or remove associations,
   * not both in one order.<br>    If the order is successfully created, a 201 response is returned,
   * including an order-id that is used to query for completion of the order. <br>    The order's
   * ProcessingStatus is set to PROCESSING when the request is successfully created.  When processing of
   * all emergency endpoint to emergency notification group associations has been attempted, the software
   * will update the order's processing status to either COMPLETED or FAILED. <br>URI Parameters:
   * <b>accountId</b> - the account id of the account to which the emergency endpoints and emergency
   * notification groups are configured. </p><p><b>The emergency notification endpoint order includes the
   * following payload elements:</b></p><table border="1" cellspacing="0" cellpadding="0" width="724">
   * <tbody>            <tr>                <td valign="top">                    <p>
   * <strong>Parameter</strong>                    </p>                </td>                <td
   * width="451" valign="top">                    <p>                        <strong>Description</strong>
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        CustomerOrderId                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * An optional customer-defined order identifier that is stored with the Bandwidth order.
   * This value is opaque to Bandwidth.                    </p>                </td>            </tr>
   * <tr>                <td valign="top">                    <p>
   * EmergencyNotificationGroup Identifier                    </p>                </td>
   * <td width="451" valign="top">                    <p>                        The mandatory identifier
   * that uniquely identifies the emergency notification group to which emergency endpoints are being
   * associated.  This value is assigned by the system when the emergency notification group is created.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        AddedAssociations
   * </p>                </td>                <td width="451" valign="top">                    <p>
   * Included when emergency endpoint to emergency notification group associations are to
   * be created.  Only AddedAssociations or Deleted Associations may be included in a given order.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        DeletedAssociations
   * </p>                </td>                <td width="451" valign="top">                    <p>
   * Included when emergency endpoint to emergency notification group associations are to
   * be removed.  Only AddedAssociations or Deleted Associations may be included in a given order.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        EepToEngAssociations
   * </p>                </td>                <td width="451" valign="top">                    <p>
   * Mandatory container for the list of TNs and AEUI identifiers to be associated or
   * dissociated with the emergency notification group.                    </p>                </td>
   * </tr>            <tr>                <td valign="top">                    <p>
   * EepTns                    </p>                </td>                <td width="451"
   * valign="top">                    <p>                        A container of emergency endpoints that
   * are of type TN.  This element may be omitted if none of the emergency endpoints to be associated or
   * dissociated are telephone numbers.                    </p>                </td>            </tr>
   * <tr>                <td valign="top">                    <p>
   * TelephoneNumber                    </p>                </td>                <td width="451"
   * valign="top">                    <p>                        A 10-digit telephone number representing
   * an emergency endpoint in the ListOfEepTns.  The list may consist of a single TN if desired.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        EepAeuiIds                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * A container of emergency endpoints that are of type AEUI.  This element may be omitted if none
   * of the emergency endpoints to be associated or dissociated are Alternate End User Identities.
   * </p>                </td>            </tr>            <tr>                <td
   * valign="top">                    <p>                        Identifier                    </p>
   * </td>                <td width="451" valign="top">                    <p>
   * A unique identifier for the AEUI representing an emergency endpoint in the ListOfEepAeuiIds.
   * The list may consist of a single AEUI ID if desired.                    </p>                </td>
   * </tr>        </tbody>    </table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createGroupOrder1(
    accountId: number,
    body?: EmergencyNotificationGroupEndpointAssociationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupEndpointAssociationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'EmergencyNotificationEndpointOrder',
      optional(emergencyNotificationGroupEndpointAssociationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationendpointorders`;
    req.throwOn(400, ApiError, 'Bad request <br> <table border="1" cellspacing="0" cellpadding="0" width="724"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="451" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Order payload does not indicate whether the endpoints are being added or deleted </p> </td> <td width="451" valign="top"> <p> Order payload must include one of "AddedAssociations" or "DeletedAssociations". </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to both add and delete endpoint associations in one request </p> </td> <td width="451" valign="top"> <p> Order payload must include one of "AddedAssociations" or "DeletedAssociations", but not both in one request. </p> </td> </tr> <tr> <td valign="top"> <p> Order payload does not specify any endpoints to be added </p> </td> <td width="451" valign="top"> <p> Order payload must include at least one Emergency Enpoint value. </p> </td> </tr> <tr> <td valign="top"> <p> Too many emergency endpoints listed </p> </td> <td width="451" valign="top"> <p> Please limit the total number of emergency endpoints to 5000 per request. </p> </td> </tr> </tbody> </table>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to configure associations between emergency endpoints and an emergency notification group, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(409, ApiError, 'Conflict <br> <table border="1" cellspacing="0" cellpadding="0" width="724"> <tbody> <tr> <td valign="top"> <p> <strong>Condition</strong> </p> </td> <td width="451" valign="top"> <p> <strong>Error Description</strong> </p> </td> </tr> <tr> <td valign="top"> <p> Invalid emergency notification group identifier </p> </td> <td width="451" valign="top"> <p> Emergency Notification Group Identifier xxx does not exist., where xxx is replaced by the emergency notification group identifier supplied in the request.  Note:<b></b> This error can be used also for the case where the emergency notification group ID exists, but not for this Iris account. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to add invalid emergency endpoint identifier </p> </td> <td width="451" valign="top"> <p> Emergency Endpoint Identifier being added does not exist.  Note:<b></b> This error can also be used for the case where the emergency endpoint ID exists, but not for this Iris account. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to remove invalid emergency endpoint identifier, for the case where the emergency endpoint does not exist for the specified Iris account </p> </td> <td width="451" valign="top"> <p>Warning:<b></b> Emergency Endpoint Identifier specified for removal does not exist. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to remove a valid emergency endpoint identifier that is associated with an emergency notification group other than the one specified in the request </p> </td> <td width="451" valign="top"> <p> Error:<b></b> Emergency Endpoint Identifier specified for removal is not associated with Emergency Notification Group xxx., where xxx is replaced by the emergency notification group identifier. </p> </td> </tr> <tr> <td valign="top"> <p> Attempt to add an endpoint, but specified emergency endpoint is already associated with another emergency notification group                                </p> </td> <td width="451" valign="top"> <p> The Emergency Endpoint with identifier xxx is already associated with Emergency Notification Group with identifier yyy., where xxx is replaced with the TN or AEUI supplied in the request, and yyy is replaced by the emergency notification group ID of the emergency notification group that the supplied endpoint ID is associated with. </p> </td> </tr> </tbody> </table>');
    return req.callAsXml(
      'EmergencyNotificationEndpointOrderResponse',
      emergencyNotificationGroupEndpointAssociationResponseSchema,
      requestOptions
    );
  }

  /**
   * This endpoint is used to fetch the status of an emergency notification endpoint order, using the
   * order-id assigned when the order was created. <br>If the order is still being processed, the
   * ProcessingStatus will be PROCESSING.  If the order has completed successfully, the ProcessingStatus
   * will be COMPLETED.  Otherwise the ProcessingStatus will be FAILED.  If the ProcessingStatus is
   * FAILED, look for the ErrorList in the payload to see reasons for the failure.URI parameters:<ul>
   * <li>  <b>accountId</b> - the account id of the account to which the emergency notification endpoint
   * order belongs.  </li>  <li>  <b>orderId</b> - the order-id assigned to the emergency notification
   * endpoint order when it was created.  </li></ul>
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async retrieveGroupAssociationOrder(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EmergencyNotificationGroupEndpointAssociationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationendpointorders/${mapped.orderId}`;
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to view emergency notification endpoint orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p><b>Condition:</b> Specified emergency notification endpoint order id does not exist for this account <br> <b>Error Description:</b> The resource does not exist </p> <br>');
    return req.callAsXml(
      'EmergencyNotificationEndpointOrderResponse',
      emergencyNotificationGroupEndpointAssociationResponseSchema,
      requestOptions
    );
  }

  /**
   * This endpoint allows you to fetch the configuration of a current emergency notification group by
   * identifier.URI parameters:<ul>  <li>  <b>accountId</b> - the account id of the account to which the
   * emergency notification recipient belongs.  </li>  <li>  <b>engId</b> - the emergency notification
   * group identifier assigned to the emergency notification group when it was created.  </li></ul>Query
   * parameters:            <table>                    <tr>                      <th>Parameter Name</th>
   * <th>Example</th>                      <th>Default</th>
   * <th>Usage</th>                    </tr>                    <tr>                        <td
   * valign="top">                            <p>                                IncludeEepTns
   * </p>                        </td>                        <td  valign="top">
   * <p>                                IncludeEepTns=true
   * </p>                        </td>                        <td valign="top">
   * <p>                                false                            </p>
   * </td>                        <td valign="top">                            <p>
   * Set this optional parameter to true if you wish to include a list
   * of all Emergency Endpoint TNs associated with this Emergency Notification Group.
   * </p>                        </td>                    </tr>                    <tr>
   * <td valign="top">                            <p>
   * IncludeEepAeuis                            </p>                        </td>
   * <td  valign="top">                            <p>
   * IncludeEepAeuis=true                            </p>                        </td>
   * <td valign="top">                            <p>                                false
   * </p>                        </td>                        <td  valign="top">
   * <p>                                Set this optional parameter to true if you wish
   * to include a list                                of all Emergency Endpoint AEUIs associated with
   * this Emergency Notification Group.                            </p>                        </td>
   * </tr>                    <tr>                        <td valign="top">
   * <p>                                StartWithEepTn                            </p>
   * </td>                        <td valign="top">                            <p>
   * StartWithEepTn=203208110                            </p>
   * </td>                        <td valign="top">                            <p>
   * No filter                            </p>                        </td>
   * <td valign="top">                            <p>                                This parameter,
   * which may only be specified if the IncludeEepTns parameter is set to true,
   * indicates the starting digits of the emergency endpoint TN that you wish to begin with in the
   * list of emergency endpoints associated with the emergency notification
   * group. At least 3 digits                                must be supplied, and up to 10 digits may be
   * included.                            </p>                        </td>                    </tr>
   * <tr>                        <td valign="top">                            <p>
   * EepTnSize                            </p>                        </td>
   * <td valign="top">                            <p>
   * EepTnSize=200                            </p>                        </td>
   * <td valign="top">                            <p>                                20
   * </p>                        </td>                        <td valign="top">
   * <p>                                This parameter, which may only be specified if the
   * IncludeEepTns parameter is set to true,                                 indicates the maximum number
   * of associated emergency endpoint TNs you wish to include for                                 each
   * emergency notification group that is returned in the query results. The value may range from 1 to
   * 5000                            </p>                        </td>                    </tr>
   * <tr>                        <td  valign="top">                            <p>
   * StartWithEepAeui                            </p>                        </td>
   * <td  valign="top">                            <p>
   * StartWithEepAeui=Frank                            </p>                        </td>
   * <td  valign="top">                            <p>                                No filter
   * </p>                        </td>                        <td  valign="top">
   * <p>                                This parameter, which may only be
   * specified if the IncludeEepAeuis parameter is set to true,                                 indicates
   * the starting characters of the emergency endpoint AEUI that you wish to begin with
   * in the list of emergency endpoints associated with the emergency notification group.
   * At least 3 characters must be supplied, and up to 50 characters may
   * be included.                            </p>                        </td>                    </tr>
   * <tr>                        <td  valign="top">                            <p>
   * EepAeuiSize                            </p>                        </td>
   * <td  valign="top">                            <p>
   * EepAeuiSize=50                            </p>                        </td>
   * <td  valign="top">                            <p>                                20
   * </p>                        </td>                        <td  valign="top">
   * <p>                                This parameter, which may only be specified if the
   * IncludeEepAeuis parameter is set to true,                                indicates the maximum
   * number of associated emergency endpoint AEUIs you wish to include for
   * each emergency notification group that is returned in the query results. The value may range from 1
   * to 5000.                            </p>                        </td>                    </tr>
   * </table>
   *
   * @param accountId
   * @param engId
   * @param includeEepTns    Example: false
   * @param includeEepAeuis  Example: false
   * @param startWithEepTn
   * @param eepTnSize        Example: 20
   * @param startWithEepAeui
   * @param eepAeuiSize      Example: 20
   * @return Response from the API call
   */
  async retrieveEmergencyNotificationGroup(
    accountId: number,
    engId: string,
    includeEepTns?: string,
    includeEepAeuis?: string,
    startWithEepTn?: string,
    eepTnSize?: number,
    startWithEepAeui?: string,
    eepAeuiSize?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      engId: [engId, string()],
      includeEepTns: [includeEepTns, optional(string())],
      includeEepAeuis: [includeEepAeuis, optional(string())],
      startWithEepTn: [startWithEepTn, optional(string())],
      eepTnSize: [eepTnSize, optional(number())],
      startWithEepAeui: [startWithEepAeui, optional(string())],
      eepAeuiSize: [eepAeuiSize, optional(number())],
    });
    req.query('IncludeEepTns', mapped.includeEepTns);
    req.query('IncludeEepAeuis', mapped.includeEepAeuis);
    req.query('StartWithEepTn', mapped.startWithEepTn);
    req.query('EepTnSize', mapped.eepTnSize);
    req.query('StartWithEepAeui', mapped.startWithEepAeui);
    req.query('EepAeuiSize', mapped.eepAeuiSize);
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationgroups/${mapped.engId}`;
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b> User does not have permission to view emergency notification groups, either due to Role/Permission or because the account is not configured for Emergency Notification Config. <br> <b>Error Description:</b> Access Denied </p>');
    req.throwOn(404, ApiError, 'The resource does not exist <br> <p><b>Condition:</b> Specified emergency notification group id does not exist for this account <br> <b>Error Description:</b> The resource does not exist </p> <br>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * <p> Fetch emergency notification groups that are currently configured on the account.  Use the
   * provided query parameters to filter the results. <br>URI Parameters: <b>accountId</b> - the account
   * id of the account to which the emergency notification group belongs </p><p><b>Query parameters:
   * </b><br>The GET operation has no request payload, but the accountId must be specified in the URI
   * parameter.Results are returned by default in the order of newest to oldest modification date of the
   * Emergency Notification Group.  This default order is reversed from oldest to newest when the
   * ModifiedAfterDate query parameter is included in the query.Query parameters act as filters on the
   * data. If more than one query parameter is provided, the results will be the intersection of the
   * results from each query parameter. In other words, the query parameters are logically ANDed.Query
   * parameters are appended to the end of the endpoint, separated by a '?' and in the format
   * parameter=value.  If you wish to specify more than one query parameter, separate them using an '&'
   * character.  The order of query parameters does not matter.  For example: <br>GET
   * /accounts/{accountId}/emergencyNotificationGroups?EngDescription=Bldg
   * 200&EnrEmailAddress=gateSecurity@mycompany.com <br>...will return all Emergency Notification Groups
   * having a description field including the string "Bldg 200", and having an emergency notification
   * recipient with the specified email address. <br>The following query parameters are supported.  All
   * query parameters are optional.</p><table>        <tr>          <th>Parameter Name</th>
   * <th>Example</th>          <th>Default</th>          <th>Usage</th>        </tr>        <tr>
   * <td valign="top">                <p>                    EngDescription                </p>
   * </td>            <td  valign="top">                <p>                    EngDescription=Building
   * 4                </p>            </td>            <td valign="top">                <p>
   * No filter                </p>            </td>            <td valign="top">                <p>
   * A substring that will exist in the Description for all returned Emergency
   * Notification Groups.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    EnrId                </p>            </td>
   * <td  valign="top">                <p>                    EnrId=                    63865500-
   * 0904-46b1-9b4f-7bd237a26363                </p>            </td>            <td valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    The Identifier of an Emergency Notification
   * Recipient that is associated with the Emergency Notification Groups returned.                </p>
   * </td>        </tr>        <tr>            <td valign="top">                <p>
   * EnrDescription                </p>            </td>            <td valign="top">
   * <p>                    EnrDescription=front desk                </p>            </td>            <td
   * valign="top">                <p>                    No filter                </p>            </td>
   * <td valign="top">                <p>                    A substring that will exist in all
   * Emergency Notification Recipient Descriptions associated with the Emergency Notification Groups
   * returned.                </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    EnrNotificationType                </p>            </td>
   * <td valign="top">                <p>                    EnrNotificationType=TTS
   * </p>            </td>            <td valign="top">                <p>                    No filter
   * </p>            </td>            <td valign="top">                <p>
   * The type of notification (EMAIL, SMS, TTS, or CALLBACK) specified for Emergency Notification
   * Recipients associated with the Emergency Notification Groups returned.                </p>
   * </td>        </tr>        <tr>            <td  valign="top">                <p>
   * EnrSmsTn                </p>            </td>            <td  valign="top">                <p>
   * EnrSmsTn=3037458827                </p>            </td>            <td  valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    The Short Message Service telephone number in
   * all SMS type Emergency Notification Recipients associated with the Emergency Notification Groups
   * returned.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    EnrTtsTn                </p>            </td>
   * <td  valign="top">                <p>                    EnrTtsTn=402288875
   * </p>            </td>            <td  valign="top">                <p>                    No filter
   * </p>            </td>            <td  valign="top">                <p>
   * The Text To Speech telephone number in all TTS type Emergency Notification Recipients associated
   * with the Emergency Notification Groups returned.                </p>            </td>        </tr>
   * <tr>            <td  valign="top">                <p>                    EnrEmailAddress
   * </p>            </td>            <td  valign="top">                <p>
   * EnrEmailAddress=fred@aol.com                </p>            </td>            <td  valign="top">
   * <p>                    No filter                </p>            </td>            <td
   * valign="top">                <p>                    The email address in all EMAIL type Emergency
   * Notification Recipients associated with the Emergency Notification Groups returned.
   * </p>            </td>        </tr>        <tr>            <td  valign="top">                <p>
   * EnrCallbackUrl                </p>            </td>            <td  valign="top">
   * <p>                    EnrCallbackUrl=                    https://e911.callback.mycompany.
   * com                </p>            </td>            <td  valign="top">                <p>
   * No filter                </p>            </td>            <td  valign="top">
   * <p>                    The callback URL in all CALLBACK type Emergency Notification Recipients
   * associated with the Emergency Notification Groups returned.                </p>            </td>
   * </tr>        <tr>            <td  valign="top">                <p>
   * EnrCallbackUsername                </p>            </td>            <td  valign="top">
   * <p>                    EnrCallbackUsername=ljames                </p>            </td>
   * <td  valign="top">                <p>                    No filter                </p>
   * </td>            <td  valign="top">                <p>                    The callback username in
   * all CALLBACK type Emergency Notification Recipients associated with the Emergency Notification
   * Groups returned.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    EnrDetails                </p>            </td>
   * <td  valign="top">                <p>                    EnrDetails=true
   * </p>            </td>            <td  valign="top">                <p>                    false
   * </p>            </td>            <td  valign="top">                <p>
   * If set to true, the results will include full details about each Emergency Notification Recipient
   * associated with the Emergency Notification Groups satisfying the query.  Otherwise, only Emergency
   * Notification Recipient identifiers are included.                </p>            </td>        </tr>
   * <tr>            <td  valign="top">                <p>                    Page
   * </p>            </td>            <td  valign="top">                <p>                    Page=2020-
   * 04-07T00:00:00Z                </p>            </td>            <td  valign="top">
   * <p>                    Now                </p>            </td>            <td  valign="top">
   * <p>                  This represents the position in the data set from which you want your
   * output to begin.  If this parameter is omitted, results will include Emergency Notification Groups
   * last modified on or before the current date and time.  If a date and time is provided, results will
   * include Emergency Notification Groups last modified on or before that date and time.  Date/time
   * format is YYYY-MM-DDTHH:MM:SS.mmmZ, where the Z indicate UTC time, or YYYY-MM-DDTHH:MM:SS.mmm-hh:mm,
   * where "-hh:mm" represents the local time offset, plus or minus, from UTC time.                </p>
   * </td>        </tr>        <tr>            <td  valign="top">                <p>
   * Size                </p>            </td>            <td  valign="top">                <p>
   * Size=10                </p>            </td>            <td  valign="top">
   * <p>                    100                </p>            </td>            <td  valign="top">
   * <p>                  The maximum number of Emergency Notification Group results to
   * include in the response payload.  This value may be between 1 and 500.                </p>
   * </td>        </tr></table>
   *
   * @param accountId
   * @param page
   * @param size                Example: 100
   * @param engDescription
   * @param enrId
   * @param enrDescription
   * @param enrNotificationType
   * @param enrSmsTn
   * @param enrTtsTn
   * @param enrEmailAddress
   * @param enrCallbackUrl
   * @param enrCallbackUsername
   * @param enrDetails          Example: false
   * @return Response from the API call
   */
  async retrieveEmergencyNotificationGroups(
    accountId: number,
    page?: string,
    size?: number,
    engDescription?: string,
    enrId?: string,
    enrDescription?: string,
    enrNotificationType?: EnrNotificationTypeEnum,
    enrSmsTn?: string,
    enrTtsTn?: string,
    enrEmailAddress?: string,
    enrCallbackUrl?: string,
    enrCallbackUsername?: string,
    enrDetails?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      engDescription: [engDescription, optional(string())],
      enrId: [enrId, optional(string())],
      enrDescription: [enrDescription, optional(string())],
      enrNotificationType: [
        enrNotificationType,
        optional(enrNotificationTypeEnumSchema),
      ],
      enrSmsTn: [enrSmsTn, optional(string())],
      enrTtsTn: [enrTtsTn, optional(string())],
      enrEmailAddress: [enrEmailAddress, optional(string())],
      enrCallbackUrl: [enrCallbackUrl, optional(string())],
      enrCallbackUsername: [enrCallbackUsername, optional(string())],
      enrDetails: [enrDetails, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('EngDescription', mapped.engDescription);
    req.query('EnrId', mapped.enrId);
    req.query('EnrDescription', mapped.enrDescription);
    req.query('EnrNotificationType', mapped.enrNotificationType);
    req.query('EnrSmsTn', mapped.enrSmsTn);
    req.query('EnrTtsTn', mapped.enrTtsTn);
    req.query('EnrEmailAddress', mapped.enrEmailAddress);
    req.query('EnrCallbackUrl', mapped.enrCallbackUrl);
    req.query('EnrCallbackUsername', mapped.enrCallbackUsername);
    req.query('EnrDetails', mapped.enrDetails);
    req.appendTemplatePath`/accounts/${mapped.accountId}/emergencynotificationgroups`;
    req.throwOn(400, ApiError, 'Bad request <br> <p><b>Condition:</b> Unrecognized query parameter <br> <b>Error Description:</b>Query parameter xxx is not recognized. </p> <br> <p><b>Condition:</b>Unsupported value for query parameter <br> <b>Error Description:</b>Invalid value xxx for query parameter yyy. Supported values are aaa, bbb, etc. </p>');
    req.throwOn(403, ApiError, 'Access Denied <br> <p> <b>Condition:</b>User does not have permission to view emergency notification orders, either due to Role/Permission or because the account is not configured for Emergency Notification Config.<br> <b>Error Description:</b>Access Denied </p>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create E911 order to associate the address with the telephone number.The key data elements in the
   * submission are as follows. <table style="text-align: left; width: 80%;"  border="1" cellpadding="2"
   * cellspacing="2">  <tbody>    <tr>      <td>TelephoneNumbers</td>      <td>A list of telephone
   * numbers you need link to the street address.</td>    </tr>    <tr>      <td>CallerName</td>
   * <td>CallerName that will be linked to TNs. This field is required in the case of a new address
   * assignment.</td>    </tr>    <tr>      <td>Address</td>      <td>This field is required in the case
   * of a new address assignment.  Inner fields: HousePrefix, HouseNumber, HouseSuffix, PreDirectional,
   * StreetName, StreetSuffix, PostDirectional, AddressLine2, City, StateCode, Zip, PlusFour.  Streetname,
   * City, and State are required.  House Number is currently required, although this enforcement may be
   * relaxed in the future. Depending on the type of E911 service, the Location ID may be updated by the
   * Bandwidth Dashboard API</td>    </tr>    <tr>      <td>DeleteTNSpecificE911Address</td>      <td>Can
   * be true or false. If value is true then Address and CallerName should not be specified.</td>
   * </tr>    <tr>      <td>AlternateEndUserIdentifiers</td>      <td>A list of AEUIs acts as a
   * replacement for the list of telephone numbers. It replaces the TelephoneNumbers and
   * AdditionalAddress payload element. If ACID exists in external system it will be updated with given
   * values.</td>    </tr>    <tr>      <td>AdditionalAddresses</td>      <td>A list of Address sections.
   * This address information for all potential endpoints which will be provisioned to the Bandwidth 911
   * system. At call time, the customer will submit this address information within the SIP header and,
   * if a match is determined, the call will be routed to the PSAP nearest to that address. Otherwise,
   * the call will be routed to an ECC. These Address sections will be the same in format to the Address
   * section in the top-level of the E911Order payload. It replaces the TelephoneNumbers and
   * AlternateEndUserIdentifiers payload element. </td>    </tr>    <tr>      <td>CustomerOrderId</td>
   * <td>The Customer Order ID is an ID assigned by the account owner to provide a reference number for
   * the Order. The element is optional. Only alphanumeric values, dashes and spaces are allowed. Max
   * length is 40 characters.</td>    </tr>  </tbody></table><br/>Examples of POST requests:<table>
   * <tbody>    <tr>      <th width="20%">Description</th>      <th width="80%">Example</th>    </tr>
   * <tr>      <td>        <strong>CONVENTIONAL E911</strong><br>        TN/Address-provisioning order.
   * <br>        <b>TelephoneNumbers</b>, <b>TelephoneNumber</b>, and <b>Address</b> are required.
   * </td>      <td>        <!-- We have to leave this indent as-is because the <pre> tag is stupid and
   * uses non-relative whitespacing.-->        <pre>&lt;E911Order&gt;  &lt;TelephoneNumbers&gt;    &lt;
   * TelephoneNumber&gt;9706542332&lt;/TelephoneNumber&gt;    &lt;TelephoneNumber&gt;9706542333&lt;
   * /TelephoneNumber&gt;  &lt;/TelephoneNumbers&gt;  &lt;CallerName&gt;OptionalCallerName&lt;
   * /CallerName&gt;  &lt;Address&gt;    &lt;HouseNumber&gt;915&lt;/HouseNumber&gt;    &lt;
   * HouseSuffix/&gt;    &lt;PreDirectional/&gt;    &lt;StreetName&gt;Elm&lt;/StreetName&gt;    &lt;
   * StreetSuffix&gt;Ave&lt;/StreetSuffix&gt;    &lt;PostDirectional/&gt;    &lt;AddressLine2/&gt;    &lt;
   * City&gt;Carpinteria&lt;/City&gt;    &lt;StateCode&gt;CA&lt;/StateCode&gt;    &lt;Zip&gt;93013&lt;
   * /Zip&gt;    &lt;PlusFour/&gt;    &lt;County/&gt;    &lt;Country&gt;United States&lt;/Country&gt;
   * &lt;/Address&gt;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>      <td>
   * <strong>CONVENTIONAL E911</strong><br>        TN/address-deletion order.<br>
   * <b>TelephoneNumbers</b> and <b>TelephoneNumber</b> are required.<br>
   * <b>DeleteTNSpecificE911Address</b> is required and must be set to 'true'.      </td>      <td>
   * <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;
   * TelephoneNumbers&gt;    &lt;TelephoneNumber&gt;9706542332&lt;/TelephoneNumber&gt;    &lt;
   * TelephoneNumber&gt;9706542333&lt;/TelephoneNumber&gt;  &lt;/TelephoneNumbers&gt;  &lt;
   * DeleteTNSpecificE911Address&gt;true&lt;/DeleteTNSpecificE911Address&gt;&lt;/E911Order&gt;
   * </pre>      </td>    </tr>    <tr>      <td>        <strong>PIDF-LO</strong><br>        PIDF-LO AEUI
   * endpoint-provisioning order with additional address provisioning and without pre-defined location id.
   * <br>        <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>, <b>Address</b>,
   * and <b>Identifier</b> are required.<br>        <b>Identifier</b> can only contain alphanumeric
   * characters and must be between 1 and 30 characters.<br>        <b>PIDFLOEnabled</b> is required and
   * must be 'true'.<br>        Default value of <b>PreferredLanguage</b> is 'en'.      </td>      <td>
   * <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;
   * Address&gt;    &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;StreetName&gt;MAIN CAMPUS&lt;
   * /StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;    &lt;City&gt;RALEIGH&lt;/City&gt;
   * &lt;StateCode&gt;NC&lt;/StateCode&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;
   * /PlusFour&gt;    &lt;Country&gt;United States&lt;/Country&gt;    &lt;AddressType&gt;E911&lt;
   * /AddressType&gt;  &lt;/Address&gt;  &lt;AlternateEndUserIdentifiers&gt;    &lt;
   * AlternateEndUserIdentifier&gt;      &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;      &lt;
   * CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;      &lt;Identifier&gt;blep123&lt;/Identifier&gt;
   * &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;      &lt;PreferredLanguage&gt;en&lt;
   * /PreferredLanguage&gt;    &lt;/AlternateEndUserIdentifier&gt;  &lt;/AlternateEndUserIdentifiers&gt;
   * &lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>      <td>        <strong>PIDF-
   * LO</strong><br>        PIDF-LO AEUI endpoint-provisioning order with additional address provisioning
   * and with pre-defined location id.<br>        <b>AlternateEndUserIdentifiers</b>,
   * <b>AlternateEndUserIdentifier</b>, <b>Address</b>, and <b>Identifier</b> are required.<br>
   * <b>Identifier</b> can only contain alphanumeric characters and must be between 1 and 30 characters.
   * <br>        <b>PIDFLOEnabled</b> is required and must be 'true'.<br>        Default value of
   * <b>PreferredLanguage</b> is 'en'.      </td>      <td>        <pre>&lt;E911Order&gt;  &lt;
   * CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;Address&gt;    &lt;LocationId&gt;
   * Some32CharacterOrLessString&lt;/LocationId&gt;    &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;
   * StreetName&gt;MAIN CAMPUS&lt;/StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;    &lt;
   * City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;
   * &lt;PlusFour&gt;5244&lt;/PlusFour&gt;    &lt;Country&gt;United States&lt;/Country&gt;    &lt;
   * AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt;  &lt;AlternateEndUserIdentifiers&gt;
   * &lt;AlternateEndUserIdentifier&gt;      &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;
   * &lt;CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;      &lt;Identifier&gt;blep123&lt;
   * /Identifier&gt;      &lt;PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;      &lt;PreferredLanguage&gt;
   * en&lt;/PreferredLanguage&gt;    &lt;/AlternateEndUserIdentifier&gt;  &lt;
   * /AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>
   * <td>        <strong>PIDF-LO</strong><br>        PIDF-LO AEUI endpoint-provisioning order with
   * provisioned location id.<br>        <b>AlternateEndUserIdentifiers</b>,
   * <b>AlternateEndUserIdentifier</b>, <b>LocationId</b>, and <b>Identifier</b> are required.<br>
   * <b>Identifier</b> can only contain alphanumeric characters and must be between 1 and 30 characters.
   * <br>        <b>PIDFLOEnabled</b> is required and must be 'true'.<br>        Default value of
   * <b>PreferredLanguage</b> is 'en'.      </td>      <td>        <pre>&lt;E911Order&gt;  &lt;
   * CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;AlternateEndUserIdentifiers&gt;
   * &lt;AlternateEndUserIdentifier&gt;      &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;
   * &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;      &lt;CallbackNumber&gt;
   * 9706542333&lt;/CallbackNumber&gt;      &lt;Identifier&gt;blep123&lt;/Identifier&gt;      &lt;
   * PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;      &lt;PreferredLanguage&gt;en&lt;
   * /PreferredLanguage&gt;    &lt;/AlternateEndUserIdentifier&gt;  &lt;/AlternateEndUserIdentifiers&gt;
   * &lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong> and
   * <strong>SIMPLE AEUI</strong><br>        Mixed PIDF-LO AEUI and Non-PIDF-LO AEUI endpoint-
   * provisioning order.<br>        <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>,
   * <b>Address</b>, and <b>Identifier</b> are required.<br>        Default value of
   * <b>PreferredLanguage</b> is 'en'.<br>        <strong>Non-PIDF-LO:</strong><br>
   * <b>CallbackNumber</b> is required.<br>        <b>Identifier</b> can only contain alphanumeric
   * characters and must be between 6 and 30 characters.<br>        <strong>PIDF-LO:</strong><br>
   * <b>PIDFLOEnabled</b> is required and must be 'true'.<br>        <b>Identifier</b> can only contain
   * alphanumeric characters and must be between 1 and 30 characters.      </td>      <td>
   * <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;
   * CallerName&gt;OptionalCallerName&lt;/CallerName&gt;  &lt;Address&gt;    &lt;LocationId&gt;
   * Some32CharacterOrLessString&lt;/LocationId&gt;    &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;
   * StreetName&gt;MAIN CAMPUS&lt;/StreetName&gt;    &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;    &lt;
   * City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;NC&lt;/StateCode&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;
   * &lt;PlusFour&gt;5244&lt;/PlusFour&gt;    &lt;Country&gt;United States&lt;/Country&gt;    &lt;
   * AddressType&gt;E911&lt;/AddressType&gt;  &lt;/Address&gt;  &lt;AlternateEndUserIdentifiers&gt;
   * &lt;AlternateEndUserIdentifier&gt;      &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;
   * &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;      &lt;CallbackNumber&gt;
   * 9706542333&lt;/CallbackNumber&gt;      &lt;Identifier&gt;blep123&lt;/Identifier&gt;      &lt;
   * PIDFLOEnabled&gt;true&lt;/PIDFLOEnabled&gt;      &lt;PreferredLanguage&gt;en&lt;
   * /PreferredLanguage&gt;    &lt;/AlternateEndUserIdentifier&gt;    &lt;AlternateEndUserIdentifier&gt;
   * &lt;CallbackNumber&gt;9706542334&lt;/CallbackNumber&gt;      &lt;Identifier&gt;blepblop&lt;
   * /Identifier&gt;      &lt;PIDFLOEnabled&gt;false&lt;/PIDFLOEnabled&gt;    &lt;
   * /AlternateEndUserIdentifier&gt;  &lt;/AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;
   * </pre>      </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong> and <strong>SIMPLE
   * AEUI</strong><br>        PIDF-LO and Non-PIDF-LO endpoint-deletion order.<br>
   * <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>, and <b>Identifier</b> are
   * required.<br>        <b>DeleteTNSpecificE911Address</b> is required and must be 'true'.<br>
   * <strong>Non-PIDF-LO:</strong><br>        <b>CallbackNumber</b> is required.<br>
   * <b>Identifier</b> can only contain alphanumeric characters 6 and 30 characters.<br>
   * <strong>PIDF-LO:</strong><br>        <b>PIDFLOEnabled</b> is required and must be 'true'.<br>
   * <b>Identifier</b> can only contain alphanumeric characters and must be between 1 and 30 characters.
   * </td>      <td>        <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;CustomOrderId1&lt;
   * /CustomerOrderId&gt;  &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt;
   * &lt;Identifier&gt;identifier&lt;/Identifier&gt;    &lt;/AlternateEndUserIdentifier&gt;  &lt;
   * /AlternateEndUserIdentifiers&gt;  &lt;DeleteTNSpecificE911Address&gt;true&lt;
   * /DeleteTNSpecificE911Address&gt;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>
   * <td><strong>PIDF-LO</strong><br>        PIDF-LO address-provisioning order.<br>
   * <b>AdditionalAddresses</b> and <b>Address</b> are required.      </td>      <td>        <pre>&lt;
   * E911Order&gt;  &lt;CustomerOrderId&gt;CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;
   * AdditionalAddresses&gt;    &lt;Address&gt;      &lt;LocationId&gt;Some32CharacterOrLessString&lt;
   * /LocationId&gt;      &lt;HouseNumber&gt;901&lt;/HouseNumber&gt;      &lt;StreetName&gt;MAIN
   * CAMPUS&lt;/StreetName&gt;      &lt;StreetSuffix&gt;DR&lt;/StreetSuffix&gt;      &lt;City&gt;
   * RALEIGH&lt;/City&gt;      &lt;StateCode&gt;NC&lt;/StateCode&gt;      &lt;Zip&gt;27606&lt;/Zip&gt;
   * &lt;PlusFour&gt;5244&lt;/PlusFour&gt;      &lt;Country&gt;United States&lt;/Country&gt;      &lt;
   * AddressType&gt;E911&lt;/AddressType&gt;    &lt;/Address&gt;    &lt;Address&gt;      &lt;
   * LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;      &lt;HouseNumber&gt;645&lt;
   * /HouseNumber&gt;      &lt;PreDirectional&gt;E&lt;/PreDirectional&gt;      &lt;StreetName&gt;
   * MANCHESTER&lt;/StreetName&gt;      &lt;StreetSuffix&gt;AVE&lt;/StreetSuffix&gt;      &lt;City&gt;LOS
   * ANGELES&lt;/City&gt;      &lt;StateCode&gt;United States&lt;/StateCode&gt;      &lt;Zip&gt;90001&lt;
   * /Zip&gt;      &lt;Country&gt;United States&lt;/Country&gt;    &lt;/Address&gt;  &lt;
   * /AdditionalAddresses&gt;&lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>
   * <td><strong>PIDF-LO</strong> <br>        PIDF-LO address-editing order.<br>        <b>Address</b>
   * and <b>LocationId</b> are required.<br>        Allows a user to update all address fields except
   * <b>PlusFour</b> and <b>Country</b>.      </td>      <td>        <pre>&lt;E911Order&gt;  &lt;
   * AdditionalAddresses&gt;    &lt;Address&gt;      &lt;HouseNumber&gt;645&lt;/HouseNumber&gt;      &lt;
   * PreDirectional&gt;E&lt;/PreDirectional&gt;      &lt;HouseSuffix&gt;1/2&lt;/HouseSuffix&gt;      &lt;
   * PostDirectional&gt;S&lt;/PostDirectional&gt;      &lt;StreetName&gt;Manchester&lt;/StreetName&gt;
   * &lt;StreetSuffix&gt;AVE&lt;/StreetSuffix&gt;      &lt;AddressLine2&gt;test address line 2&lt;
   * /AddressLine2&gt;      &lt;City&gt;Los Angeles&lt;/City&gt;      &lt;StateCode&gt;CA&lt;
   * /StateCode&gt;      &lt;Zip&gt;90001&lt;/Zip&gt;      &lt;LocationId&gt;
   * Some32CharacterOrLessString&lt;/LocationId&gt;    &lt;/Address&gt;  &lt;/AdditionalAddresses&gt;&lt;
   * /E911Order&gt;          </pre>      </td>    </tr>    <tr>      <td><strong>PIDF-LO</strong><br>
   * PIDF-LO address-deletion order.<br>        <b>AdditionalAddresses</b>, <b>Address</b>, and
   * <b>LocationId</b> are required.<br>        <b>DeleteTNSpecificE911Address</b> is required and must
   * be 'true'.      </td>      <td>        <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;
   * CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;AdditionalAddresses&gt;    &lt;Address&gt;      &lt;
   * LocationId&gt;Some32CharacterOrLessString1&lt;/LocationId&gt;    &lt;/Address&gt;    &lt;Address&gt;
   * &lt;LocationId&gt;Some32CharacterOrLessString1&lt;/LocationId&gt;    &lt;/Address&gt;  &lt;
   * /AdditionalAddresses&gt;  &lt;DeleteTNSpecificE911Address&gt;true&lt;/DeleteTNSpecificE911Address&gt;
   * &lt;/E911Order&gt;        </pre>      </td>    </tr>    <tr>      <td><strong>SIMPLE
   * AEUI</strong><br>        Non-PIDF-LO endpoint-provisioning order.<br>
   * <b>AlternateEndUserIdentifiers</b>, <b>AlternateEndUserIdentifier</b>, <b>Address</b>,
   * <b>CallbackNumber</b>, and <b>Identifier</b> are required<br>        <b>Identifier</b> can only
   * contain alphanumeric characters, must contain at least one letter, and must be between 6 and 30
   * characters.<br>      </td>      <td>        <pre>&lt;E911Order&gt;  &lt;CustomerOrderId&gt;
   * CustomOrderId1&lt;/CustomerOrderId&gt;  &lt;CallerName&gt;OptionalCallerName&lt;/CallerName&gt;  &lt;
   * Address&gt;    &lt;LocationId&gt;Some32CharacterOrLessString&lt;/LocationId&gt;    &lt;
   * HouseNumber&gt;901&lt;/HouseNumber&gt;    &lt;StreetName&gt;MAIN CAMPUS&lt;/StreetName&gt;    &lt;
   * StreetSuffix&gt;DR&lt;/StreetSuffix&gt;    &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;StateCode&gt;
   * NC&lt;/StateCode&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;    &lt;PlusFour&gt;5244&lt;/PlusFour&gt;    &lt;
   * Country&gt;United States&lt;/Country&gt;    &lt;AddressType&gt;E911&lt;/AddressType&gt;  &lt;
   * /Address&gt;  &lt;AlternateEndUserIdentifiers&gt;    &lt;AlternateEndUserIdentifier&gt;      &lt;
   * CallbackNumber&gt;9706542333&lt;/CallbackNumber&gt;      &lt;Identifier&gt;abc123&lt;/Identifier&gt;
   * &lt;PIDFLOEnabled&gt;false&lt;/PIDFLOEnabled&gt;    &lt;/AlternateEndUserIdentifier&gt;  &lt;
   * /AlternateEndUserIdentifiers&gt;&lt;/E911Order&gt;        </pre>      </td>    </tr>
   * </tbody></table><br/><b>Error Codes.</b><br/>For all possible error codes that can be returned in an
   * E911 order, refer to section 6.4 of the Error Code Reference.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createE911Order(
    accountId: number,
    body?: E911OrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'E911Order', optional(e911OrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/e911s`;
    req.throwOn(400, ApiError, 'Bad Request<br>A 400 response indicates that the order could not be created.<br>Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve a list of the externalTns orders that are associated with the account. <p>A maximum of 1,
   * 000 orders can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param orderDetails      Example: false
   * @param orderIdFragment
   * @param action
   * @param type
   * @return Response from the API call
   */
  async getOrders2(
    accountId: number,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    orderDetails?: boolean,
    orderIdFragment?: string,
    action?: string,
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      action: [action, optional(string())],
      type: [type, optional(string())],
    });
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('orderDetails', mapped.orderDetails);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('action', mapped.action);
    req.query('type', mapped.type);
    req.appendTemplatePath`/accounts/${mapped.accountId}/externalTns`;
    req.throwOn(404, ApiError, 'No externalTns orders can be found that match the query parameters.');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Create a externalTns order to add or remove telephone numbers provided by the customer from the
   * Bandwidth network.Note: the attempt to import a telephone number that is already present in the
   * account will *not* create an error, but will reset all of the  attributes of that telephone number
   * in the Dashboard system as if the telephone number was being imported for the first timeThe key data
   * elements in the submission are - <table style="text-align: left; width: 80%;" border="1"
   * cellpadding="2" cellspacing="2">  <tbody>    <tr>      <td>CustomerOrderId</td>      <td>An order ID
   * created by the customer for their tracking purposes. Only alphanumeric values, dashes and spaces are
   * allowed. Max length is 40 characters.</td>    </tr>    <tr>      <td>SiteId</td>      <td>(Required)
   * The ID of the Site that the Telephone Numbers are to be provisioned to.</td>    </tr>    <tr>
   * <td>SipPeerId</td>      <td>(Optional) The ID of the SIP Peer that the Telephone Numbers are to be
   * provisioned to.</td>    </tr>    <tr>      <td>Action</td>      <td>(Required) Indentify the action
   * on external TNs. Allowed values... IMPORT or REMOVE.</td>    </tr>    <tr>      <td>LoaType</td>
   * <td>(Optional) Indentify the LoaType on external TNs. Allowed values... CARRIER or  SUBSCRIBER.
   * Default value is CARRIER</td>    </tr>  </tbody></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOrder1(
    accountId: number,
    body?: ExternalTnsOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'ExternalTnsOrder',
      optional(externalTnsOrderPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/externalTns`;
    req.throwOn(400, ApiError, 'Bad Request <br> A 400 response Indicates that the order could not be created.Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a TelephoneNumbersAssignment order with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrder(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/numbersAssignment/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'TelephoneNumbersAssignmentOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Request a collection of BDRs be aggregated and ZIPped ready for distribution.  The payload for the
   * POST declares the date range for the request.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createBdr(
    accountId: number,
    body?: BdrArchiveCreationDescriptor,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Bdr', optional(bdrArchiveCreationDescriptorSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bdrs`;
    req.throwOn(404, ApiError, 'A 400 response indicates that there was an error in processing the payload, perhaps something like incorrectly formatted or chosen dates. ');
    return req.callAsXml('BdrResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param bdrId
   * @return Response from the API call
   */
  async getBdrArchiveFile(
    accountId: number,
    bdrId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      bdrId: [bdrId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bdrs/${mapped.bdrId}/file`;
    return req.callAsXml('BdrFileResponse', unknown(), requestOptions);
  }

  /**
   * A GET on the BDR ID will return a "still processing" indication if the file creation has not
   * completed, or will redirect to the file to be downloaded.
   *
   * @param accountId
   * @param bdrId
   * @return Response from the API call
   */
  async getBdr(
    accountId: number,
    bdrId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BdrArchiveRetrievalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      bdrId: [bdrId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bdrs/${mapped.bdrId}`;
    req.throwOn(400, ApiError, 'A 400 indicates that the BDR id is malformed. ');
    req.throwOn(404, ApiError, 'A 404 indicates that the BDR id cannot be found. ');
    return req.callAsXml(
      'BdrRetrievalResponse',
      bdrArchiveRetrievalResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve billing report instances within the account scope and billing type.The valid Billing Types
   * are...
   * <ul><li>BDR</li><li>MDR</li><li>INVOICE</li><li>STMTBDR</li><li>DIDSNAP</li><li>DIDSNAP_MSG</li><li>
   * RECORDINGBDR</li><li>RECORDINGSTMTBDR</li><li>TRANSCRIPTIONBDR</li><li>TRANSCRIPTIONSTMTBDR</li><li>
   * CNAMBDR</li><li>CNAMSTMTBDR</li><li>CONFBDR</li><li>CONFSTMTBDR</li></ul>
   *
   * @param accountId
   * @param kind
   * @return Response from the API call
   */
  async retrieveReports(
    accountId: number,
    kind?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BillingReportsRetrievalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      kind: [kind, optional(string())],
    });
    req.query('kind', mapped.kind);
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingreports`;
    req.throwOn(400, ApiError, 'A 400 response indicates that report type is incorrect.');
    return req.callAsXml(
      'BillingReportsRetrievalResponse',
      billingReportsRetrievalResponseSchema,
      requestOptions
    );
  }

  /**
   * The payload for the POST declares the date range and type for the desired reports. The valid Types
   * are... <ul> <li>BDR - Billing Detail Records - per call information</li> <li>MDR - Message Detail
   * Records - per messagin information</li> <li>INVOICE - A copy of the invoice file or files for the
   * specified date range</li> <li>STMTBDR - BDR records that are aligned with the invoice</li>
   * <li>DIDSNAP - a list of telephone numbers aligned as closely as we can with the billing window</li>
   * <li>DIDSNAP_MSG - a list of telephone numbers with active messaging</li> </ul>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createReport(
    accountId: number,
    body?: BillingReportCreationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BillingReportCreationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'BillingReport',
      optional(billingReportCreationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingreports`;
    req.throwOn(404, ApiError, 'A 400 response indicates that there was an error in processing the payload, perhaps something like incorrectly formatted or chosen dates. ');
    return req.callAsXml(
      'BillingReportCreationResponse',
      billingReportCreationResponseSchema,
      requestOptions
    );
  }

  /**
   * A GET on the /file resource subtending a report ID will cause the download of the file.  Executing
   * this resource path within a browser will cause the download of the file.
   *
   * @param accountId
   * @param archiveId
   * @return Response from the API call
   */
  async retrieveReportArchive(
    accountId: number,
    archiveId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BillingReportArchiveRetrievalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      archiveId: [archiveId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingreports/${mapped.archiveId}/file`;
    req.throwOn(400, ApiError, 'A 400 indicates that the report ID is malformed.');
    req.throwOn(404, ApiError, 'A 404 indicates that the requested report cannot be found.');
    return req.callAsXml(
      'BillingReportArchiveRetrievalResponse',
      billingReportArchiveRetrievalResponseSchema,
      requestOptions
    );
  }

  /**
   * Get Billing Report
   *
   * @param accountId
   * @param archiveId
   * @return Response from the API call
   */
  async retrieveReport(
    accountId: number,
    archiveId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BillingReportRetrievalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      archiveId: [archiveId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingreports/${mapped.archiveId}`;
    req.throwOn(400, ApiError, 'A 400 indicates that the report ID is malformed.');
    req.throwOn(404, ApiError, 'A 404 indicates that the requested report cannot be found.');
    return req.callAsXml(
      'BillingReportRetrievalResponse',
      billingReportRetrievalResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with a named DLDA order.  This indicates the various
   * states that the order has passed through, as well as the current state of the order as the last
   * entry.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getDldaOrderHistory(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/dldas/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a externalTns order with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrder2(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/externalTns/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory1(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/externalTns/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about a importTnOrder with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrder4(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/importtnorders/${mapped.orderId}`;
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the importtnorders requests for the given account ID. <p>A maximum of 1,000 orders can be
   * retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param orderIdFragment
   * @param activityState
   * @param bandwidthPrime
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @param orderDetails          Example: false
   * @param status
   * @return Response from the API call
   */
  async getOrders4(
    accountId: number,
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    orderIdFragment?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    orderDetails?: boolean,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      orderDetails: [orderDetails, optional(boolean())],
      status: [status, optional(string())],
    });
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('orderDetails', mapped.orderDetails);
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/importtnorders`;
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Creates an importTnOrders request to add numbers under the given site ID and sippeer ID as specified
   * in the body.A successfully submitted order will have a status of "RECEIVED". A successfully
   * completed order will have a status of "COMPLETE" if all of the telephone numbers were successfully
   * imported and  "PARTIAL" if some of the telephone numbers were imported. A failed order with will
   * have a staus of "FAILED" and no telephone numbers would have been imported.The elements supplied in
   * the payloads are described in the following table:<table border="1" cellspacing="0" cellpadding="0"
   * width="624">    <tbody>        <tr>            <td valign="top">                <p>
   * <strong>Parameter</strong>                </p>            </td>            <td valign="top">
   * <p>                    <strong>Required</strong>                </p>            </td>
   * <td width="351" valign="top">                <p>
   * <strong>Description</strong>                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    accountId (URL Parameter)
   * </p>            </td>            <td valign="top">                <p align="center">
   * Yes                </p>            </td>            <td width="351" valign="top">
   * <p>                    The account ID for porting the numbers.                </p>            </td>
   * </tr>        <tr>            <td valign="top">                <p>
   * CustomerOrderId                </p>            </td>            <td valign="top">                <p
   * align="center">                    No                </p>            </td>            <td
   * width="351" valign="top">                <p>                    Internal customer order id for
   * tracking the order.  Only alphanumeric values, dashes and spaces are allowed. Max length is 40
   * characters.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    Name                </p>            </td>
   * <td valign="top">                <p align="center">                    Yes                </p>
   * </td>            <td width="351" valign="top">                <p>
   * Subscriber business / customer name.                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    HouseNumber                </p>
   * </td>            <td valign="top">                <p align="center">                    Yes
   * </p>            </td>            <td width="351" valign="top">                <p>
   * Street address number.                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    StreetName                </p>
   * </td>            <td valign="top">                <p align="center">                    Yes
   * </p>            </td>            <td width="351" valign="top">                <p>
   * Street name.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    City                </p>            </td>
   * <td valign="top">                <p align="center">                    Yes                </p>
   * </td>            <td width="351" valign="top">                <p>                    City.
   * </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    StateCode                </p>            </td>            <td
   * valign="top">                <p align="center">                    Yes                </p>
   * </td>            <td width="351" valign="top">                <p>                    Two letter
   * state code.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    Zip                </p>            </td>
   * <td valign="top">                <p align="center">                    Yes                </p>
   * </td>            <td width="351" valign="top">                <p>                    Zip
   * code.                </p>            </td>        </tr>        <tr>            <td valign="top">
   * <p>                    LoaAuthorizingPerson                </p>            </td>
   * <td valign="top">                <p align="center">                    Yes                </p>
   * </td>            <td width="351" valign="top">                <p>                    First
   * and last name of person who authorized LOA.                </p>            </td>        </tr>
   * <tr>            <td valign="top">                <p>                    LoaType                </p>
   * </td>            <td valign="top">                <p align="center">
   * Yes                </p>            </td>            <td width="351" valign="top">                <p>
   * (Optional) Indentify the LoaType on TNs. Allowed values... CARRIER or  SUBSCRIBER.
   * Default value is SUBSCRIBER.                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    TelephoneNumber                </p>
   * </td>            <td valign="top">                <p align="center">                    Yes
   * </p>            </td>            <td width="351" valign="top">                <p>
   * Ten digit phone number with no dots or dashes. One or more is required. Use a PhoneNumber
   * tag for each phone number in the list.                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    SiteId                </p>
   * </td>            <td valign="top">                <p align="center">                    Yes
   * </p>            </td>            <td width="351" valign="top">                <p>
   * See section on Sites                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    SipPeerId                </p>
   * </td>            <td valign="top">                <p align="center">                    No
   * </p>            </td>            <td width="351" valign="top">                <p>
   * See section on SIP Peers                </p>            </td>        </tr>    </tbody></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOrder2(
    accountId: number,
    body?: ImportTnOrdersPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'ImportTnOrder',
      optional(importTnOrdersPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/importtnorders`;
    req.throwOn(400, ApiError, 'The order failed; one of the input parameters is invalid. The error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the history of the specified importTnOrder.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory3(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/importtnorders/${mapped.orderId}/history`;
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getLidbOrderHistory1(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/lidbs/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific Lidb Order identified as the resource.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getLidbOrder(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/lidbs/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve a list of the LIDB orders that are associated with the account. <p>A maximum of 1,000
   * orders can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param lastModifiedAfter
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @return Response from the API call
   */
  async getLidbOrder2(
    accountId: number,
    lastModifiedAfter?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
    });
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.appendTemplatePath`/accounts/${mapped.accountId}/lidbs`;
    req.throwOn(404, ApiError, 'NOT FOUNDIf any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Create TN Option order to assign line features to the telephone number.The key data elements in the
   * submission are - <table style="text-align: left; width: 80%;" border="1" cellpadding="2"
   * cellspacing="2">  <tbody>    <tr>      <td>TnOptionGroups</td>      <td>A list of TnOptionGroups.
   * </td>    </tr>    <tr>      <td>TnOptionGroup</td>      <td>Contains list of telephone numbers and
   * set of TN options you want to assign to all TNs in the list.</td>    </tr>    <tr>
   * <td>CustomerOrderId</td>        <td>Optional value for Id set by customer. Only alphanumeric values,
   * dashes and spaces are allowed. Max length is 40 characters.</td>    </tr>  </tbody></table>There are
   * TN Option values:<ul><li> TelephoneNumber - [ 10digit ] </li><li> CallingNameDisplay - [ on | off |
   * <i>unchanged</i> | <i>systemDefault</i> ] </li><li> PortOutPasscode - [ alphanumeric string 4-10
   * characters | unchanged | systemDefault ] </li><li> NumberFormat - [ 10digit | 11digit | e164 |
   * <i>unchanged</i> | <i>systemDefault</i> ] </li><li> RPIDFormat - [ 10digit | 11digit | e164 |
   * <i>unchanged</i> | <i>systemDefault</i> ] </li><li> RewriteUser - [ string | <i>unchanged</i> |
   * <i>systemDefault</i>] </li><li> CallForward - [ 10digit | <i>unchanged</i> | <i>systemDefault</i>]
   * </li><li> Protected - [ true | false | <i>unchanged</i> | <i>systemDefault</i>] </li><li> Sms - [ on
   * | off | <i>unchanged</i>] </li><li> FinalDestinationURI - [ string | <i>unchanged</i> |
   * <i>systemDefault</i>] </li><ul>  <li>a 10 digit telephone number, or</li>  <li>a SIP URI ( without
   * the sip: prefix )    <ul>      <li>in the form address-string@host IP:port, where </li>      <li>the
   * host IP is an IPv4 address in the standard numerical n.n.n.n. form, and </li>      <li>the port is
   * numeric, and optional</li>      <li>containing [a-z,A-Z,0-9], with ':', '.' and '@' to delimit the
   * components of the overall string, and</li>      <li>less than 60 characters long.</li>    </ul>
   * </li></ul><li> NNID [ integer | <i>unchanged</i> | <i>systemDefault</i> ] </li><li> ESPID [ string |
   * <i>unchanged</i> | <i>systemDefault</i> ] </li><li> A2pSettings </li><ul>  <li>MessageClass - [
   * string {1,64} ] </li>  <li>CampaignId - [ string {1,64} ] </li>  <li>Action - [ <i>asSpecified</i> |
   * <i>off</i> | <i>unchanged</i> | <i>systemDefault</i> ] </li></ul><li> Origination Route Plan
   * </li><ul>  <li>Route List</li>    <ul>    <li>Endpoint</li>      <ul>        <li>a NANP telephone
   * number, or</li>        <li>a SIP URI, or</li>        <li>a IPv4 address, or </li>        <li>a Fully
   * Qualified Domain name(FQDN) </li>      </ul>    <li>Priority</li>    <li>Weight</li>    </ul>
   * <li>Action - [ <i>asSpecified</i> | <i>off</i> | <i>unchanged</i>] </li></ul></ul>Where:  <ul>
   * <li>for A2pSettings attribute</li>    <table style="text-align: left; width: 80%;"
   * border="1" cellpadding="2" cellspacing="0">        <tbody>        <tr>          <th>Number
   * attribute</th>          <th>Action value</th>          <th>Describe of action</th>        </tr>
   * <tr>          <td>LongCode</td>          <td><i>systemDefault</i></td>          <td>Removes the
   * per-TN A2P attributes, and it reverts to the Location/SIP Peer characteristics. Any values for Class
   * or Campaign ID are not valid</td>        </tr>        <tr>          <td>LongCode</td>
   * <td><i>asSpecified</i></td>          <td>Sets the message class and campaign ID - this is the
   * default if unspecified</td>        </tr>        <tr>          <td>LongCode</td>
   * <td><i>off</i></td>          <td>Will set the TN as a 'P' TN. Any values for Class or Campaign ID
   * are not valid</td>        </tr>        <tr>          <td>LongCode</td>
   * <td><i>unchanged</i></td>          <td>Do nothing with respect to A2P</td>        </tr>        <tr>
   * <td>TollFree</td>          <td><i>systemDefault</i></td>          <td>Removes the per-TN A2P
   * attributes, and it reverts to the Location/SIP Peer characteristics. Any values for Class or
   * Campaign ID are not valid</td>        </tr>        <tr>          <td>TollFree</td>
   * <td><i>asSpecified</i></td>          <td>Sets the message class and campaign ID - this is the
   * default if unspecified</td>        </tr>        <tr>          <td>TollFree</td>
   * <td><i>off</i></td>          <td>If the Togglz value is set to 'on' this is invalid for Toll Free
   * telephone numbers. Any values for Class or Campaign ID in the payload are invalid. If the Togglz
   * value is set to off this behaves like and A2P TN, where the characteristics of the TNs is set to
   * 'P'</td>        </tr>        <tr>          <td>TollFree</td>          <td><i>unchanged</i></td>
   * <td>Do nothing with respect to A2P</td>        </tr>        </tbody>    </table>    <li>for
   * Origination Route plan attribute</li>    <table style="text-align: left; width: 80%;"
   * border="1" cellpadding="2" cellspacing="0">        <tbody>        <tr>          <th>Action
   * value</th>          <th>Describe of action</th>        </tr>        <tr>
   * <td>asSpecified</td>          <td>Creates/updates the origination route plan for the TN with route
   * plan details provided in the request </td>        </tr>        <tr>          <td>off</td>
   * <td>Removes the origination route plan for the TN. Route list is the request must be empty</td>
   * </tr>        <tr>          <td>unchanged</td>          <td>Doesn't update/create the origination
   * route plan, even when route plan details exist in the request</td>        </tr>        </tbody>
   * </table>    <ul>      <li> Origination route plan is validated against CallForward and
   * RewriteUser</li>        <ul>          <li type="square">Route plan and CallForward cannot co-exist.
   * Order is accepted but will respond with error messages on GET.</li>          <li type="square">Route
   * plan and RewriteUser cannot co-exist. Order is accepted but will respond with error messages on GET.
   * </li>        </ul>    </ul>    <li>for other attribute</li>    <ul>      <li type="square">
   * <i>systemDefault</i> - implies that the element profile value should be removed so that the TN
   * changes back to the default system behavior;</li>      <li type="square"> <i>unchanged</i> - the
   * value should remain unchanged - implies a read before write model.</li>      <li
   * type="square"><u>Leaving the element out of the payload is equivalent to <i>unchanged</i>.</u></li>
   * </ul>  </ul>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOrder5(
    accountId: number,
    body?: TnOptionOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TnOptionOrder',
      optional(tnOptionOrderPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnoptions`;
    req.throwOn(400, ApiError, 'Bad Request <br> A 400 response Indicates that the order could not be created.Error text and an error code will be provided in the ErrorList element.');
    req.throwOn(409, ApiError, 'Conflict <br> A 409 response indicates that order could not be created.Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves a list of lsrorders.  Various query parameters can be used to filter the list of LSR
   * Orders as documented below. <p>A maximum of 1,000 orders can be retrieved per request. If no date
   * range or specific query parameter (marked by <b class="required">*</b> below) is provided, the order
   * results will be limited to the last two years.</p>
   *
   * @param accountId
   * @param createdDateFrom
   * @param createdDateTo
   * @param customerOrderId
   * @param orderIdFragment
   * @param status
   * @param tn
   * @param pon
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @return Response from the API call
   */
  async getOrder7(
    accountId: number,
    createdDateFrom?: string,
    createdDateTo?: string,
    customerOrderId?: string,
    orderIdFragment?: string,
    status?: string[],
    tn?: string,
    pon?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      status: [status, optional(array(string()))],
      tn: [tn, optional(string())],
      pon: [pon, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
    });
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('status', mapped.status);
    req.query('tn', mapped.tn);
    req.query('pon', mapped.pon);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders`;
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * A POST creates a lsrorder request to initiate a port-out action.<br>The payload fields are described
   * below...<br><table style="text-align: left; width: 80%;"     border="1" cellpadding="2"
   * cellspacing="2">      <tbody>        <tr>          <td>Pon</td>          <td>The Pon is customer
   * specified order indentifier field. Allowed alphanumeric and "#","-","_". Up to 25 characters long.
   * (required).</td>        </tr>        <tr>          <td>CustomerOrderId</td>          <td>The
   * CustomerOrderId is customer specified order indentifier field. Allowed alphanumeric, spaces and
   * dashes. Up to 40 characters long. (optional).</td>        </tr>        <tr>          <td>SPID</td>
   * <td>Identifier used in porting process. If account is no multi-SPID option - default with
   * account value, otherwise value is required. Up to 4 characters long. (required)</td>        </tr>
   * <tr>          <td>BillingTelephoneNumber</td>          <td>Non-tollfree 10 digit phone number
   * (optional).</td>        </tr>        <tr>          <td>RequestedFocDate</td>          <td>optional
   * (next day if not specified).</td>        </tr>        <tr>          <td>SubscriberType</td>
   * <td>Subscriber type. BUSINESS | RESEDENTIAL (optional) (RESEDENTIAL if not specified).</td>
   * </tr>        <tr>          <td>BusinessName</td>          <td>Subscriber business name for BUSINESS
   * SubscriberType. Up to 25 characters long. (required BusinessName or LastName).</td>        </tr>
   * <tr>          <td>LastName</td>          <td>Subscriber last name for RESEDENTIAL SubscriberType.
   * Up to 25 characters long. (required BusinessName or LastName).</td>        </tr>        <tr>
   * <td>FirstName</td>          <td>Subscriber first name for RESEDENTIAL SubscriberType. Up to 25
   * characters long. (optional).</td>        </tr>        <tr>          <td>MiddleInitial</td>
   * <td>Subscriber middle initial for RESEDENTIAL SubscriberType. 1 character (optional).</td>
   * </tr>                        <tr>          <td>AccountNumber</td>          <td>AccountNumber.
   * Alphanumeric, up to 32 characters. (optional).</td>        </tr>                        <tr>
   * <td>PinNumber</td>          <td>PinNumber. Alphanumeric, up to 10 characters. (optional).</td>
   * </tr>        <tr>          <td>AuthorizingPerson</td>          <td>AuthorizingPerson. Alphanumeric,
   * up to 100 characters (required).</td>        </tr>        <tr>          <td>HousePrefix</td>
   * <td>HousePrefix. Alphanumeric, up to 6 characters.</td>        </tr>        <tr>
   * <td>HouseNumber</td>          <td>HouseNumber. Alphanumeric, up to 45 characters  (required).</td>
   * </tr>        <tr>          <td>HouseSuffix</td>          <td>HouseSuffix. Alphanumeric, up to
   * 45 characters.</td>        </tr>        <tr>          <td>PreDirectional</td>
   * <td>PreDirectional. Alphanumeric, up to 2 characters.</td>        </tr>        <tr>
   * <td>StreetName</td>          <td>StreetName. Alphanumeric, up to 200 characters  (required).</td>
   * </tr>        <tr>          <td>StreetSuffix</td>          <td>StreetSuffix. Alphanumeric, up to
   * 45 characters.</td>        </tr>        <tr>          <td>PostDirectional</td>
   * <td>PostDirectional. Alphanumeric, up to 2 characters.</td>        </tr>        <tr>
   * <td>AddressLine2</td>          <td>AddressLine2. Alphanumeric, up to 200 characters.</td>
   * </tr>        <tr>          <td>County</td>          <td>County. Alphanumeric, up to 45 characters.
   * </td>        </tr>        <tr>          <td>City</td>          <td>City. Alphanumeric, up to 100
   * characters  (required).</td>        </tr>        <tr>          <td>StateCode</td>
   * <td>StateCode. Alphanumeric, 2 characters  (required).</td>        </tr>        <tr>
   * <td>Zip</td>          <td>Zip code. Allowed formats: 5 numbers, 5+4 or Canadian  (required).</td>
   * </tr>        <tr>          <td>ListOfTelephoneNumbers</td>          <td>List of tns to be
   * processed  (required).</td>        </tr>        </tbody>    </table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createLsrOrder(
    accountId: number,
    body?: LsrOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LsrOrderResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'LsrOrder', optional(lsrOrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders`;
    req.throwOn(400, ApiError, 'Bad request shows that lsrorder request does not pass validation. Fror more info see LsrOrderErrors section in response.');
    return req.callAsXml(
      'LsrOrderResponse',
      lsrOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information associated with the specified lsr ID number.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrder8(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders/${mapped.orderId}`;
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the history of the specified lsr order.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory5(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param status
   * @return Response from the API call
   */
  async getTotalOrdersByStatus(
    accountId: number,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LongXMLWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(string())],
    });
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders/totals`;
    return req.callAsXml('Quantity', longXMLWrapperSchema, requestOptions);
  }

  /**
   * Retrieve information about a removeImportedTnOrder with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrder9(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/removeImportedTnOrders/${mapped.orderId}`;
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the removeImportedTnOrders requests for the given account ID. <p>A maximum of 1,000 orders
   * can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param orderIdFragment
   * @param activityState
   * @param bandwidthPrime
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @param orderDetails          Example: false
   * @param status
   * @return Response from the API call
   */
  async getOrders7(
    accountId: number,
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    orderIdFragment?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    orderDetails?: boolean,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      orderDetails: [orderDetails, optional(boolean())],
      status: [status, optional(string())],
    });
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('orderDetails', mapped.orderDetails);
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/removeImportedTnOrders`;
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Creates a removeImportedTnOrders request to remove imported telephone numbers from the given site ID
   * and sippeer ID as specified in the body. A successfully submitted order will have a status of
   * "PROCESSING". A successfully completed order will have a status of "COMPLETE" if all of the
   * telephone numbers were successfully removed and  "PARTIAL" if some of the telephone numbers were
   * removed. A failed order with will have a staus of "FAILED" and no telephone numbers would have been
   * removed.The elements supplied in the payloads are described in the following table:<table border="1"
   * cellspacing="0" cellpadding="0" width="624">    <tbody>        <tr>            <td valign="top">
   * <p>                    <strong>Parameter</strong>                </p>            </td>
   * <td valign="top">                <p>                    <strong>Required</strong>
   * </p>            </td>            <td width="351" valign="top">                <p>
   * <strong>Description</strong>                </p>            </td>        </tr>        <tr>
   * <td valign="top">                <p>                    accountId (URL Parameter)
   * </p>            </td>            <td valign="top">                <p align="center">
   * Yes                </p>            </td>            <td width="351" valign="top">
   * <p>                    The account ID for porting the numbers.                </p>            </td>
   * </tr>        <tr>            <td valign="top">                <p>
   * CustomerOrderId                </p>            </td>            <td valign="top">                <p
   * align="center">                    No                </p>            </td>            <td
   * width="351" valign="top">                <p>                    Internal customer order id for
   * tracking the order.  Only alphanumeric values, dashes and spaces are allowed. Max length is 40
   * characters.                </p>            </td>        </tr>        <tr>            <td
   * valign="top">                <p>                    TelephoneNumber                </p>
   * </td>            <td valign="top">                <p align="center">                    Yes
   * </p>            </td>            <td width="351" valign="top">                <p>
   * Ten digit phone number with no dots or dashes. One or more is required. Use a PhoneNumber tag
   * for each phone number in the list.                </p>            </td>        </tr>
   * </tbody></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOrder4(
    accountId: number,
    body?: RemoveImportedTnOrdersPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'RemoveImportedTnOrder',
      optional(removeImportedTnOrdersPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/removeImportedTnOrders`;
    req.throwOn(400, ApiError, 'The order failed; one of the input parameters is invalid. The error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the history of the specified removeImportedTnOrder.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory7(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/removeImportedTnOrders/${mapped.orderId}/history`;
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory8(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param status
   * @return Response from the API call
   */
  async getTotalOrdersByStatus1(
    accountId: number,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(string())],
    });
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/totals`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * returns a list of phone numbers associated with the ID of a given account.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getTNsByOrderId(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}/tns`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the area codes of the phone numbers from the specified order.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getReportByNPA(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}/areaCodes`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * GET is used to retrieve order ids and order details for previously attempted Telephone Number orders.
   * <p>A maximum of 1,000 orders can be retrieved per request. If no date range or specific query
   * parameter (marked by <b class="required">*</b> below) is provided, the order results will be limited
   * to the last two years.</p>
   *
   * @param accountId
   * @param userid
   * @param startdate
   * @param enddate
   * @param status
   * @param customerOrderId
   * @param page
   * @param size
   * @return Response from the API call
   */
  async getTnOrders1(
    accountId: number,
    userid?: string,
    startdate?: string,
    enddate?: string,
    status?: string,
    customerOrderId?: string,
    page?: string,
    size?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      userid: [userid, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
      status: [status, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
    });
    req.query('userid', mapped.userid);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.query('status', mapped.status);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders`;
    req.throwOn(400, ApiError, 'Bad Request - malformed Query Parameters can result in a 400 Bad request.');
    req.throwOn(404, ApiError, 'Not Found - returned if the retrieval request cannot be satisfied, either because the order id cannot be found or the order id is not recognized.');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the Telephone Numbers associated by the given order ID
   *
   * @param accountId
   * @param siteId    Example: 0
   * @param orderId
   * @return Response from the API call
   */
  async getTnsByOrderId(
    accountId: number,
    siteId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/orders/${mapped.orderId}/tns`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * GET all of the details associated with an identified order
   *
   * @param accountId
   * @param orderId
   * @param tndetail  Example: false
   * @return Response from the API call
   */
  async getTnOrder1(
    accountId: number,
    orderId: string,
    tndetail?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
      tndetail: [tndetail, optional(boolean())],
    });
    req.query('tndetail', mapped.tndetail);
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * The GET method retrieves all the orders associated with the given site.
   *
   * @param accountId
   * @param siteId    Example: 0
   * @param userid
   * @param startdate
   * @param enddate
   * @param status
   * @param page
   * @param size
   * @return Response from the API call
   */
  async getTnOrdersBySite(
    accountId: number,
    siteId: number,
    userid?: string,
    startdate?: string,
    enddate?: string,
    status?: string,
    page?: string,
    size?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      userid: [userid, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
      status: [status, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
    });
    req.query('userid', mapped.userid);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.query('status', mapped.status);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/orders`;
    req.throwOn(404, ApiError, 'Orders cannot be found for that site. Possible explanations:<ul>    <li>There are no orders associated with that site.</li>    <li>The given parameters are invalid.</li></ul>');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId    Example: 0
   * @param orderId
   * @param tndetail  Example: false
   * @return Response from the API call
   */
  async getTnOrderForSiteId(
    accountId: number,
    siteId: number,
    orderId: string,
    tndetail?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      orderId: [orderId, string()],
      tndetail: [tndetail, optional(boolean())],
    });
    req.query('tndetail', mapped.tndetail);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/orders/${mapped.orderId}`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the total quantity of phone numbers from the specified order.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getCountTNsByOrderId(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}/totals`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the Npa-Nxx of the phone numbers from the specified order.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getReportByNPANXX(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/orders/${mapped.orderId}/npaNxx`;
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param productName
   * @return Response from the API call
   */
  async getProductTnHistory(
    accountId: number,
    productName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductTnHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productName: [productName, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/${mapped.productName}/tntotals`;
    return req.callAsXml(
      'ProductTNDetailsResponse',
      productTnHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve count of Telephone numbers for Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param feature
   * @return Response from the API call
   */
  async getSipPeerTelephoneNumbersCount(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    feature?: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumbersCountResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      feature: [feature, optional(array(string()))],
    });
    req.query('feature', mapped.feature);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/totaltns`;
    return req.callAsXml(
      'SipPeerTelephoneNumbersCountResponse',
      sipPeerTelephoneNumbersCountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param fullnumber
   * @param rateCenter
   * @param lata
   * @param tier
   * @param npa
   * @param npaNxx
   * @param npaNxxX
   * @param city
   * @param state
   * @param host
   * @param orderId
   * @param lastModifiedDateFrom
   * @param lastModifiedDateTo
   * @param mProtected
   * @param status
   * @return Response from the API call
   */
  async searchAccountTelephoneNumbers(
    accountId?: number[],
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    fullnumber?: string,
    rateCenter?: string,
    lata?: number,
    tier?: number,
    npa?: string,
    npaNxx?: string,
    npaNxxX?: string,
    city?: string,
    state?: string,
    host?: string,
    orderId?: string,
    lastModifiedDateFrom?: string,
    lastModifiedDateTo?: string,
    mProtected?: string,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumbersHistoryResponse>> {
    const req = this.createRequest('GET', '/tns');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      fullnumber: [fullnumber, optional(string())],
      rateCenter: [rateCenter, optional(string())],
      lata: [lata, optional(number())],
      tier: [tier, optional(number())],
      npa: [npa, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxX: [npaNxxX, optional(string())],
      city: [city, optional(string())],
      state: [state, optional(string())],
      host: [host, optional(string())],
      orderId: [orderId, optional(string())],
      lastModifiedDateFrom: [lastModifiedDateFrom, optional(string())],
      lastModifiedDateTo: [lastModifiedDateTo, optional(string())],
      mProtected: [mProtected, optional(string())],
      status: [status, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('fullnumber', mapped.fullnumber);
    req.query('rateCenter', mapped.rateCenter);
    req.query('lata', mapped.lata);
    req.query('tier', mapped.tier);
    req.query('npa', mapped.npa);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxX', mapped.npaNxxX);
    req.query('city', mapped.city);
    req.query('state', mapped.state);
    req.query('host', mapped.host);
    req.query('orderId', mapped.orderId);
    req.query('lastModifiedDateFrom', mapped.lastModifiedDateFrom);
    req.query('lastModifiedDateTo', mapped.lastModifiedDateTo);
    req.query('protected', mapped.mProtected);
    req.query('status', mapped.status);
    return req.callAsXml(
      'TelephoneNumbersResponse',
      telephoneNumbersHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async createGetTelephoneNumbersDetailsByTelephoneNumbers(
    body?: TelephoneNumbersPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumbersHistoryResponse>> {
    const req = this.createRequest('POST', '/tns');
    req.xml('body', body, 'TnList', optional(telephoneNumbersPayloadSchema));
    return req.callAsXml(
      'TelephoneNumbersResponse',
      telephoneNumbersHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves detailed information about the phone number.TnAttributes - Does this telephone number is
   * protected or not.
   *
   * @param fullnumber
   * @return Response from the API call
   */
  async getTelephoneNumberDetails(
    fullnumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberDetailHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ fullnumber: [fullnumber, string()] });
    req.appendTemplatePath`/tns/${mapped.fullnumber}/tndetails`;
    req.throwOn(400, ApiError, 'Bad Request - failed to get detailed information about the current phone number.');
    return req.callAsXml(
      'TelephoneNumberResponse',
      telephoneNumberDetailHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the telephone number's information.
   *
   * @param fullnumber
   * @return Response from the API call
   */
  async getTelephoneNumber(
    fullnumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberStatusWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ fullnumber: [fullnumber, string()] });
    req.appendTemplatePath`/tns/${mapped.fullnumber}`;
    return req.callAsXml(
      'TelephoneNumberResponse',
      telephoneNumberStatusWrapperSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the rate centers associated with that telephone number.
   *
   * @param fullnumber
   * @return Response from the API call
   */
  async getTelephoneNumberRateCenter(
    fullnumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberDetailHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ fullnumber: [fullnumber, string()] });
    req.appendTemplatePath`/tns/${mapped.fullnumber}/ratecenter`;
    return req.callAsXml(
      'TelephoneNumberResponse',
      telephoneNumberDetailHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the lata associated with that telephone number.
   *
   * @param fullnumber
   * @return Response from the API call
   */
  async getTelephoneNumberLata(
    fullnumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberDetailHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ fullnumber: [fullnumber, string()] });
    req.appendTemplatePath`/tns/${mapped.fullnumber}/lata`;
    return req.callAsXml(
      'TelephoneNumberResponse',
      telephoneNumberDetailHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves information about available NnRoutes for the phone number.
   *
   * @param fullnumber
   * @return Response from the API call
   */
  async getTelephoneNumberAvailableRoutes(
    fullnumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberAvailableNnRoutesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ fullnumber: [fullnumber, string()] });
    req.appendTemplatePath`/tns/${mapped.fullnumber}/availableNnRoutes`;
    req.throwOn(400, ApiError, 'Bad Request - failed to get available NnRoutes information for the current phone number.');
    return req.callAsXml(
      'AvailableNNRoutesResponse',
      telephoneNumberAvailableNnRoutesResponseSchema,
      requestOptions
    );
  }

  /**
   * Returns the total number of in-service numbers for the given account.
   *
   * @param accountId
   * @param tier
   * @param lata
   * @param rateCenter
   * @param areaCode
   * @param npaNxx
   * @param npaNxxx
   * @param state
   * @param city
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getInserviceTelephoneNumbers(
    accountId: number,
    tier?: number,
    lata?: number,
    rateCenter?: string,
    areaCode?: string,
    npaNxx?: string,
    npaNxxx?: string,
    state?: string,
    city?: string,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberTotalsHistory>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      tier: [tier, optional(number())],
      lata: [lata, optional(number())],
      rateCenter: [rateCenter, optional(string())],
      areaCode: [areaCode, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxx: [npaNxxx, optional(string())],
      state: [state, optional(string())],
      city: [city, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('tier', mapped.tier);
    req.query('lata', mapped.lata);
    req.query('rateCenter', mapped.rateCenter);
    req.query('areaCode', mapped.areaCode);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxx', mapped.npaNxxx);
    req.query('state', mapped.state);
    req.query('city', mapped.city);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.appendTemplatePath`/accounts/${mapped.accountId}/inservicenumbers/totals`;
    return req.callAsXml(
      'Quantity',
      telephoneNumberTotalsHistorySchema,
      requestOptions
    );
  }

  /**
   * Retrieves all the telephone numbers currently in service for the given site.<br>There are multiple
   * parameters to search and sort the in-service numbers:<ul>    <li>LATA</li>    <li>Tier</li>
   * <li>Rate center</li>    <li>Area code</li>    <li>Npa-Nxx</li>    <li>State</li>    <li>City</li>
   * <li>Start Date</li>    <li>End date</li></ul>
   *
   * @param accountId
   * @param siteId
   * @param page
   * @param size
   * @param tier
   * @param lata
   * @param rateCenter
   * @param areaCode
   * @param npaNxx
   * @param npaNxxx
   * @param state
   * @param city
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getInserviceTelephoneNumbers1(
    accountId: number,
    siteId: number,
    page?: string,
    size?: number,
    tier?: number,
    lata?: number,
    rateCenter?: string,
    areaCode?: string,
    npaNxx?: string,
    npaNxxx?: string,
    state?: string,
    city?: string,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTelephoneNumbersHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tier: [tier, optional(number())],
      lata: [lata, optional(number())],
      rateCenter: [rateCenter, optional(string())],
      areaCode: [areaCode, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxx: [npaNxxx, optional(string())],
      state: [state, optional(string())],
      city: [city, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tier', mapped.tier);
    req.query('lata', mapped.lata);
    req.query('rateCenter', mapped.rateCenter);
    req.query('areaCode', mapped.areaCode);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxx', mapped.npaNxxx);
    req.query('state', mapped.state);
    req.query('city', mapped.city);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/inservicenumbers`;
    return req.callAsXml(
      'TNs',
      accountTelephoneNumbersHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves a list of in-service phone numbers associated with the account ID. There are multiple
   * search parameters for searching for in-service numbers:<ul>    <li>size and page for pagination</li>
   * <li>area code</li>    <li>Npa-Nxx</li>    <li>LATA</li>    <li>state</li>    <li>rate
   * center</li></ul>
   *
   * @param accountId
   * @param page
   * @param size
   * @param tier
   * @param lata
   * @param rateCenter
   * @param areaCode
   * @param npaNxx
   * @param npaNxxx
   * @param state
   * @param city
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getInserviceTelephoneNumbers2(
    accountId: number,
    page?: string,
    size?: number,
    tier?: number,
    lata?: number,
    rateCenter?: string,
    areaCode?: string,
    npaNxx?: string,
    npaNxxx?: string,
    state?: string,
    city?: string,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTelephoneNumbersHistoryResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tier: [tier, optional(number())],
      lata: [lata, optional(number())],
      rateCenter: [rateCenter, optional(string())],
      areaCode: [areaCode, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxx: [npaNxxx, optional(string())],
      state: [state, optional(string())],
      city: [city, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tier', mapped.tier);
    req.query('lata', mapped.lata);
    req.query('rateCenter', mapped.rateCenter);
    req.query('areaCode', mapped.areaCode);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxx', mapped.npaNxxx);
    req.query('state', mapped.state);
    req.query('city', mapped.city);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.appendTemplatePath`/accounts/${mapped.accountId}/inservicenumbers`;
    req.throwOn(404, ApiError, 'Not Found - The search parameters are invalid and prevent finding any content');
    return req.callAsXml(
      'TNs',
      accountTelephoneNumbersHistoryResponseSchema,
      requestOptions
    );
  }

  /**
   * A GET on the number desired will return a 200 OK if the number is in service on the account, or a
   * 404 not found.
   *
   * @param accountId
   * @param telephoneNumber
   * @return Response from the API call
   */
  async getInserviceTelephoneNumbers3(
    accountId: number,
    telephoneNumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      telephoneNumber: [telephoneNumber, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/inservicenumbers/${mapped.telephoneNumber}`;
    req.throwOn(404, ApiError, 'The telephone number is not currently in service.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves a list of disconnected numbers associated with the account. There are optional search
   * parameters to limit the discNumbers payload
   *
   * @param accountId
   * @param page
   * @param size
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getDisconnectedTelephones(
    accountId: number,
    page?: string,
    size?: number,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountDisconnectedNumbersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.appendTemplatePath`/accounts/${mapped.accountId}/discnumbers`;
    return req.callAsXml(
      'TNs',
      accountDisconnectedNumbersResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves a total number of disconnects.
   *
   * @param accountId
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getDisconnectedTelephoneNumberTotals(
    accountId: number,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberTotalsHistory>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.appendTemplatePath`/accounts/${mapped.accountId}/discnumbers/totals`;
    return req.callAsXml(
      'Quantity',
      telephoneNumberTotalsHistorySchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about one or more Telephone Numbers (TNs) with port out passcode.
   *
   * @param accountId
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param fullnumber
   * @param rateCenter
   * @param lata
   * @param tier
   * @param npa
   * @param npaNxx
   * @param npaNxxX
   * @param city
   * @param state
   * @param host
   * @param orderId
   * @param lastModifiedDateFrom
   * @param lastModifiedDateTo
   * @param mProtected
   * @param status
   * @return Response from the API call
   */
  async getTnsPasscode(
    accountId: number,
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    fullnumber?: string,
    rateCenter?: string,
    lata?: number,
    tier?: number,
    npa?: string,
    npaNxx?: string,
    npaNxxX?: string,
    city?: string,
    state?: string,
    host?: string,
    orderId?: string,
    lastModifiedDateFrom?: string,
    lastModifiedDateTo?: string,
    mProtected?: string,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnPortOutPasscodesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      fullnumber: [fullnumber, optional(string())],
      rateCenter: [rateCenter, optional(string())],
      lata: [lata, optional(number())],
      tier: [tier, optional(number())],
      npa: [npa, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxX: [npaNxxX, optional(string())],
      city: [city, optional(string())],
      state: [state, optional(string())],
      host: [host, optional(string())],
      orderId: [orderId, optional(string())],
      lastModifiedDateFrom: [lastModifiedDateFrom, optional(string())],
      lastModifiedDateTo: [lastModifiedDateTo, optional(string())],
      mProtected: [mProtected, optional(string())],
      status: [status, optional(string())],
    });
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('fullnumber', mapped.fullnumber);
    req.query('rateCenter', mapped.rateCenter);
    req.query('lata', mapped.lata);
    req.query('tier', mapped.tier);
    req.query('npa', mapped.npa);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxX', mapped.npaNxxX);
    req.query('city', mapped.city);
    req.query('state', mapped.state);
    req.query('host', mapped.host);
    req.query('orderId', mapped.orderId);
    req.query('lastModifiedDateFrom', mapped.lastModifiedDateFrom);
    req.query('lastModifiedDateTo', mapped.lastModifiedDateTo);
    req.query('protected', mapped.mProtected);
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnportoutpasscodes`;
    req.throwOn(400, ApiError, 'Bad Request - any syntax error in the parameters will cause a 400 error with a payload similar to the payload in the example, with an error code and text description.');
    return req.callAsXml(
      'TelephoneNumbersResponse',
      tnPortOutPasscodesResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about one or more Telephone Numbers (TNs), where the TNs are specified in POST
   * body.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createGetTnsPortOutPasscodesByTelephoneNumbers(
    accountId: number,
    body?: TelephoneNumbersPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnPortOutPasscodesResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'TnList', optional(telephoneNumbersPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnportoutpasscodes`;
    req.throwOn(400, ApiError, 'Bad Request - when in the POST body specified more then {pagination.maxsize} TNs.');
    return req.callAsXml(
      'TelephoneNumbersResponse',
      tnPortOutPasscodesResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves a list of in-service phone numbers associated with the account ID. There are multiple
   * search parameters for searching for in-service numbers:<ul>    <li>size and page for pagination</li>
   * <li>area code</li>    <li>Npa-Nxx</li>    <li>LATA</li>    <li>state</li>    <li>rate
   * center</li></ul>
   *
   * @param accountId
   * @param type
   * @return Response from the API call
   */
  async getTelephoneNumbersDetailsHistory(
    accountId: number,
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumbersDetailsHistory>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      type: [type, optional(string())],
    });
    req.query('type', mapped.type);
    req.appendTemplatePath`/accounts/${mapped.accountId}/inserviceNumbers`;
    req.throwOn(404, ApiError, 'Not Found - The search parameters are invalid and prevent finding any content');
    return req.callAsXml(
      'TNs',
      telephoneNumbersDetailsHistorySchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getAccountTollFreeTotals(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingPremiseTrunksResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/uctrunks`;
    return req.callAsXml(
      'UcTrunkingPremiseSettingsResponse',
      ucTrunkingPremiseTrunksResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the total count of Toll-Free Telephone Numbers for the given SIP peer.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerTollFreeTotals(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTollFreeTotalsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/tftotals`;
    return req.callAsXml(
      'SipPeerTollFreeTotalsResponse',
      sipPeerTollFreeTotalsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the total number of seats.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getProductTnHistory1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteTnTotalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/totalSeats`;
    req.throwOn(400, ApiError, 'The account ID given does not have UC Trunking associated with it.');
    return req.callAsXml(
      'SiteTNsResponse',
      siteTnTotalResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getProductTnHistory2(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteTnTotalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/totalSeats`;
    return req.callAsXml(
      'SiteTNsResponse',
      siteTnTotalResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the total number of seats.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getProductTnHistory3(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteTnTotalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/totalSeats`;
    req.throwOn(400, ApiError, 'The account ID given does not have UC Trunking associated with it.');
    return req.callAsXml(
      'SiteTNsResponse',
      siteTnTotalResponseSchema,
      requestOptions
    );
  }

  /**
   * Request portability information on a set of TNs
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createCheckImportTnAvailability(
    accountId: number,
    body?: ImportTnCheckerPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'ImportTnCheckerPayload',
      optional(importTnCheckerPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/importTnChecker`;
    req.throwOn(400, ApiError, 'Bad Response - there were errors in evaluating the body of the requestPotential errors include:<ul>  <li> List of TNs is empty.  <li> List of TNs is more than 5000 TNs.  <li> The account does not have the necessary (IMPORT_TNS) flag.  <li> TNs are invalid (they are not actual TNs, and there are duplicates).</ul>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Gets a single Import To Account order by its ID
   *
   * @param accountId
   * @param orderid
   * @param tndetail  Example: false
   * @return Response from the API call
   */
  async getAllTNsForImportOrder(
    accountId: number,
    orderid: string,
    tndetail?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ImportToAccountNumberOrderResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
      tndetail: [tndetail, optional(boolean())],
    });
    req.query('tndetail', mapped.tndetail);
    req.appendTemplatePath`/accounts/${mapped.accountId}/importToAccount/${mapped.orderid}`;
    return req.callAsXml(
      'ImportToAccountNumberOrderResponse',
      importToAccountNumberOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * Gets all telephone numbers associated with a Port In order
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getTNsByOrderId1(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberListWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}/tns`;
    return req.callAsXml(
      'TelephoneNumbers',
      telephoneNumberListWrapperSchema,
      requestOptions
    );
  }

  /**
   * Gets the quantity of telephone numbers in a single Port In order
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getCountTNsByOrderId1(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LongXMLWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}/totals`;
    return req.callAsXml('Quantity', longXMLWrapperSchema, requestOptions);
  }

  /**
   * Gets a list of Port In orders which match the included criteria
   *
   * @param accountId
   * @param customerOrderId
   * @param pon
   * @param startdate
   * @param enddate
   * @param status
   * @param date
   * @param tn
   * @param page
   * @param size
   * @param bulkportinorderid
   * @return Response from the API call
   */
  async getPortins(
    accountId: number,
    customerOrderId?: string,
    pon?: string,
    startdate?: string,
    enddate?: string,
    status?: string,
    date?: string,
    tn?: string,
    page?: string,
    size?: number,
    bulkportinorderid?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpResponseListWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      customerOrderId: [customerOrderId, optional(string())],
      pon: [pon, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
      status: [status, optional(string())],
      date: [date, optional(string())],
      tn: [tn, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      bulkportinorderid: [bulkportinorderid, optional(string())],
    });
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('pon', mapped.pon);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.query('status', mapped.status);
    req.query('date', mapped.date);
    req.query('tn', mapped.tn);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('bulkportinorderid', mapped.bulkportinorderid);
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins`;
    return req.callAsXml(
      'LNPResponseWrapper',
      lnpResponseListWrapperSchema,
      requestOptions
    );
  }

  /**
   * Creates a port-in request for the accountId, SiteId, and PeerId. If PeerId is omitted, the default
   * PeerId (Location) for the Site (Sub-Account) will be used.  Once the payload is successfully
   * submitted, the order will temporarily have a status of  "PENDING_DOCUMENTS", then "SUBMITTED".
   * <br><br>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createLnpOrder(
    accountId: number,
    body?: LnpOrder,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpOrderResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'LnpOrder', optional(lnpOrderSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins`;
    req.throwOn(400, ApiError, 'The order failed; one of the input parameters is invalid.');
    return req.callAsXml(
      'LnpOrderResponse',
      lnpOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * Gets detailed information about a single Port In order
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getLnpObjectById(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpOrderResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}`;
    return req.callAsXml(
      'LnpOrderResponse',
      lnpOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * It is possible to change ("SUPP" in LNP terms) an existing LNP order.  This is done via a PUT on the
   * existing order-id.Since many of the entries in an LNP Order cannot be changed after the initial
   * order is placed the PUT on a porting order-id does *not* require that the full order payload is
   * included.<br/>If SUPP is done to <strong>draft</strong> portin no validations will be applied except
   * validation of tn list if at least 1 tn is provided.Items that can be included in a SUPP request
   * include:
   * <ul><li>CustomerOrderId</li><li>RequestedFocDate</li><li>BillingTelephoneNumber</li><li>NewBillingTe
   * lephoneNumber</li><li>AccountNumber</li><li>PinNumber</li><li>TnAttributes
   * elements</li><li>Subscriber elements, including the subscriber type, the name elements, and the
   * street address elements.  See the discussion below on
   * ResetAddressFields</li><li>SiteId</li><li>PeerId</li><li>PartialPort,
   * and</li><li>LoaAuthorizingPerson</li><li>ListOfPhoneNumbers</li><li>Triggered</li><li>Immediately</l
   * i></ul>Note: If the order ProcessingStatus is DRAFT, the rules about what can be changed are much
   * more relaxed. Validation is performed when the ProcessingStatus is changed from DRAFT to SUBMITTED.
   * <p>The AltSpid element can be modified if it is not configured at the system level.<p>List of phone
   * numbers can be modified only for Automated on-net port type.<p><b>ProcessingStatus</b> - you can
   * only provide this field with a value of SUBMITTED and only if the current ProcessingStatus of the
   * port-in is DRAFT.<p><b>ResetAddressFields -</b> As stated above the general approach to handling
   * <i>this</i> API call is to replace the elements included in the request body, and leave other
   * preexisting elements in an unmodified condition.  This is typical of a PATCH method, but because of
   * our commitment to backwards compatibility we have elected not to "Fix" this behavior.As a result,
   * providing only a few fields in the street address will result in an update to just those fields.
   * This prevents removal of an element of the address.  The ResetAddressFields element is provided to
   * resolve this issue.  The default setting of 'false' is to consistency with the initial
   * implementation.The recommendation is to replace the entire street address.  This ensures that you
   * are enforcing the street address content of the port-in order.  As part of this recommendation the
   * ResetAddressFields element should be set to true, which will force the street address to be exactly
   * what you specified in the payload.<br> <br> When a port-in is being processed by off-net partner
   * Level 3 (you can tell this because /lnpchecker indicates a Port Type of AUTOMATEDOFFNET), the rules
   * for what can be changed in a SUPP operation are more restrictive. If the order has NOT yet received
   * FOC, you may change the following:<ul>  <li>RequestedFocDate</li>  <li>BillingTelephoneNumber</li>
   * <li>SubscriberType</li>  <li>Subscriber name elements or BusinessName, provided that SubscriberType
   * is provided</li></ul>After FOC has been received, only RequestedFocDate may be changed.
   *
   * @param accountId
   * @param orderid
   * @param localOrderUpdate Example: false
   * @param body
   * @return Response from the API call
   */
  async updateSuppLnpOrder(
    accountId: number,
    orderid: string,
    localOrderUpdate?: boolean,
    body?: LnpOrderSupp,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpOrderResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
      localOrderUpdate: [localOrderUpdate, optional(boolean())],
    });
    req.query('LocalOrderUpdate', mapped.localOrderUpdate);
    req.xml('body', body, 'LnpOrderSupp', optional(lnpOrderSuppSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'List of telephone numbers cannot be changed due to validation errors.');
    return req.callAsXml(
      'LnpOrderResponse',
      lnpOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * If portin is in DRAFT state the order will be deleted. Otherwise the call simply places the existing
   * order in a cancelled state.Note that only a pending port-in order can be cancelled; if the order was
   * previously cancelled or completed, then a DELETE will not be possible.
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async deleteCancelLnpOrder(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Order id is invalid, order does not exist or the port-in order is already processed, and therefore cannot be deleted.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Gets the number of Port In orders with the specified vendor and status
   *
   * @param accountId
   * @param vendor
   * @param status
   * @return Response from the API call
   */
  async getPortCountPerVendor(
    accountId: number,
    vendor?: string,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LongXMLWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      vendor: [vendor, optional(string())],
      status: [status, optional(string())],
    });
    req.query('vendor', mapped.vendor);
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/totals`;
    return req.callAsXml('Quantity', longXMLWrapperSchema, requestOptions);
  }

  /**
   * Gets Port In orders which were last modified in the specified date range
   *
   * @param accountId
   * @param startdate
   * @param enddate
   * @param page
   * @param size
   * @return Response from the API call
   */
  async getAllPortsByAccountIdAndRange(
    accountId: number,
    startdate?: string,
    enddate?: string,
    page?: string,
    size?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpResponseListWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
    });
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/status`;
    return req.callAsXml(
      'LNPResponseWrapper',
      lnpResponseListWrapperSchema,
      requestOptions
    );
  }

  /**
   * Gets history of changes to a Port In order
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getHistoryByOrderId(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OrderHistoryWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderid}/history`;
    return req.callAsXml(
      'OrderHistoryWrapper',
      orderHistoryWrapperSchema,
      requestOptions
    );
  }

  /**
   * Gets a list of Port In orders for the specified site (sub-account)
   *
   * @param accountId
   * @param siteId    Example: 0
   * @param status
   * @param page
   * @param size
   * @return Response from the API call
   */
  async getSitePortInOrders(
    accountId: number,
    siteId: number,
    status?: string,
    page?: string,
    size?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpResponseListWrapper>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      status: [status, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
    });
    req.query('status', mapped.status);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/portins`;
    return req.callAsXml(
      'LNPResponseWrapper',
      lnpResponseListWrapperSchema,
      requestOptions
    );
  }

  /**
   * Request portability information on a set of TNs
   *
   * @param accountId
   * @param fullCheck
   * @param body
   * @return Response from the API call
   */
  async createCheckLnpAvailability(
    accountId: number,
    fullCheck?: string,
    body?: NumberPortabilityRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NumberPortabilityResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      fullCheck: [fullCheck, optional(string())],
    });
    req.query('fullCheck', mapped.fullCheck);
    req.xml(
      'body',
      body,
      'NumberPortabilityRequest',
      optional(numberPortabilityRequestSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/lnpchecker`;
    req.throwOn(400, ApiError, 'Bad Response - there were errors in evaluating the body of the requestPotential errors include: <ul><li> Telephone number is already being processed on another order.<li> Rate Center Not Present in Bandwidth Dashboard API.<li> Account not enabled for LNP </ul> ');
    return req.callAsXml(
      'NumberPortabilityResponse',
      numberPortabilityResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param telephonenumber
   * @return Response from the API call
   */
  async getCheckLnpAvailability1(
    accountId: number,
    telephonenumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LnpAvailabilityCheckResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      telephonenumber: [telephonenumber, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/availabilityCheck/${mapped.telephonenumber}`;
    return req.callAsXml(
      'LnpAvailabilityCheckResponse',
      lnpAvailabilityCheckResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates or cancels a port-out ID. THe payload to this method is similar to the GET on
   * /accounts/{accountid}/portouts.<br>In the payload, CallbackUrl and InternalPort are optional
   * additives.<br>There are also multiple options for the following:<table>    <tr>
   * <th>Option</th>        <th>Choices</th>    </tr>    <tr>
   * <td>Supplemental</td><td>NONE<br>CANCEL<br>UPDATE<br>OTHER<br></td>    </tr>    <tr>
   * <td>PortOutAction</td><td>NEW<br>SUPP<br>MODIFY<br>CANCEL<br></td>    </tr></table>
   *
   * @param accountId
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async updatePortOut(
    accountId: number,
    orderId: string,
    body?: ManualPortOutRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ManualPortOutResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.xml(
      'body',
      body,
      'PortOutRequest',
      optional(manualPortOutRequestSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/portouts/${mapped.orderId}`;
    return req.callAsXml(
      'PortOutResponse',
      manualPortOutResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateSuppPortOut(
    accountId: number,
    body?: ManualPortOutRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ManualPortOutResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'PortOutRequest',
      optional(manualPortOutRequestSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/portouts`;
    return req.callAsXml(
      'PortOutResponse',
      manualPortOutResponseSchema,
      requestOptions
    );
  }

  /**
   * Creates a port-out request.<br>In the payload, CallbackUrl and InternalPort are optional.<br>There
   * are also multiple options for the following:<table>    <tr>        <th>Option</th>
   * <th>Choices</th>    </tr>    <tr>
   * <td>Supplemental</td><td>NONE<br>CANCEL<br>UPDATE<br>OTHER<br></td>    </tr>    <tr>
   * <td>PortOutAction</td><td>NEW<br>SUPP<br>MODIFY<br>CANCEL<br></td>    </tr>    <tr>
   * <td>InternalPort</td><td>true or false<br></td>    </tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createPortOut(
    accountId: number,
    body?: ManualPortOutRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ManualPortOutResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'PortOutRequest',
      optional(manualPortOutRequestSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/portouts`;
    return req.callAsXml(
      'PortOutResponse',
      manualPortOutResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async deleteCancelPortOut(
    accountId: number,
    body?: ManualPortOutRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ManualPortOutResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'PortOutRequest',
      optional(manualPortOutRequestSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/portouts`;
    return req.callAsXml(
      'PortOutResponse',
      manualPortOutResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the history of the specified bulk port-in order. Obtaining history for a draft bulk port-
   * in is not supported.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getPortInOrderHistory1(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the Bulk Port-in requests for the given account ID. <p>A maximum of 1,000 orders can be
   * retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param page
   * @param size
   * @param status
   * @param orderDate
   * @param orderDetails     Example: false
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @return Response from the API call
   */
  async getBulkPortins(
    accountId: number,
    page?: string,
    size?: number,
    status?: string,
    orderDate?: string,
    orderDetails?: boolean,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      status: [status, optional(string())],
      orderDate: [orderDate, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('status', mapped.status);
    req.query('orderDate', mapped.orderDate);
    req.query('orderDetails', mapped.orderDetails);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Creates a Bulk Port-in request to be used as a template for a collections of individual port-in
   * orders. This will be applied to port-ins that result from decomposing a collection of Telephone
   * Numbers that span carriers, or have attributes that drive the decomposition into a number of
   * individual port-in orders.<p>Upon a successfully-submitted payload, the order will have a status of
   * "DRAFT", denoting that further modification to the template is expected.<p>Releated sub-resources
   * are used to decompose the collection of Telephone Numbers into individual port-in orders.<p>The only
   * valid value for the <ProcessingStatus> element in a POST is 'DRAFT', which is the default value.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createBulkPortinsOrder(
    accountId: number,
    body?: BulkPortin,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'BulkPortin', optional(bulkPortinSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/`;
    req.throwOn(400, ApiError, 'Order could not be processed and no order ID was created.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the information associated with the specified port-in ID number.
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getById(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}`;
    req.throwOn(404, ApiError, 'The indicated Bulk Port-in order could not be found.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * It is possible to change ("SUPP" in LNP terms) an existing Bulk Port-in order.  This is done via a
   * PUT or PATCH on the existing order-id.Since the Bulk Portin order resource acts as a template for
   * portin orders in DRAFT status, any record can be changed at any time.The PUT will completely replace
   * the existing Bulk Portin order with the payload of the PUT.The only valid value for the
   * <ProcessingStatus> element in a PUT is 'DRAFT' where 'DRAFT' is the default value.If the portin
   * orders contained within the Bulk Port are in DRAFT state, any field can be modified.  If any portin
   * order in the Bulk Port is in any other state, normal SUPP rules apply, and the list of appropriate
   * fields is smaller.
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async updateBulkPortinsOrder(
    accountId: number,
    orderid: string,
    body?: BulkPortin,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'BulkPortin', optional(bulkPortinSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Bad request. Invalid input.');
    req.throwOn(404, ApiError, 'The indicated Bulk Port-in order could not be found.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete Bulk Port-in order with subdending port-ins. Deleting a bulk port-in allowed for 'DRAFT'
   * state only.Deleting a bulk port-in will delete all DRAFT port-ins associated with it.If a bulk port-
   * in contains a CANCELLED port-in (due to port decomposition finding non-portable TNs),that port-in
   * will be disassociated with the bulk port-in, but not deleted.
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async deleteBulkPortinsOrder(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Bad request. Bulk Port-in order not in DRAFT state.');
    req.throwOn(404, ApiError, 'The indicated Bulk Port-in order could not be found.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * It is possible to change ("SUPP" in LNP terms) an existing Bulk Port-in order.  This is done via a
   * PUT or PATCH on the existing order-id.Since the Bulk Portin order resource acts as a template for
   * portin orders in DRAFT status, any record can be changed at any time.The PATCH will replace elements
   * of the referenced Bulk Portin order, but it will replace *only* the records included in the request
   * payload.  Other elements will remain untouched.User may include delete attribute to whatever element
   * which causes deletion of that element.For example: <CustomerOrderId delete="true"/> will cause
   * CustomerOrderId to be removed.The only valid values for the <ProcessingStatus> element in a PUT or
   * PATCH are 'DRAFT' or 'IN&lowbar;PROGRESS' where 'DRAFT' is the default value.<b>Changing the &lt;
   * ProcessingStatus&gt; to 'IN&lowbar;PROGRESS' will force all subtending portins to to begin
   * processing</b>. This is only valid if there are subtending portins.Changing the fields in a Bulk
   * Portin order will cause the system to reapply all changed values to the ports contained in the list
   * of subtending portin orders.Note that if the portin orders contained within the Bulk Port are in
   * DRAFT state, any field can be modified.  If any portin order in the Bulk Port is in any other state,
   * normal SUPP rules apply, and the list of appropriate fields is smaller.
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async patchBulkPortinsOrder(
    accountId: number,
    orderid: string,
    body?: BulkPortinPatch,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PATCH');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'BulkPortin', optional(bulkPortinPatchSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Bad request. Invalid input.');
    req.throwOn(404, ApiError, 'The indicated Bulk Port-in order could not be found.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves a list of Port-in Orders that are all associated with the identified Bulk Port-in.   This
   * response is not paginated due to its inherently limited size
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getPortinList(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}/portinlist`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * A PUT on a PortinList resource will cause replacement of the list of Port-in orders associated with
   * a Bulk Port-in.    This PUT will *completely replace* the existing list of port-in orders associated
   * with the Bulk Port-in.  If all port-in orders in the list are not valid the PUT request will fail,
   * due to the potential for losing the port-in to Bulk Port-in relationships for a range of port-in
   * orders.
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async updatePortinList(
    accountId: number,
    orderid: string,
    body?: BulkPortinList,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'PortinList', optional(bulkPortinListSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}/portinlist`;
    req.throwOn(400, ApiError, 'There was an error - one or more of the port-in orders was invalid.  The response payload will indicate the errors that were detected, and no changes will be made to the list of portin orders associated with the bulk order.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves a list of all telephone numbers associated with a Bulk Portin.   This response is not
   * paginated due to its inherently limited size
   *
   * @param accountId
   * @param orderid
   * @return Response from the API call
   */
  async getBulkTnList(
    accountId: number,
    orderid: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}/tnlist`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * A PUT on a TnList resource causes the decomposition of that list of TNs into individual port-in
   * orders that comply with the rules for atomic ports.  The result is the creation of a set of port-in
   * orders, with TNs associated with each order.  The response payload indicates the TNs that were
   * successfully decomposed, and the TNs that could not be ported. The response payload contains three
   * optional elements:<ul><li>the 'ValidTnList' - a collection of telephone numbers that can be
   * ported</li><li>the 'NonPortableTnList' - a collection of telephone numbers that cannot be ported,
   * and </li><li>the 'InvalidTnList' - a collection of any strings that were submitted as telephone
   * numbers, but that are not syntactically valid</li></ul>
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async updatePopulateBulkOrder(
    accountId: number,
    orderid: string,
    body?: BulkTnList,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'TnList', optional(bulkTnListSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/bulkportins/${mapped.orderid}/tnlist`;
    req.throwOn(400, ApiError, 'The TN List payload was malformed, and the list could not be processed.  No response payload is returned.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the information associated with the specified port-in ID number. Note: For users of
   * Enterprise Telephony accounts, AlternateSpid, LosingCarrierSPID, LosingCarrierName, and
   * LosingCarrierIsWireless, are omitted from the success output.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getUpdateTnActivationStatus(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PortinLosingCarrierResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderId}`;
    return req.callAsXml(
      'PortinLosingCarrierResponse',
      portinLosingCarrierResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates the information associated with the specified LSR.  This is also used to cancel an order, by
   * changing the order status field to cancelled.  This is the only case where the status can be changed,
   * and when this is done, all other fields are left as they were prior to the cancellation.  Please
   * see the example below.
   *
   * @param accountId
   * @param orderid
   * @param body
   * @return Response from the API call
   */
  async updateLsrOrder(
    accountId: number,
    orderid: string,
    body?: LsrOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LsrOrderResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
    });
    req.xml('body', body, 'LsrOrder', optional(lsrOrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/lsrorders/${mapped.orderid}`;
    req.throwOn(400, ApiError, 'Validation error occurred.');
    req.throwOn(404, ApiError, 'Requested lsr not found.');
    return req.callAsXml(
      'LsrOrderResponse',
      lsrOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve the status (activated or not activated) of TNs associated with the customer activated
   * (triggered) order. <br><br>At this time all phone numbers associated with a PON will be activated at
   * the same time.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async retrieveTnActivationStatus(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnActivationStatusResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderId}/activationStatus`;
    req.throwOn(400, ApiError, 'Return a 400 error if the port-in Order is not in FOC status, or if not executed on the day of FOC or within the delay interval.');
    req.throwOn(404, ApiError, 'Return a 404 if the Port-in Order is missing, or if the activation is complete, and thus the ActivationStatus resource has been erased.');
    return req.callAsXml(
      'ActivationStatusResponse',
      tnActivationStatusResponseSchema,
      requestOptions
    );
  }

  /**
   * Sets the activation time for the port-in order.  <br> <br>This API call is used to set the
   * Activation time of the customer activated (triggered) port.<ul><li>If the time is in the past all of
   * the TNs in the port-in request will be activated 'immediately'.</li><li>For automated on-net port-
   * ins, if the time is within three days after the approved FoC date, the auto-activation time for the
   * port will be set to that time.</li><li>For automated off-net port-ins, if the date matches the
   * actual FOC date and the time is between 6:00 AM ET and 10:00 PM ET, the auto-activation time for the
   * port will be set to that time.</li></ul>
   *
   * @param accountId
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async updateTnActivationStatus1(
    accountId: number,
    orderId: string,
    body?: TnActivationStatus,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnActivationStatusResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.xml(
      'body',
      body,
      'ActivationStatus',
      optional(tnActivationStatusSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/portins/${mapped.orderId}/activationStatus`;
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(404, ApiError, 'Not Found');
    return req.callAsXml(
      'ActivationStatusResponse',
      tnActivationStatusResponseSchema,
      requestOptions
    );
  }

  async updateFileDirect(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
      body: [body, optional(unknown())],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/loas/${mapped.fileName}`;
    req.throwOn(400, ApiError, 'A 400 indicates that the requested upload failed.');
    req.throwOn(404, ApiError, 'A 404 indicates that the file was not available for replacement.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Deletes the file associated with the order
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param fileName
   * @return Response from the API call
   */
  async deleteFile(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/loas/${mapped.fileName}`;
    req.throwOn(404, ApiError, 'a 404 indicates that the indicated file was not found in conjunction with the order id.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * POSTing to the /loas resource will enable the upload of the file.  The key attribute to the POST is
   * ensuring that the headers are correctly set to support the file upload.<br>    <br>Header settings
   * typical of a valid upload are...<br>    <br><code>Host: api.inetwork.com <br>Authorization: Basic
   * xxxxxxxxxxxxxxxxxxxx== <br>Content-Type: application/pdf <br>Accept:  <br>Accept-Encoding: gzip,
   * deflate <br>Accept-Language: en-US,en;q=0.8 <br>Cache-Control: no-cache <br>    <br>----
   * WebKitFormBoundaryE19zNvXGzXaLvS5C <br>Content-Disposition: form-data; name="george";
   * filename="Bandwidth Dashboard.pdf" <br>Content-Type: application/pdf <br>    <br>    <br>----
   * WebKitFormBoundaryE19zNvXGzXaLvS5C <br></code>
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async uploadFileDirect(
    accountId: number,
    orderType: string,
    orderId: string,
    body?: FileWrapper,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.formData({
      body: body,
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/loas`;
    req.throwOn(400, ApiError, 'A 400 indicates that the requested upload failed.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param fileName
   * @return Response from the API call
   */
  async getFileMetaData(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FileMetaDataPayload>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
    });
    req.appendTemplatePath`/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/${mapped.fileName}`;
    return req.callAsXml(
      'FileMetaData',
      fileMetaDataPayloadSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param fileName
   * @param body
   * @return Response from the API call
   */
  async updateFileMetaData(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    body?: FileMetaDataPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FileMetaDataPayload>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
    });
    req.xml('body', body, 'FileMetaData', optional(fileMetaDataPayloadSchema));
    req.appendTemplatePath`/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/${mapped.fileName}`;
    return req.callAsXml(
      'FileMetaData',
      fileMetaDataPayloadSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param fileName
   * @return Response from the API call
   */
  async removeFileMetaData(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FileMetaDataPayload>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
    });
    req.appendTemplatePath`/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/${mapped.fileName}`;
    return req.callAsXml(
      'FileMetaData',
      fileMetaDataPayloadSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve all subscriptions for the account (including email and callback
   * subscriptions).The returned information reflects the subscription as it has been defined, and for
   * callback subscriptions will reflect the status of the latest attempt to place the callback.  The
   * <Status> element will indicate if an error is being encountered when the Bandwidth Dashboard API
   * attempts to place the callback.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param eventType
   * @return Response from the API call
   */
  async getSubscriptions(
    accountId: number,
    orderType?: string,
    orderId?: string,
    eventType?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, optional(string())],
      orderId: [orderId, optional(string())],
      eventType: [eventType, optional(string())],
    });
    req.query('orderType', mapped.orderType);
    req.query('orderId', mapped.orderId);
    req.query('eventType', mapped.eventType);
    req.appendTemplatePath`/accounts/${mapped.accountId}/subscriptions`;
    req.throwOn(400, ApiError, 'if the account specified does not exist or is locked it will result in a bad request');
    return req.callAsXml('SubscriptionsResponse', unknown(), requestOptions);
  }

  /**
   * A POST on the /subscriptions resource is used to request a new subscription for an account.<br>The
   * POST creates a new e-mail or callback subscription. A well-formed POST will create a subscription
   * resource, and return asubscription ID as part of the location header. The ID is used to uniquely
   * identify the subscription.The user should submit the desired e-mail address for notifications and
   * the frequency with which he wants to get the updates:DAILY (for daily digests) or NONE (immediately
   * after events). OrderId is optional. If OrderId is specified only notifications willbe sent for
   * events related to that order. If OrderId is omitted, notifications will be sent related to events of
   * all orders of the specified type.<br>For email subscriptions on order status notification use a body
   * like this:<br>```<Subscription>    <OrderType> [ portins | portouts | orders | disconnects | dldas |
   * lsrorders | e911s | tnoptions | externalTns | lidb | bulkPortins| importtnorders |
   * removeImportedTnOrders | emergencyNotificationGroup | emergencyEndpointGroup] </OrderType> <!--
   * required -->    <OrderId> [ UUID ] </OrderId> <!-- optional, if provided notifications will only be
   * sent for events regarding this specific order, if omitted notifications regarding events for all
   * orders of the specified type will be sent -->    <EmailSubscription>        <Email> [ email address]
   * </Email>        <DigestRequested> [ NONE | DAILY ] </DigestRequested> <!-- required -->
   * </EmailSubscription></Subscription>```For email subscriptions on event notification use a body like
   * this:<br>```<Subscription>    <EventType> [ MESSAGING_LOST ] </EventType> <!-- required -->
   * <EmailSubscription>        <Email> [ email address] </Email>        <DigestRequested> [ NONE | DAILY
   * ] </DigestRequested> <!-- required -->    </EmailSubscription></Subscription>```For callback
   * subscriptions on order status notification use a body like this:<br>```<Subscription>    <OrderType>
   * [portins | portouts | orders | disconnects | dldas | lsrorders | e911s | tnoptions | externalTns |
   * lidb | importtnorders | removeImportedTnOrders| emergencyNotificationGroup | emergencyEndpointGroup]
   * </OrderType> <!-- same rules and values as above -->    <OrderId> [UUID]</OrderId> <!-- same rules
   * and value as above -->    <CallbackSubscription>        <URL> [valid publically addressable URL]
   * </URL> <!-- the URL that notifications should get POSTed to, HTTPS is highly recommended -->
   * <Expiry> [time in seconds] </Expiry> <!-- the number of seconds after which to expire this
   * subscription -->        <CallbackCredentials> <!-- optional, but recommended; these credentials will
   * be used to when authenticating with the notification receiving server -->
   * <BasicAuthentication> <!-- optional, the endpoint may be secured with BASIC auth -->
   * <Username> [username] </Username> <!-- max 100 characters -->                <Password> [password]
   * </Password> <!-- the password will be stored encrypted and never returned via the API -->
   * </BasicAuthentication>            <!-- optional, a BASE64 encoded public key matching the
   * notification receiving server -->            <PublicKey>LS0tLS1CRUdJTiBDRVJUSUZJ [...]
   * kQgQ0VSVElGSUNBVEUtLS0tLQ0K</PublicKey>        </CallbackCredentials>
   * </CallbackSubscription></Subscription>```For callback subscriptions on event notification use a body
   * like this:<br>```<Subscription>    <EventType> [ MESSAGING_LOST ] </EventType> <!-- required -->
   * <CallbackSubscription>        <URL> [valid publically addressable URL] </URL> <!-- the URL that
   * notifications should get POSTed to, HTTPS is highly recommended -->        <Expiry> [time in
   * seconds] </Expiry> <!-- the number of seconds after which to expire this subscription -->
   * <CallbackCredentials> <!-- optional, but recommended; these credentials will be used to when
   * authenticating with the notification receiving server -->            <BasicAuthentication> <!--
   * optional, the endpoint may be secured with BASIC auth -->                <Username> [username]
   * </Username> <!-- max 100 characters -->                <Password> [password] </Password> <!-- the
   * password will be stored encrypted and never returned via the API -->
   * </BasicAuthentication>            <!-- optional, a BASE64 encoded public key matching the
   * notification receiving server -->            <PublicKey>LS0tLS1CRUdJTiBDRVJUSUZJ [...]
   * kQgQ0VSVElGSUNBVEUtLS0tLQ0K</PublicKey>        </CallbackCredentials>
   * </CallbackSubscription></Subscription>```The credentials used to impose security on the callbacks
   * are defined in the <CallbackCredentials> element.  The Basic authentication is straightforward, but
   * the <PublicKey> requires a little more explanation.  Please see the document to the left on Mutual
   * Authentication for CallBacks.<p>When status changes on an order that had been subscribed to with a
   * callback subscription (order update, note added to order), the following payloadwill be POSTed to
   * the URL of the callback subscription.<br>More detail can be found in the API documentation for the
   * fictitious endpoint /callbacks```xml<Notification>    <SubscriptionId>...</SubscriptionId>
   * <OrderType>portins | portouts | orders | disconnects | dldas | lsrorders | e911s| tnoptions |
   * externalTns | lidb | importtnorders | removeImportedTnOrders </OrderType>    <OrderId>...</OrderId>
   * <!-- for order update events -->    <Status>COMPLETE | FAILED | PARTIAL | EXCEPTION ... </Status>
   * <!-- for order update events -->    <Message>...</Message>    <!-- for note events -->    <Note>...
   * </Note>    <!-- for portins/portouts/orders/disconnects OrderTypes -->
   * <CompletedTelephoneNumbers>        <TelephoneNumber> ... </TelephoneNumber>        <!-- ... -->
   * </CompletedTelephoneNumbers></Notification>```When a event happens that had been subscribed to with
   * a callback subscription (messaging lost, messaging gained etc.), the following payloadwill be POSTed
   * to the URL of the callback subscription.<br>More detail can be found in the API documentation for
   * the fictitious endpoint /callbacks```xml<Notification>    <SubscriptionId>...</SubscriptionId>
   * <EventType>MESSAGING_LOST</EventType>    <CompletedTelephoneNumbers>
   * <TelephoneNumber>9192345678</TelephoneNumber>        <TelephoneNumber>9192345679</TelephoneNumber>
   * </CompletedTelephoneNumbers></Notification>```
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createSubscription(
    accountId: number,
    body?: Subscription,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SubscriptionResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Subscription', optional(subscriptionSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/subscriptions`;
    req.throwOn(400, ApiError, 'if the account specified does not exist or is locked it will result in a bad request');
    req.throwOn(404, ApiError, 'if the subscription validation failed (e.g. invalid URL, invalid expiration date, invalid public key)');
    req.throwOn(409, ApiError, 'if the subscription for this subscription target already exits it will result in a CONFLICT response');
    return req.callAsXml(
      'SubscriptionResponse',
      subscriptionResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the information associated with the subscription ID.The returned information reflects the
   * subscription as it has been defined, and for callback subscriptions will reflect the status of the
   * latest attempt to place the callback.  The <status> element will indicate if an error is being
   * encountered when the Bandwidth Dashboard API attempts to place the callback.
   *
   * @param accountId
   * @param subscriptionId
   * @return Response from the API call
   */
  async getSubscription(
    accountId: number,
    subscriptionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      subscriptionId: [subscriptionId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/subscriptions/${mapped.subscriptionId}`;
    return req.callAsXml('SubscriptionsResponse', unknown(), requestOptions);
  }

  /**
   * Updates the subscription. This can be be used to update various values (expiry, email address, url,
   * credentials...).Note that the initial state changes for an order may happen very quickly, so
   * subscribing to anorder once the system creates it needs to account for the fact that the initial
   * state may bedifferent based on timing factors. It is recommended that the application creating
   * thesubscription check the order status after the subscription is created to ensure the correct
   * initialcondition. <br>The same rules around valid or possible values as for POSTs apply.
   *
   * @param accountId
   * @param subscriptionId
   * @param body
   * @return Response from the API call
   */
  async updateSubscription(
    accountId: number,
    subscriptionId: string,
    body?: Subscription,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SubscriptionResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      subscriptionId: [subscriptionId, string()],
    });
    req.xml('body', body, 'Subscription', optional(subscriptionSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/subscriptions/${mapped.subscriptionId}`;
    req.throwOn(400, ApiError, 'Subscription values failed validation');
    req.throwOn(404, ApiError, 'Subscription does not exist');
    return req.callAsXml(
      'SubscriptionResponse',
      subscriptionResponseSchema,
      requestOptions
    );
  }

  /**
   * Deletes the specified subscription. Note that deleting subscriptions is only supported on a one-by-
   * one basis.Deleting all subscriptions associated with an order requires GETting all of those
   * subscriptions, then deleting them one by one.
   *
   * @param accountId
   * @param subscriptionId
   * @return Response from the API call
   */
  async deleteSubscription(
    accountId: number,
    subscriptionId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SubscriptionResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      subscriptionId: [subscriptionId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/subscriptions/${mapped.subscriptionId}`;
    req.throwOn(404, ApiError, 'subscription does not exist');
    return req.callAsXml(
      'SubscriptionResponse',
      subscriptionResponseSchema,
      requestOptions
    );
  }

  /**
   * Import a large number of previously ported or otherwise acquired numbers into the accountThe various
   * parameters in the importToAccount payload are...        <table style="text-align: left; width: 80%;"
   * border="1" cellpadding="2" cellspacing="2">          <thead>            <tr>
   * <th>Parameter</th><th>Description</th>            </tr>          </thead>          <tbody>
   * <tr>              <td>accountid</td>              <td>The numerical Account ID assigned to the
   * Account.</td>            </tr>            <tr>              <td>SiteId</td>              <td>The ID
   * of the Site that the set of TNs is to be associated with. </td>            </tr>            <tr>
   * <td>PeerId</td>              <td>The ID of the SIP Peer that the set of TNs is to be
   * associated with. (optional) </td>            </tr>            <tr>              <td>BatchId</td>
   * <td>A user-chosen id for the batch of phone numbers.  This Batch ID can span multiple
   * number submissions.  Up to 10 alphanumeric characters.  If  the submission is not intended to be
   * grouped into a batch of submissions then the Batch ID must be globally unique.  <b>It is recommended
   * that the batch ids be globally unique, and that imports not be grouped together in batches by use of
   * a common batch id.</b></td>            </tr>            <tr>              <td>BatchSize</td>
   * <td>The number of TNs in the batch, aggregated across all of the orders in the batch. This
   * total spans API Calls, so if 3 calls are necessary to import 15000 numbers, this value would be
   * 15000.  It is recommended to use a batch size equal to the number of telephone numbers in the API
   * call, and use a different batch name for each API call - essentially limiting a batch to a single
   * API call.</td>            </tr>            <tr>              <td>VendorName</td>
   * <td>The vendor that owns the number that is being ported in.  If the number is manually ported to a
   * partners network then this would reflect that partner</td>            </tr>            <tr>
   * <td>BillingType</td>                <td>Type of billing rules to be applied. Possible values..
   * . NOCHARGE, PORTIN, NEWNUMBER, PROJECTPORT.</td>            </tr>            <tr>
   * <td>NumberFormat</td>                <td>Format of TNs to import. Optional parameter. Possible
   * values... 10D, E164, USMOBILESC.</td>            </tr>            <tr>
   * <td>TelehoneNumberList</td>              <td>List of TNs to import - limited to 5000 Telephone
   * Numbers.</td>            </tr>            <tr>              <td>TnAttributes</td>
   * <td>List of phone number attributes to be assigned. Optional parameter. Possible values: "Protected".
   * </td>            </tr>            <tr>             <td>InitialStatus</td>             <td>TN status
   * that be assigned to imported telephone numbers. Required existence of "Protected" TnAttribute.
   * Possible values: "Available". </td>            </tr>          </tbody>        </table>
   *
   * @param accountid
   * @param body
   * @return Response from the API call
   */
  async createImportToAccountOrder(
    accountid: number,
    body?: ImportToAccountNumberOrder,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountid: [accountid, number()] });
    req.xml(
      'body',
      body,
      'ImportToAccountNumberOrder',
      optional(importToAccountNumberOrderSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountid}/importToAccount`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create a Disconnect order, and disconnect the numbers listed in the disconnect order.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createDisconnectNumberOrder(
    accountId: number,
    body?: DisconnectTelephoneNumberOrder,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'DisconnectTelephoneNumberOrder',
      optional(disconnectTelephoneNumberOrderSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/disconnects`;
    req.throwOn(400, ApiError, 'Bad Response - there were errors in evaluating the body of the request.Potential errors include: <ul>  <li> Protected attribute is invalid. Valid values: TRUE, FALSE, UNCHANGED.</li></ul>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the information associated with the specified port-in ID number. Note: For users of
   * Enterprise Telephony accounts, AlternateSpid, LosingCarrierSPID, LosingCarrierName, and
   * LosingCarrierIsWireless, are omitted from the success output.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @return Response from the API call
   */
  async getAdminParameters(
    accountId: number,
    orderType: string,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminParametersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}`;
    return req.callAsXml(
      'AdminParametersResponse',
      adminParametersResponseSchema,
      requestOptions
    );
  }

  /**
   * It is possible to change ("SUPP" in LNP terms) an existing LNP order.  This is done via a PUT on the
   * existing order-id.Since many of the entries in an LNP Order cannot be changed after the initial
   * order is placed the PUT on a porting order-id does *not* require that the full order payload is
   * included.<br/>If SUPP is done to <strong>draft</strong> portin no validations will be applied except
   * validation of tn list if at least 1 tn is provided.Items that can be included in a SUPP request
   * include:
   * <ul><li>CustomerOrderId</li><li>RequestedFocDate</li><li>BillingTelephoneNumber</li><li>NewBillingTe
   * lephoneNumber</li><li>AccountNumber</li><li>PinNumber</li><li>TnAttributes
   * elements</li><li>Subscriber elements, including the subscriber type, the name elements, and the
   * street address elements.  See the discussion below on
   * ResetAddressFields</li><li>SiteId</li><li>PeerId</li><li>PartialPort,
   * and</li><li>LoaAuthorizingPerson</li><li>ListOfPhoneNumbers</li><li>Triggered</li><li>Immediately</l
   * i></ul>Note: If the order ProcessingStatus is DRAFT, the rules about what can be changed are much
   * more relaxed. Validation is performed when the ProcessingStatus is changed from DRAFT to SUBMITTED.
   * <p>The AltSpid element can be modified if it is not configured at the system level.<p>List of phone
   * numbers can be modified only for Automated on-net port type.<p><b>ProcessingStatus</b> - you can
   * only provide this field with a value of SUBMITTED and only if the current ProcessingStatus of the
   * port-in is DRAFT.<p><b>ResetAddressFields -</b> As stated above the general approach to handling
   * <i>this</i> API call is to replace the elements included in the request body, and leave other
   * preexisting elements in an unmodified condition.  This is typical of a PATCH method, but because of
   * our commitment to backwards compatibility we have elected not to "Fix" this behavior.As a result,
   * providing only a few fields in the street address will result in an update to just those fields.
   * This prevents removal of an element of the address.  The ResetAddressFields element is provided to
   * resolve this issue.  The default setting of 'false' is to consistency with the initial
   * implementation.The recommendation is to replace the entire street address.  This ensures that you
   * are enforcing the street address content of the port-in order.  As part of this recommendation the
   * ResetAddressFields element should be set to true, which will force the street address to be exactly
   * what you specified in the payload.<br> <br> When a port-in is being processed by off-net partner
   * Level 3 (you can tell this because /lnpchecker indicates a Port Type of AUTOMATEDOFFNET), the rules
   * for what can be changed in a SUPP operation are more restrictive. If the order has NOT yet received
   * FOC, you may change the following:<ul>  <li>RequestedFocDate</li>  <li>BillingTelephoneNumber</li>
   * <li>SubscriberType</li>  <li>Subscriber name elements or BusinessName, provided that SubscriberType
   * is provided</li></ul>After FOC has been received, only RequestedFocDate may be changed.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async updateAdminParameters(
    accountId: number,
    orderType: string,
    orderId: string,
    body?: AdminParametersPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminParametersResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.xml(
      'body',
      body,
      'AdminParameters',
      optional(adminParametersPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}`;
    req.throwOn(400, ApiError, 'List of telephone numbers cannot be changed due to validation errors.');
    return req.callAsXml(
      'AdminParametersResponse',
      adminParametersResponseSchema,
      requestOptions
    );
  }

  /**
   * If portin is in DRAFT state the order will be deleted. Otherwise the call simply places the existing
   * order in a cancelled state.Note that only a pending port-in order can be cancelled; if the order was
   * previously cancelled or completed, then a DELETE will not be possible.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @return Response from the API call
   */
  async removeAdminParameters(
    accountId: number,
    orderType: string,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminParametersResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}`;
    req.throwOn(400, ApiError, 'Order id is invalid, order does not exist or the port-in order is already processed, and therefore cannot be deleted.');
    return req.callAsXml(
      'AdminParametersResponse',
      adminParametersResponseSchema,
      requestOptions
    );
  }

  /**
   * This link is used for configuring multiple telephone numbers with specific attributes:<br/>CNAM,
   * NumberFormat, RPIDFormat, RewriteUser, CallForward, Protected and Sms.<br/>There are some possible
   * attribute values:<ul><li> TelephoneNumber - [ 10digit ] </li><li> CallingNameDisplay - [ on | off |
   * <i>unchanged</i> | <i>systemdefault</i> ] </li><li> NumberFormat - [ 10digit | 11digit | e164 |
   * <i>unchanged</i> | <i>systemdefault</i> ] </li><li> RPIDFormat - [ 10digit | 11digit | e164 |
   * <i>unchanged</i> | <i>systemdefault</i> ] </li><li> RewriteUser - [ string | <i>unchanged</i> |
   * <i>systemdefault</i>] </li><li> CallForward - [ 10digit | <i>unchanged</i> | <i>systemdefault</i>]
   * </li><li> Protected - [ true | false | <i>unchanged</i> | <i>systemdefault</i>] </li><li> Sms - [ on
   * | off | <i>unchanged</i>] </li></ul>Where:<ul><li type="square"> <i>systemdefault</i> - implies that
   * the element profile value should be removed so that the TN changes back to the default system
   * behavior;</li><li type="square"> <i>unchanged</i> - the value should remain unchanged - implies a
   * read before write model.</li><li type="square"><u>Leaving the element out of the payload is
   * equivalent to <i>unchanged</i>.</u></li></ul>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createLineOptionOrder(
    accountId: number,
    body?: LineOptionOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LineOptionOrderResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'LineOptionOrder',
      optional(lineOptionOrderPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/lineoptionorders`;
    req.throwOn(400, ApiError, 'Possible errors in response: <li> <li> 50xx "Telephone number is invalid."  </li><li> 50xx "Telephone number is not available on the system."    </li><li> 50xx "Duplicate telephone number."    </li><li> 50xx "Telephone number is required."       </li><li> 50xx "Telephone number is not available."    </li><li> 50xx "There is an issue with telephone number. Please contact Customer Service."    </li><li> 50xx "There are no valid telephone numbers."     </li><li> 50xx "Account has no \'CNAM\'/ \'CallForward\' product feature."      </li><li> 50xx "CallingNameDisplay \'--\' is invalid. Valid values are: on, off, unchanged, systemdefault." </li><li> 50xx "Call Forwarding number \'--\' is not a valid 10-digit telephone number."     </li><li> 50xx "Number Format \'--\' is invalid."     </li><li> 50xx "Rewrite User \'--\' is invalid."     </li><li> 50xx "RPID Format \'--\' is invalid."      </li><li> 13xxx "Protected attribute \'--\' is invalid. Valid values are: true,  false,unchanged, systemdefault." </li><li> 13xxx "Toll free numbers are not candidates for Protected status." </li><li> 13xxx "Non-Tier-0 numbers are not candidates for Protected status." </li></ul>');
    req.throwOn(401, ApiError, 'If customer doesn\'t have a permissions for this link (required role: ROLE_API_CNAMLIDB), this error can appear                    ');
    return req.callAsXml(
      'LineOptionOrderResponse',
      lineOptionOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * <span>A POST creates a request for Telephone Numbers</span><br>A POST on the /orders resource is
   * used to request that the system provide one or more TNs for use by the account.  The post creates a
   * new number order record to preserve the request, as well as the response of the Bandwidth Dashboard
   * API to the request.  A well-formed POST on the /orders resource will create an order record, and
   * return an order-id string that can be used to uniquely identify the new number order request.  The
   * details of success and failure of the request for TNs will be preserved and linked to the returned
   * order id.<br><br>The order-id is returned in the Location Header, allowing the API user immediate
   * access to the order.<br><br>There are multiple ways that new telephone numbers can be requested.
   * The various request payloads are documented below. <br><br>Common values in <b>all</b> request
   * payloads include: <br><table>    <tr>        <th>Parameter</th>        <th>Description</th>    </tr>
   * <tr>        <td>Quantity</td>        <td>The desired quantity of requested numbers. values range
   * from 1-5000. If no quantity is specified, the default of 5000 is returned.</td>    </tr>    <tr>
   * <td>name</td>        <td>The name of the order. Max length restricted to 50 characters.</td>
   * </tr>    <tr>        <td>CustomerOrderId</td>        <td>Optional value for Id set by customer. Only
   * alphanumeric values, dashes and spaces are allowed. Max length is 40 characters.</td>    </tr>
   * <tr>        <td>SiteId</td>        <td>The ID of the Site that the SIP Peer is to be associated with.
   * </td>    </tr>    <tr>        <td>PeerId</td><td>The ID of the SIP Peer that the telephone numbers
   * are to be assigned to.</td>    </tr>    <tr>        <td>PartialAllowed</td>        <td>By default
   * all order submissions are fulfilled partially. Setting the PartialAllowed to false would trigger the
   * entire order to be fulfilled (any error ecnountered such as 1 TN not being available would fail all
   * TNs in the order)<br>            By default, this value is set to false</td>    </tr>    <tr>
   * <td>BackOrderRequested</td>        <td>BackOrderRequested will indicate to the system that if the
   * entire quantity of numbers is not available on the first attempt to fill the new number order, the
   * request will be repeated periodically until the request is successful or cancelled. Setting the
   * parameter to true indeicated a desire to backorder numbers if the entire quantity is not
   * available</td>    </tr></table><p>The following POST payload elements are not common to all orders.
   * They are specific to one or more types of orders:<br><table>    <tr>
   * <th>Parameter</th><th>Description</th>    </tr>    <tr>        <td>TelephoneNumberList</td><td>A
   * list of telephone numbers to order</td>    </tr>    <tr>        <td>AreaCode</td><td>Allowed ranged:
   * [2-9] for the first digit and [0, 9] for both the second and third digits.</td>    </tr>    <tr>
   * <td>RateCenter</td><td>A text Rate Center name.  Must be combined with State information</td>
   * </tr>    <tr>        <td>State</td><td>The two-letter abbreviation of the state</td>    </tr>
   * <tr>        <td>City</td><td>The name of the city that the Ordered telephone numbers should apply
   * to</td>    </tr>    <tr>        <td>Zip</td><td>A five-digit (XXXXX) or nine-digit (XXXXX-XXXX)
   * format value.</td>    </tr>    <tr>        <td>Lata</td><td>A maximum five-digit (XXXXX) numeric
   * format.</td>    </tr>    <tr>        <td>EnableLCA</td><td>If set to true, local calling access
   * numbers will be returned for Rate Center, NPA-NXX and NPANXXX orders if numbers are not available
   * for the given criteria. Default is true.</td>    </tr>    <tr>        <td>Npa-Nxx or Npa-Nxxxx with
   * EnableLCA</td><td>NpaNxx combination to be searched.<br>Valid Npa values:  [2-9] for the first digit,
   * and [0-9] for both the second and third digits.<br>Valid Nxx values: [2-9] for the first digit, and
   * [0-9] for both the second and third digits.<br>Valid Xxvalues [0-9].<br><br>if set to true, enables
   * the ability to get local calling access numbers if numbers are not available for the given criteria.
   * </td>    </tr>    <tr>        <td>LocalVanity</td><td>A text string used to request a regular vanity
   * number. Valid range is between 4 and 7 alphanumeric characters.</td>    </tr>    <tr>
   * <td>EndsIn</td><td>Intended to use with LocalVanity only. The parameter value is true or false. If
   * set to true, the search will look for only numbers which end in specified LocalVanity, otherwise
   * LocalVanity sequence can be met anywhere in last 7 number digits. The default is false.</td>
   * </tr>    <tr>        <td>TollFreeVanity</td><td>A text string used to request a toll free vanity
   * number. Valid range is between 4 and 7 alphanumeric characters.</td>    </tr>    <tr>
   * <td>TollFreeWildCardPattern</td><td>A 3-digit wild card pattern for specifying toll free prefixes,
   * comprised of 8 followed by two stars, a digit and a star or two digits</td>    </tr>    <tr>
   * <td>ReservationIdList</td><td>If a telephone number or numbers have been previously reserved, the
   * ReservationIdList provides the IDs necessary to release the numbers.  This only applies to reserved
   * numbers - if no reservation has been placed on the numbers this list is not required.</td>    </tr>
   * <tr>        <td>TnAttributes</td>        <td>Attributes to be assigned to the telephone number.
   * Optional parameter. Possible values: "Protected"</td>    </tr></table><br><br><b>Putting it all
   * together</b><br><br>The request to order numbers is performed via a POST to the /orders resource.
   * As indicated above, the payload of this POST varies depending on the type of search that is to be
   * performed for the numbers, with a unique payload element used to indicate each different order type.
   * <br><br>The unique components of the payload are described in the table below.  These are combined
   * with the common payload components in the first table above to create a full order payload.  Some
   * complete payloads are captured in the examples. <br><br>The generic response payload is also
   * captured below: <br><table style="text-align: left; width: 100%;" border="1" cellpadding="2"
   * cellspacing="0">    <tbody>        <tr><th>The 'wrapper' Request Payload'</th></tr>        <tr>
   * <td>                <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;
   * Order&gt;    &lt;CustomerOrderId&gt;SJM00001&lt;/CustomerOrderId&gt;    &lt;!--        There are
   * various types of orders, all of which are submitted in the 'xxxOrderType'        element of the
   * Order Request payload.  The 'Payload Segment' elements described in        the table below, which
   * describe the encoding for the various order types, replace        this comment to create a complete
   * payload that includes the order type and the        common elements.        Take a look at the
   * example payloads as well.    --&gt;    &lt;SiteId&gt;202&lt;/SiteId&gt;    &lt;PeerId&gt;518824&lt;
   * /PeerId&gt;    &lt;TnAttributes/&gt;&lt;/Order&gt;                </pre>            </td>
   * </tr>    </tbody></table><table style="text-align: left; width: 100%;" border="1" cellpadding="2"
   * cellspacing="0">  <tbody>    <col width="60%">    <col width="40%">    <tr>      <th>Payload
   * segment</th>      <th>Description</th>    </tr>    <tr>      <td>      <pre>&lt;
   * ExistingTelephoneNumberOrderType&gt;    &lt;TelephoneNumberList&gt;        &lt;TelephoneNumber&gt;
   * 9193752369&lt;/TelephoneNumber&gt;        &lt;TelephoneNumber&gt;9193752720&lt;/TelephoneNumber&gt;
   * &lt;TelephoneNumber&gt;9193752648&lt;/TelephoneNumber&gt;    &lt;/TelephoneNumberList&gt;
   * &lt;ReservationIdList&gt;        &lt;ReservationId&gt;[GUID]&lt;/ReservationId&gt;        &lt;
   * ReservationId&gt;[GUID]&lt;/ReservationId&gt;    &lt;/ReservationIdList&gt;&lt;
   * /ExistingTelephoneNumberOrderType&gt;</pre>      </td>      <td>Order a set of numbers known to be
   * available. <br>      This often results if the numbers have been<br>      found using a separate
   * <b>availableNumbers</b> search<br>        If the numbers have previously been reserved, <br>
   * a reservation id must be included</td>    </tr>    <tr>      <td>      <pre>&lt;
   * AreaCodeSearchAndOrderType&gt;    &lt;AreaCode&gt;617&lt;/AreaCode&gt;    &lt;Quantity&gt;1&lt;
   * /Quantity&gt;&lt;/AreaCodeSearchAndOrderType&gt;</pre>      </td>      <td>Allowed ranges ~ <br>
   * [2-9] for the first digit and <br>      [0, 9] for both the second and <br>      third digits.</td>
   * </tr>    <tr>      <td>      <pre>&lt;RateCenterSearchAndOrderType&gt;    &lt;RateCenter&gt;
   * RALEIGH&lt;/RateCenter&gt;    &lt;State&gt;NC&lt;/State&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;&lt;
   * /RateCenterSearchAndOrderType&gt;</pre>      </td>      <td>Specify the Rate Center and <br> the
   * State</td>    </tr>    <tr>      <td>      <pre>&lt;NPANXXSearchAndOrderType&gt;    &lt;NpaNxx&gt;
   * 919439&lt;/NpaNxx&gt;    &lt;EnableTNDetail&gt;true&lt;/EnableTNDetail&gt;    &lt;EnableLCA&gt;
   * false&lt;/EnableLCA&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;&lt;/NPANXXSearchAndOrderType&gt;</pre>
   * </td>      <td>Specify the NpaNxx combination to be ordered.<br>      Valid Npa values ~ [2-9]
   * for the first digit,<br>      and [0-9] for both the second and third digits.<br>      Valid Nxx
   * values ~ [2-9] for the first digit, <br>      and [0-9] for both the second and third digits.<br>
   * A similar approach is viable for NPANXXXX.<br>      The EnableLCA flag turns LCA search on or off.
   * </td>    </tr>    <tr>      <td>      <pre>&lt;TollFreeVanitySearchAndOrderType&gt;   &lt;
   * Quantity&gt;1&lt;/Quantity&gt;       &lt;TollFreeVanity&gt;newcars&lt;/TollFreeVanity&gt;&lt;
   * /TollFreeVanitySearchAndOrderType&gt;</pre>      </td>      <td>      Specify a Toll Free Vanity
   * search, where the <br>      numbers ordered match a specific alphanumeric <br>      pattern between
   * 4 and 7 characters long</td>    </tr>    <tr>      <td>      <pre>&lt;
   * TollFreeWildCharSearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;    &lt;
   * TollFreeWildCardPattern&gt;8**&lt;/TollFreeWildCardPattern&gt;&lt;
   * /TollFreeWildCharSearchAndOrderType&gt;</pre>      </td>      <td>Specify the Toll Free wild card
   * pattern.<br>      to be ordered, comprised of 3 digits beginning with '8'.<br>      Examples are 8**,
   * 87*, etc.</td>    </tr>    <tr>      <td>      <pre>&lt;StateSearchAndOrderType&gt;    &lt;
   * Quantity&gt;1&lt;/Quantity&gt;    &lt;State&gt;NC&lt;/State&gt;&lt;/StateSearchAndOrderType&gt;
   * </pre>      </td>      <td>Specify the State to be searched<br>for telephone numbers</td>    </tr>
   * <tr>      <td>      <pre>&lt;CitySearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;
   * &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;State&gt;NC&lt;/State&gt;&lt;/CitySearchAndOrderType&gt;
   * </pre>      </td>      <td>Specify the City and State to be ordered from.</td>    </tr>    <tr>
   * <td>      <pre>&lt;ZIPSearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;    &lt;Zip&gt;
   * 27606&lt;/Zip&gt;&lt;/ZIPSearchAndOrderType&gt;</pre>      </td>      <td>Specify the Zip Code to be
   * ordered from.</td>    </tr>    <tr>      <td>      <pre>&lt;LATASearchAndOrderType&gt;    &lt;
   * Quantity&gt;1&lt;/Quantity&gt;       &lt;Lata&gt;224&lt;/Lata&gt;&lt;/LATASearchAndOrderType&gt;
   * </pre>      </td>      <td>Specify the LATA to order <br> telephone numbers from.</td>    </tr>
   * <tr>      <td>      <pre>&lt;CombinedSearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;
   * &lt;AreaCode&gt;617&lt;/AreaCode&gt;    &lt;RateCenter&gt;RALEIGH&lt;/RateCenter&gt;    &lt;State&gt;
   * NC&lt;/State&gt;    &lt;NpaNxx&gt;919439&lt;/NpaNxx&gt;    &lt;NpaNxxX&gt;9194391&lt;/NpaNxxX&gt;
   * &lt;Lata&gt;224&lt;/Lata&gt;    &lt;City&gt;RALEIGH&lt;/City&gt;    &lt;Zip&gt;27606&lt;/Zip&gt;
   * &lt;EnableLCA&gt;false&lt;/EnableLCA&gt;&lt;/CombinedSearchAndOrderType&gt;</pre>      </td>
   * <td>Specify the any combination of:<br>
   * <ul><li>AreaCode</li><li>RateCenter</li><li>State</li><li>NpaNxx</li><li>NpaNxxX</li><li>Lata</li><l
   * i>City</li><li>Zip</li></ul>      <br>But with following limitations:<ul>    <li>Parameters AreaCode,
   * NpaNxx and NpaNxxX<br>are mutually exclusive</li>    <li>LCA search is supported only for<br>one of
   * the following criteria:<ul><ul><li>NpaNxx</li><li>NpaNxxX</li><li>RateCenter and
   * State</li></ul></li>    <li>If City or RateCenter is specified<br>then State is required</li></ul>
   * </td><tr><td><pre>&lt;CombinedSearchAndOrderType&gt;    &lt;Quantity&gt;1&lt;/Quantity&gt;    &lt;
   * AreaCode&gt;617&lt;/AreaCode&gt;    &lt;LocalVanity&gt;newcars&lt;/LocalVanity&gt;    &lt;EndsIn&gt;
   * false&lt;/EndsIn&gt;&lt;/CombinedSearchAndOrderType&gt;</pre></td><td>    Specify AreaCode and
   * LocalVanity to order telephone numbers matching a specific alphanumeric pattern between 4 and 7
   * characters long.<br>    <br>    Limitations:    <ul>    <li>AreaCode is always required</li>
   * <li>No parameter combinations are allowed here</li>    <li>This order type is unsupported with
   * BackOrderRequested=true</li>    </ul></td></tr><tr><td><pre> &lt;TnAttributes&gt;    &lt;
   * TnAttribute&gt;Protected&lt;/TnAttribute&gt;    &lt;/TnAttributes&gt;</pre>        </td>
   * <td>Specify TnAttribute to be assigned to the ordered telephone numbers.</td>      </tr>    </tr>
   * </tbody></table><br> <br> Some examples of POST payloads for some orders are below...
   *
   * @param accountid
   * @param body
   * @return Response from the API call
   */
  async createOrder3(
    accountid: number,
    body?: Order,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountid: [accountid, number()] });
    req.xml('body', body, 'Order', optional(orderSchema));
    req.appendTemplatePath`/accounts/${mapped.accountid}/orders`;
    req.throwOn(400, ApiError, 'One or more of the input parameters are invalid.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * With the introduction of Backorder capabilities, new number orders may stay in backordered state
   * while the order is filled.   While in this state it is possible to update the modifiable fields in
   * the record, as well as to request that backorder processing of the order be ended.The fields that
   * can be updated are...<ul><li>The order name</li><li>The customer order id</li><li>The backordered
   * state.</li></ul>Specifying a &lt;CloseOrder&gt; value of true will cancel the backorder request,
   * leaving the currently ordered numbers on the account.  No further numbers will be added to the
   * account as a result of the order.
   *
   * @param accountid
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async updateOrder(
    accountid: number,
    orderId: string,
    body?: Order,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountid: [accountid, number()],
      orderId: [orderId, string()],
    });
    req.xml('body', body, 'Order', optional(orderSchema));
    req.appendTemplatePath`/accounts/${mapped.accountid}/orders/${mapped.orderId}`;
    req.throwOn(400, ApiError, 'The request payload is invalid');
    req.throwOn(404, ApiError, 'The order-id cannot be found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve the set of notes associated with an order.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @return Response from the API call
   */
  async getOrderNotes(
    accountId: number,
    orderType: string,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NotesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/notes`;
    return req.callAsXml('Notes', notesResponseSchema, requestOptions);
  }

  /**
   * Updates the Notes resource by adding a note. Adding a note to a port-in order causes a notification
   * to be sent to Bandwidth Operations, so that they may assist as necessary.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param body
   * @return Response from the API call
   */
  async createOrderNote(
    accountId: number,
    orderType: string,
    orderId: string,
    body?: Note,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NoteResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
    });
    req.xml('body', body, 'Note', optional(noteSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/notes`;
    req.throwOn(400, ApiError, 'Bad Request - the note has not been created because the payload is incomplete or in error.  An error payload is provided in the response.');
    return req.callAsXml('NoteResponse', noteResponseSchema, requestOptions);
  }

  /**
   * Updates single note by it's id.
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param noteId
   * @param body
   * @return Response from the API call
   */
  async updateOrderNote(
    accountId: number,
    orderType: string,
    orderId: string,
    noteId: number,
    body?: Note,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NoteResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      noteId: [noteId, number()],
    });
    req.xml('body', body, 'Note', optional(noteSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/notes/${mapped.noteId}`;
    req.throwOn(400, ApiError, 'Bad Request - the note has not been updated because the payload is incomplete or in error.  An error payload is provided in the response.');
    return req.callAsXml('NoteResponse', noteResponseSchema, requestOptions);
  }

  /**
   * Reserves a telephone number for a default time of 4 hours. A successful reservation returns a
   * location header that can be used to retrieve the reservation at a later time.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createReservation(
    accountId: number,
    body?: Reservation,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReservationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Reservation', optional(reservationSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/TnReservation`;
    req.throwOn(400, ApiError, 'The Telephone Number requested is not available.');
    return req.callAsXml(
      'ReservationResponse',
      reservationResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves a TN reservation's information.
   *
   * @param accountId
   * @param reservationId
   * @return Response from the API call
   */
  async getReservation(
    accountId: number,
    reservationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReservationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      reservationId: [reservationId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/TnReservation/${mapped.reservationId}`;
    return req.callAsXml(
      'ReservationResponse',
      reservationResponseSchema,
      requestOptions
    );
  }

  /**
   * Deletes a TN reservation.
   *
   * @param accountId
   * @param reservationId
   * @return Response from the API call
   */
  async deleteReservation(
    accountId: number,
    reservationId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReservationResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      reservationId: [reservationId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/TnReservation/${mapped.reservationId}`;
    return req.callAsXml(
      'ReservationResponse',
      reservationResponseSchema,
      requestOptions
    );
  }

  /**
   * This API call retrieves information about the account indicated by the Account ID.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAcctReports(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/reports`;
    return req.callAsXml(
      'ReportsResponse',
      reportsResponseSchema,
      requestOptions
    );
  }

  /**
   * A GET issued on a specific report (as identified by it's ID) will return all of the details of that
   * report, allowing the API user to create an instance of that report.  Those details include:    <ul>
   * <li>The report name</li>        <li>a description of the report in general terms</li>
   * <li>a set of parameters that are used to provide boundaries on the information that is provided.
   * &nbsp;These parameters contain</li>        <ul>            <li>The parameter name,</li>
   * <li>a&nbsp;description of the parameter,</li>            <li>a declaration of whether it is required
   * or not, </li>            <li>is multiple vales allowed or not, </li>            <li>the type of the
   * parameter, which can be one of</li>                <ul>                    <li>Account ID
   * (autofilled)</li>                    <li>Site ID</li>                    <li>SipPeer ID</li>
   * <li>String</li>                    <li>Integer</li>                    <li>Boolean</li>
   * <li>Enum, with a list of possible values.</li>                </ul>
   * <li>the help info for describing parameter</li>            </ul>        </ul>    </ul>
   *
   * @param accountId
   * @param reportId
   * @return Response from the API call
   */
  async getAcctReport(
    accountId: number,
    reportId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      reportId: [reportId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/reports/${mapped.reportId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportResponse',
      reportResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report instances associated with a specific report, including the up-to-date report
   * generation status.
   *
   * @param reportId
   * @param accountId
   * @param userInstancesOnly
   * @return Response from the API call
   */
  async getAcctReportInstances(
    reportId: number,
    accountId: number,
    userInstancesOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstancesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      accountId: [accountId, number()],
      userInstancesOnly: [userInstancesOnly, optional(boolean())],
    });
    req.query('userInstancesOnly', mapped.userInstancesOnly);
    req.appendTemplatePath`/accounts/${mapped.reportId}/reports/${mapped.accountId}/instances`;
    return req.callAsXml(
      'ReportInstancesResponse',
      reportInstancesResponseSchema,
      requestOptions
    );
  }

  /**
   * POSTing to the instances resource of a specific report will create an instance of that report that
   * pulls from data that is filtered by the supplied parameters.  Those parameter values must match the
   * parameters that are required as defined by the report, as provided by issuing a GET on the report.
   * <br><br>The sequence of events is essentially to...<ol>    <li>issue a GET on the desired
   * report/report-id to retrieve the parameter and other details of the report</li>    <li>issue a POST
   * on the /report/report-id/instances resource, using the parameter information retrieved in the
   * initial call to define the data that is needed</li></ol>The Location header will provide a link to
   * the created report instance.  Note that the report instance itself contains only the metadata
   * describing the instance.  A subsequent call to /report/report-id/instances/instance-id/file must be
   * made to actually download the file.
   *
   * @param reportId
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createAcctReportInstance(
    reportId: number,
    accountId: number,
    body?: ReportInstance,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      accountId: [accountId, number()],
    });
    req.xml('body', body, 'Instance', optional(reportInstanceSchema));
    req.appendTemplatePath`/accounts/${mapped.reportId}/reports/${mapped.accountId}/instances`;
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(503, ApiError, 'Service Unavailable');
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param userInstancesOnly
   * @return Response from the API call
   */
  async getAcctInstances(
    accountId: number,
    userInstancesOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstancesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      userInstancesOnly: [userInstancesOnly, optional(boolean())],
    });
    req.query('userInstancesOnly', mapped.userInstancesOnly);
    req.appendTemplatePath`/accounts/${mapped.accountId}/reports/instances`;
    return req.callAsXml(
      'ReportInstancesResponse',
      reportInstancesResponseSchema,
      requestOptions
    );
  }

  /**
   * A GET on the specific instance will retrieve report instance details, including the current report
   * instance status.  All of the information required to understand the nature and limits of the
   * reported data are contained in the payload, including the general description information as well as
   * the list of parameters and the values assigned to those parameters.
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async getAcctReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.reportId}/reports/${mapped.reportInstanceId}/instances/${mapped.accountId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateAcctReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId: number,
    body?: ReportInstance,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, number()],
    });
    req.xml('body', body, 'Instance', optional(reportInstanceSchema));
    req.appendTemplatePath`/accounts/${mapped.reportId}/reports/${mapped.reportInstanceId}/instances/${mapped.accountId}`;
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report instance output file, if output is available.
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async getAcctReportInstanceFile(
    reportId: number,
    reportInstanceId: number,
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.reportId}/reports/${mapped.reportInstanceId}/instances/${mapped.accountId}/file`;
    req.throwOn(404, ApiError, 'A report instance matching the supplied identification information could not be found.');
    return req.callAsXml(
      'ReportInstanceFileResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async deleteAcctReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.reportId}/${mapped.reportInstanceId}/instances/${mapped.accountId}`;
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the phone numbers according to the input parameters
   *
   * @param accountId
   * @param areaCode
   * @param npaNxx
   * @param npaNxxx
   * @param rateCenter
   * @param lata
   * @param city
   * @param state
   * @param zip
   * @param tollFreeWildCardPattern
   * @param tollFreeVanity
   * @param localVanity
   * @param endsIn
   * @param enableTNDetail
   * @param quantity
   * @param orderBy
   * @param mProtected
   * @param lCA
   * @return Response from the API call
   */
  async searchTelephoneNumbers(
    accountId: number,
    areaCode?: string,
    npaNxx?: string,
    npaNxxx?: string,
    rateCenter?: string,
    lata?: string,
    city?: string,
    state?: string,
    zip?: string,
    tollFreeWildCardPattern?: string,
    tollFreeVanity?: string,
    localVanity?: string,
    endsIn?: boolean,
    enableTNDetail?: boolean,
    quantity?: number,
    orderBy?: string,
    mProtected?: string,
    lCA?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchResult>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      areaCode: [areaCode, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxx: [npaNxxx, optional(string())],
      rateCenter: [rateCenter, optional(string())],
      lata: [lata, optional(string())],
      city: [city, optional(string())],
      state: [state, optional(string())],
      zip: [zip, optional(string())],
      tollFreeWildCardPattern: [tollFreeWildCardPattern, optional(string())],
      tollFreeVanity: [tollFreeVanity, optional(string())],
      localVanity: [localVanity, optional(string())],
      endsIn: [endsIn, optional(boolean())],
      enableTNDetail: [enableTNDetail, optional(boolean())],
      quantity: [quantity, optional(number())],
      orderBy: [orderBy, optional(string())],
      mProtected: [mProtected, optional(string())],
      lCA: [lCA, optional(boolean())],
    });
    req.query('areaCode', mapped.areaCode);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxx', mapped.npaNxxx);
    req.query('rateCenter', mapped.rateCenter);
    req.query('lata', mapped.lata);
    req.query('city', mapped.city);
    req.query('state', mapped.state);
    req.query('zip', mapped.zip);
    req.query('tollFreeWildCardPattern', mapped.tollFreeWildCardPattern);
    req.query('tollFreeVanity', mapped.tollFreeVanity);
    req.query('localVanity', mapped.localVanity);
    req.query('endsIn', mapped.endsIn);
    req.query('enableTNDetail', mapped.enableTNDetail);
    req.query('quantity', mapped.quantity);
    req.query('orderBy', mapped.orderBy);
    req.query('protected', mapped.mProtected);
    req.query('LCA', mapped.lCA);
    req.appendTemplatePath`/accounts/${mapped.accountId}/availableNumbers`;
    req.throwOn(400, ApiError, 'Invalid/missing input parameter');
    return req.callAsXml('SearchResult', searchResultSchema, requestOptions);
  }

  /**
   * Retrieves a list of available Npa-Nxx telephone numbers.
   *
   * @param accountId
   * @param areaCode
   * @param state
   * @param quantity
   * @return Response from the API call
   */
  async searchAvailableNpaNxx(
    accountId: number,
    areaCode?: string,
    state?: string,
    quantity?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchResultForAvailableNpaNxx>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      areaCode: [areaCode, optional(string())],
      state: [state, optional(string())],
      quantity: [quantity, optional(number())],
    });
    req.query('areaCode', mapped.areaCode);
    req.query('state', mapped.state);
    req.query('quantity', mapped.quantity);
    req.appendTemplatePath`/accounts/${mapped.accountId}/availableNpaNxx`;
    req.throwOn(400, ApiError, 'There are no phone numbers within the specified scope.');
    return req.callAsXml(
      'SearchResultForAvailableNpaNxx',
      searchResultForAvailableNpaNxxSchema,
      requestOptions
    );
  }

  /**
   * The Rate Centers API Call returns information about the Bandwidth CLEC Network, including coverage
   * data, indicating both the extent of on-net and off-net coverage, as well as number availability,
   * again from an on-net and off-net perspective. The rules are as follows- <ul><li>If supported=true is
   * specified, then the coverage or availability is reported for the Bandwidth CLEC only. </li><li>If
   * supported=true is omitted or false, then the coverage or availability is reported for the
   * combination of the Bandwidth CLEC and our partners </li><li>If available=true is specified, then
   * only Rate Centers in which we have available numbers are reported. </li><li>If available is omitted
   * or false then all Rate Centers within the scope defined by supported will be returned.
   * </li></ul>These rules apply for both the /rateCenters and /cities API calls. <table border="1"
   * cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top" > </td> <td valign="top" > Supported
   * = true </td> <td valign="top" > Supported is missing </td> </tr> <tr> <td valign="top" > available =
   * true </td> <td valign="top" > Available numbers within the Bandwidth CLEC network </td> <td
   * valign="top" > Available numbers within the Bandwidth CLEC network combined with our partner
   * networks </td> </tr> <tr> <td valign="top" > available is missing </td> <td valign="top" > Coverage
   * in the Bandwidth CLEC </td> <td valign="top" > Coverage of the combined Bandwidth CLEC + Partner
   * networks </td> </tr> </tbody> </table>
   *
   * @param state
   * @param supported
   * @param available
   * @return Response from the API call
   */
  async searchRateCenters(
    state?: string,
    supported?: boolean,
    available?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RateCenterSearchResults>> {
    const req = this.createRequest('GET', '/rateCenters');
    const mapped = req.prepareArgs({
      state: [state, optional(string())],
      supported: [supported, optional(boolean())],
      available: [available, optional(boolean())],
    });
    req.query('state', mapped.state);
    req.query('supported', mapped.supported);
    req.query('available', mapped.available);
    return req.callAsXml(
      'RateCenterResponse',
      rateCenterSearchResultsSchema,
      requestOptions
    );
  }

  /**
   * The Rate Centers and Cities API Calls return information about the Bandwidth CLEC Network, including
   * coverage data, indicating both the extent of on-net and off-net coverage, as well as number
   * availability, again from an on-net and off-net perspective. The rules are as follows- <ul><li>If
   * supported=true is specified, then the coverage or availability is reported for the Bandwidth CLEC
   * only. </li><li>If supported is omitted or false, then the coverage or availability is reported for
   * the combination of the Bandwidth CLEC and our partners </li><li>If available=true is specified, then
   * only Rate Centers in which we have available numbers are reported. </li><li>If available is omitted
   * or false, then all Rate Centers within the scope defined by supported will be returned.
   * </li></ul>These rules apply for both the /rateCenters and /cities API calls. <table border="1"
   * cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top" > </td> <td valign="top" > Supported
   * = true </td> <td valign="top" > Supported is missing </td> </tr> <tr> <td valign="top" > available =
   * true </td> <td valign="top" > Available numbers within the Bandwidth CLEC network </td> <td
   * valign="top" > Available numbers within the Bandwidth CLEC network combined with our partner
   * networks </td> </tr> <tr> <td valign="top" > available is missing </td> <td valign="top" > Coverage
   * in the Bandwidth CLEC </td> <td valign="top" > Coverage of the combined Bandwidth CLEC + Partner
   * networks </td> </tr> </tbody> </table>
   *
   * @param state
   * @param supported
   * @param available
   * @return Response from the API call
   */
  async searchCities(
    state?: string,
    supported?: boolean,
    available?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CitySearchResults>> {
    const req = this.createRequest('GET', '/cities');
    const mapped = req.prepareArgs({
      state: [state, optional(string())],
      supported: [supported, optional(boolean())],
      available: [available, optional(boolean())],
    });
    req.query('state', mapped.state);
    req.query('supported', mapped.supported);
    req.query('available', mapped.available);
    return req.callAsXml(
      'CityResponse',
      citySearchResultsSchema,
      requestOptions
    );
  }

  /**
   * The Covered Rate Centers API Call return information about the Bandwidth CLEC Network, including
   * coverage data, indicating both the extent of on-net and off-net coverage, as well as number
   * availability. The various query parameters are summarized in the following table ... <table
   * border="0" cellpadding="0" cellspacing="0"> <tbody> <tr> <td valign="top" width="114">
   * <p><strong>Query Parameter</strong> </p> </td> <td valign="top"> <p><strong>Description</strong>
   * </p> </td> </tr> <tr> <td valign="top" width="114"> <p>page </p> </td> <td valign="top"> <p>The
   * starting value for a paginated response. The default is 1 indicating the first page of results.
   * </p> </td> </tr> <tr> <td valign="top" width="114"> <p>size </p> </td> <td valign="top"> <p>The
   * number of rate centers to include in a paginated result payload. </p> </td> </tr> <tr> <td
   * valign="top" width="114"> <p>state </p> </td> <td valign="top"> <p>A 2 character State code </p>
   * </td> </tr> <tr> <td valign="top" width="114"> <p>abbreviation </p> </td> <td valign="top"> <p>A
   * rate center abbreviation </p> </td> </tr> <tr> <td valign="top" width="114"> <p>name </p> </td> <td
   * valign="top"> <p>A rate center name </p> </td> </tr> <tr> <td valign="top" width="114"> <p>zip </p>
   * </td> <td valign="top"> <p>A 5 digit zip code </p> </td> </tr> <tr> <td valign="top" width="114">
   * <p>city </p> </td> <td valign="top"> <p>A City name </p> </td> </tr> <tr> <td valign="top"
   * width="114"> <p>lata </p> </td> <td valign="top"> <p>A 3 or 5 digit LATA </p> </td> </tr> <tr> <td
   * valign="top" width="114"> <p>tier </p> </td> <td valign="top"> <p>A bandwidth coverage tier; a value
   * from 0 to 5. </p> </td> </tr> <tr> <td valign="top" width="114"> <p>npa </p> </td> <td valign="top">
   * <p>A 3 digit NPA or Area Code </p> </td> </tr> <tr> <td valign="top" width="114"> <p>npaNxx </p>
   * </td> <td valign="top"> <p>6 digits NPA and NXX values </p> </td> </tr> <tr> <td valign="top"
   * width="114"> <p>npaNxxX </p> </td> <td valign="top"> <p>7 digits of NPA, NXX and thousands block
   * values. </p> </td> </tr> <tr> <td valign="top" width="114"> <p>embed </p> </td> <td valign="top">
   * <p>One of the values [ZipCodes, Cities, NpaNxxX, AvailableNumberCount, LimitedAvailableNumberCount,
   * LocalRateCenters]. <br> This repeatable query parameter will force a list (or multiple lists) of the
   * indicated data to be provided in the response. For example if the payload should contain a list of
   * the Cities covered by the Rate Centers then embed=cities would be included as a query parameter.<br>
   * No filter parameters are supported if <q>LocalRateCenters</q> is specified. In this case only
   * <q>size</q>, <q>page</q> and any other <q>embed</q> parameters are supported. </p> </td> </tr>
   * </tbody> </table>
   *
   * @param page
   * @param size
   * @param name
   * @param abbreviation
   * @param state
   * @param zip
   * @param city
   * @param lata
   * @param npa
   * @param npaNxx
   * @param npaNxxX
   * @param tier
   * @param embed
   * @return Response from the API call
   */
  async searchCoveredRateCenters(
    page?: string,
    size?: number,
    name?: string,
    abbreviation?: string,
    state?: string,
    zip?: string,
    city?: string,
    lata?: string,
    npa?: string,
    npaNxx?: string,
    npaNxxX?: string,
    tier?: string,
    embed?: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CoveredRateCenterSearchResponse>> {
    const req = this.createRequest('GET', '/coveredRateCenters');
    const mapped = req.prepareArgs({
      page: [page, optional(string())],
      size: [size, optional(number())],
      name: [name, optional(string())],
      abbreviation: [abbreviation, optional(string())],
      state: [state, optional(string())],
      zip: [zip, optional(string())],
      city: [city, optional(string())],
      lata: [lata, optional(string())],
      npa: [npa, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxX: [npaNxxX, optional(string())],
      tier: [tier, optional(string())],
      embed: [embed, optional(array(string()))],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('name', mapped.name);
    req.query('abbreviation', mapped.abbreviation);
    req.query('state', mapped.state);
    req.query('zip', mapped.zip);
    req.query('city', mapped.city);
    req.query('lata', mapped.lata);
    req.query('npa', mapped.npa);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxX', mapped.npaNxxX);
    req.query('tier', mapped.tier);
    req.query('embed', mapped.embed);
    req.throwOn(400, ApiError, 'Invalid query parameter value');
    return req.callAsXml(
      'CoveredRateCenters',
      coveredRateCenterSearchResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about a specific covered rate center identified as the resource.
   *
   * @param rateCenterId
   * @return Response from the API call
   */
  async searchCoveredRateCenter(
    rateCenterId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CoveredRateCenter>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ rateCenterId: [rateCenterId, number()] });
    req.appendTemplatePath`/coveredRateCenters/${mapped.rateCenterId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the rate center id does not exist in the system');
    return req.callAsXml(
      'CoveredRateCenter',
      coveredRateCenterSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param q
   * @param type
   * @return Response from the API call
   */
  async getDoTypeaheadSearch(
    q?: string,
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/typeahead');
    const mapped = req.prepareArgs({
      q: [q, optional(string())],
      type: [type, optional(string())],
    });
    req.query('q', mapped.q);
    req.query('type', mapped.type);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * list the products associated with a SIP Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerProductsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products`;
    return req.callAsXml(
      'SipPeerProductResponse',
      sipPeerProductsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve sipper messaging settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveMessagingSettings(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerMessagingSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/settings`;
    return req.callAsXml(
      'SipPeerMessagingSettingsResponse',
      sipPeerMessagingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * create/update/delete messaging settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateMessagingSettings1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerMessagingSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerMessagingSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerMessagingSettings',
      optional(sipPeerMessagingSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/settings`;
    req.throwOn(400, ApiError, 'settings were successfully created/updated');
    return req.callAsXml(
      'SipPeerMessagingSettingsResponse',
      sipPeerMessagingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve sms feature settings for sippeer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveSmsFeature(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerSmsFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms`;
    return req.callAsXml(
      'SipPeerSmsFeatureResponse',
      sipPeerSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Update sms feature settings. <br/><b>Warning</b>: settings A2pLongCode as 'ON' or 'OFF' will enforce
   * this value for all tns under target sippeer <br/><b>Note</b>: In case of using SMPP protocol, it may
   * be not possible to add or delete hosts with large subnet masks. <br/>Please refer to the
   * documentation ofaccounts/:accountid/sites/:siteid/sippeers/:sippeerid/products/:
   * messaging/features/sms/smpp/hostsendpoint for information about restrictions and other tips
   * regarding smpp hosts.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSmsFeature1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerSmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerSmsFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerSmsFeature',
      optional(sipPeerSmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>CampaignID shouldn\'t be present if all of features \'A2pLongCode\', \'TollFree\' and \'ShortCode\' are disabled</li>   <li>CampaignID is required if at least one of features \'A2pLongCode\', \'TollFree\' and \'ShortCode\' is enabled</li>   <li>Campaign ID \'%s\' was not found in list of authorized Campaign IDs.</li>   <li>A2P Campaign ID \'%s\' is not valid. Needs to be between 1 and 64 characters. Only alphanumeric characters,   whitespaces, dashes, underscores and dots are allowed.</li>   <li>A2P Message Class \'%s\' is not valid.</li>   <li>A2P Message Class is required if at least one of features \'A2pLongCode\', \'TollFree\' and \'ShortCode\' is enabled</li>   <li>A2P Message Class shouldn\'t be present if all of features \'A2pLongCode\', \'TollFree\' and \'ShortCode\' are disabled</li>   <li>A2P Message Class \'%s\' was not found in list of authorized Message Classes.</li>   <li>A2P Message Class is required if \'A2pLongCode\' is enabled.</li>   <li>A2P Message Class shouldn\'t be present if \'A2pLongCode\' is disabled.</li>   <li>A2pLongCode value is invalid. Valid values are: \'ON\', \'OFF\', \'DefaultOn\', \'DefaultOff\'.</li>   <li>Host ip or mask can\'t be changed</li>   <li>47.0.0.0/12 has invalid mask. Valid mask values: 14-32</li>   <li>Termination IP 47.123.17.16/30 overlaps with an address that is already in use</li>   <li>Termination IP 47.123.17.16/30 overlaps with addresses that are already in use: 47.123.17.18</li>   <li>The IP address provided: &lt;47.123.17.17&gt; contains a non zero subnet portion. An equivalent   IP address such as &lt;47.123.17.16&gt; with a zero subnet value must be provided</li>   <li>Can not disable shortcode sms settings for a SipPeer if shortcode numbers with messaging enabled   are present on this SipPeer</li></ul>');
    req.throwOn(403, ApiError, 'Access denied. Possible errors in response:<ul>   <li>Configuring subnet values larger than /20 requires Bandwidth staff intervention</li></ul>');
    return req.callAsXml(
      'SipPeerSmsFeatureResponse',
      sipPeerSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Create sms feature settings. <br/><b>Warning</b>: settings A2pLongCode as 'ON' or 'OFF' will enforce
   * this value for all tns under target sippeer <br/><b>Note</b>: In case of using SMPP protocol, it may
   * be not possible to add or delete hosts with large subnet masks. <br/>Please refer to the
   * documentation ofaccounts/:accountid/sites/:siteid/sippeers/:sippeerid/products/:
   * messaging/features/sms/smpp/hostsendpoint for information about restrictions and other tips
   * regarding smpp hosts.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSmsFeature1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerSmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerSmsFeatureResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerSmsFeature',
      optional(sipPeerSmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>    <li>Account level settings don`t exist</li>    <li>CampaignID shouldn\'t be present if all of features \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' are disabled</li>    <li>CampaignID is required if at least one of features \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' is enabled</li>    <li>Campaign ID \'%s\' was not found in list of authorized Campaign IDs.</li>    <li>A2P Campaign ID \'%s\' is not valid. Needs to be between 1 and 64 characters. Only alphanumeric    characters, whitespaces, dashes, underscores and dots are allowed.</li>    <li>A2P Message Class \'%s\' is not valid.</li>    <li>A2P Message Class is required if at least one of features \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' is enabled</li>    <li>A2P Message Class shouldn\'t be present if all of features \'A2pLongCode\', \'TollFree\' and    \'ShortCode\' are disabled</li>    <li>A2P Message Class \'%s\' was not found in list of authorized Message Classes.</li>    <li>A2P Message Class is required if \'A2pLongCode\' is enabled.</li>    <li>A2P Message Class shouldn\'t be present if \'A2pLongCode\' is disabled.</li>    <li>A2pLongCode value is invalid. Valid values are: \'ON\', \'OFF\', \'DefaultOn\', \'DefaultOff\'.</li>    <li>Host ip or mask can\'t be changed</li>    <li>47.0.0.0/12 has invalid mask. Valid mask values: 14-32</li>    <li>Termination IP 47.123.17.16/30 overlaps with an address that is already in use</li>    <li>Termination IP 47.123.17.16/30 overlaps with addresses that are already in use: 47.123.17.18</li>    <li>The IP address provided: &lt;47.123.17.17&gt; contains a non zero subnet portion. An equivalent IP    address such as &lt;47.123.17.16&gt; with a zero subnet value must be provided</li>    <li>Account \'%s\' has no \'%s\' product feature</li>    <li>Can\'t create sip peer http protocol sms feature without account level http settings.</li></ul>');
    req.throwOn(403, ApiError, 'Access denied. Possible errors in response:<ul>   <li>Configuring subnet values larger than /20 requires Bandwidth staff intervention</li></ul>');
    return req.callAsXml(
      'SipPeerSmsFeatureResponse',
      sipPeerSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * delete sms settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async deleteSmsFeature(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerSmsFeatureResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>  <li>SMS feature can\'t be removed because MMS feature is present, remove it first.</li>  <li>Can not disable SMS feature on Sip Peer because it has telephone numbers with messaging enabled.</li></ul>');
    req.throwOn(404, ApiError, 'sms settings do not exist');
    return req.callAsXml(
      'SipPeerSmsFeatureResponse',
      sipPeerSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve mms feature settings for sippeer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveMmsFeatureSettings1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureMmsSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/mms/settings`;
    return req.callAsXml(
      'MmsFeatureMmsSettingsResponse',
      mmsFeatureMmsSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve mms feature settings for sippeer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveMmsFeature(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/mms`;
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * update mms feature settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateMmsFeature1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerMmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml('body', body, 'MmsFeature', optional(sipPeerMmsFeatureSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/mms`;
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Set mms feature settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createMmsFeature1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerMmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml('body', body, 'MmsFeature', optional(sipPeerMmsFeatureSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/mms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Pauload contains two protocol</li></ul>');
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * delete mms settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async deleteMmsFeature1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/mms`;
    req.throwOn(404, ApiError, 'mms settings were not found');
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve smpp hosts
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveSmsFeatureSmppHosts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmsSmppHostsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms/smpp/hosts`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Host ip or mask can\'t be changed</li>   <li>47.0.0.0/12 has invalid mask. Valid mask values: 14-32</li>   <li>Termination IP 47.123.17.16/30 overlaps with an address that is already in use</li>   <li>Termination IP 47.123.17.16/30 overlaps with addresses that are already in use: 47.123.17.18</li>   <li>The IP address provided: <47.123.17.17> contains a non zero subnet portion. An equivalent IP address such as <47.123.17.16> with a zero subnet value must be provided</li></ul>');
    req.throwOn(403, ApiError, 'Access denied. Possible errors in response:<ul>   <li>Configuring subnet values larger than /20 requires Bandwidth staff intervention</li></ul>');
    return req.callAsXml(
      'SmsSmppHostsResponse',
      smsSmppHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * Add smpp host. Host address may or may not include the subnet mask (/32 is assumed if not
   * specified)Regular users can only specify subnets not larger then /20. Updatingsubnet values larger
   * than /20 requires Bandwidth staff intervention (Bandwidth staff may define subnets upto /14)Also,
   * host address should not intersect with addresses used by other services or other accounts,otherwise
   * a validation error will occur.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSmsFeatureSmppHosts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SmsHost,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmsSmppHostsResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml('body', body, 'SmsHost', optional(smsHostSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms/smpp/hosts`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Host ip or mask can\'t be changed</li>   <li>47.0.0.0/12 has invalid mask. Valid mask values: 14-32</li>   <li>Termination IP 47.123.17.16/30 overlaps with an address that is already in use</li>   <li>Termination IP 47.123.17.16/30 overlaps with addresses that are already in use: 47.123.17.18</li>   <li>The IP address provided: <47.123.17.17> contains a non zero subnet portion. An equivalent IP address such as <47.123.17.16> with a zero subnet value must be provided</li></ul>');
    req.throwOn(403, ApiError, 'Access denied. Possible errors in response:<ul>   <li>Configuring subnet values larger than /20 requires Bandwidth staff intervention</li></ul>');
    return req.callAsXml(
      'SmsSmppHostsResponse',
      smsSmppHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve smpp host
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param hostId
   * @return Response from the API call
   */
  async retrieveSmsFeatureSmppHost(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    hostId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmsSmppHostsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      hostId: [hostId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms/smpp/hosts/${mapped.hostId}`;
    return req.callAsXml(
      'SmsSmppHostsResponse',
      smsSmppHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * Update smpp host. Host address may or may not include the subnet mask (/32 is assumed if not
   * specified)Regular users can only specify subnets not larger then /20. Updatingsubnet values larger
   * than /20 requires Bandwidth staff intervention (Bandwidth staff may define subnets upto /14)Also,
   * host address should not intersect with addresses used by other services or other accounts,otherwise
   * a validation error will occur.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param hostId
   * @param body
   * @return Response from the API call
   */
  async updateSmsFeatureSmppHost(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    hostId: number,
    body?: SmsHost,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmsSmppHostsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      hostId: [hostId, number()],
    });
    req.xml('body', body, 'SmsHost', optional(smsHostSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms/smpp/hosts/${mapped.hostId}`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Host ip or mask can\'t be changed</li>   <li>47.0.0.0/12 has invalid mask. Valid mask values: 14-32</li>   <li>Termination IP 47.123.17.16/30 overlaps with an address that is already in use</li>   <li>Termination IP 47.123.17.16/30 overlaps with addresses that are already in use: 47.123.17.18</li>   <li>The IP address provided: <47.123.17.17> contains a non zero subnet portion. An equivalent IP address such as <47.123.17.16> with a zero subnet value must be provided</li></ul>');
    req.throwOn(403, ApiError, 'Access denied. Possible errors in response:<ul>   <li>Configuring subnet values larger than /20 requires Bandwidth staff intervention</li></ul>');
    return req.callAsXml(
      'SmsSmppHostsResponse',
      smsSmppHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete smpp host. Note: plain users can not delete hosts with subnet masks that are larger then /20,
   * becausethese hosts can only be managed by Bandwidth staff.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param hostId
   * @return Response from the API call
   */
  async deleteSmsFeatureSmppHosts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    hostId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SmsSmppHostsResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      hostId: [hostId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/features/sms/smpp/hosts/${mapped.hostId}`;
    req.throwOn(404, ApiError, 'smpp host was not found');
    return req.callAsXml(
      'SmsSmppHostsResponse',
      smsSmppHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve sipper application settings
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param applicationSettings
   * @return Response from the API call
   */
  async retrieveMessagingApplication(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    applicationSettings: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      applicationSettings: [applicationSettings, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/${mapped.applicationSettings}`;
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Create/update/delete application settings for sippeer<br>Set the ApplicationsSettings value to
   * 'REMOVE' to unassign application <br>
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param applicationSettings
   * @param body
   * @return Response from the API call
   */
  async updateMessagingApplication(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    applicationSettings: string,
    body?: ApplicationsSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      applicationSettings: [applicationSettings, string()],
    });
    req.xml(
      'body',
      body,
      'ApplicationsSettings',
      optional(applicationsSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/messaging/${mapped.applicationSettings}`;
    return req.callAsXml(
      'MmsFeatureResponse',
      mmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve origination settings for sippeer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveSipPeerTerminationGateway(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerOriginationSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/origination/settings`;
    return req.callAsXml(
      'SipPeerOriginationSettingsResponse',
      sipPeerOriginationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * update origination settings<br><ul>   <li>VoiceProtocol is required with possible values: HTTP,
   * SIP</li>   <li>HttpSettings and HttpVoiceV2AppId are optional fields and only allowed if
   * VoiceProtocol is HTTP</li></ul><br>Note: Changing the Voice Protocol from SIP to HTTP will remove
   * Voice Hosts or Voice Host Groups and Termination Hosts, which are configured using API
   * /accounts/{accountId}/sites/{siteId}/sippeers/{sippeerId}.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSipPeerTerminationGateway(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerOriginationSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerOriginationSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerOriginationSettings',
      optional(sipPeerOriginationSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/origination/settings`;
    return req.callAsXml(
      'SipPeerOriginationSettingsResponse',
      sipPeerOriginationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Set sippeer origination settings<br><ul>    <li>VoiceProtocol is required with possible values: HTTP,
   * SIP</li>    <li>HttpSettings and HttpVoiceV2AppId are optional fields and only allowed if
   * VoiceProtocol is HTTP</li></ul>
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTerminationGateway(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerOriginationSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerOriginationSettingsResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerOriginationSettings',
      optional(sipPeerOriginationSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/origination/settings`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Account level settings don`t exist</li></ul>');
    return req.callAsXml(
      'SipPeerOriginationSettingsResponse',
      sipPeerOriginationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * get all sip peer gateway IPs and subnets
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerTerminationProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTerminationProductsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination`;
    req.throwOn(500, ApiError, 'Server Error');
    return req.callAsXml(
      'TerminationResponse',
      sipPeerTerminationProductsResponseSchema,
      requestOptions
    );
  }

  /**
   * get all sip peer gateway IPs and subnets
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerTerminationGateways(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayIpsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/hosts`;
    return req.callAsXml(
      'TerminationHosts',
      sipPeerGatewayIpsResponseSchema,
      requestOptions
    );
  }

  /**
   * get sip peer gateway IP or subnet by id
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param gatewayId
   * @return Response from the API call
   */
  async getSipPeerTerminationGateway(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    gatewayId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayIpResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/hosts/${mapped.gatewayId}`;
    req.throwOn(404, ApiError, 'sip peer gateway ip was not found');
    return req.callAsXml(
      'SipPeerGatewayIpResponse',
      sipPeerGatewayIpResponseSchema,
      requestOptions
    );
  }

  /**
   * get all gateway attributes
   *
   * @param accountId
   * @param siteId
   * @param gatewayId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerTerminationGatewayAttributes(
    accountId: number,
    siteId: number,
    gatewayId: number,
    sipPeerId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayAttributesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      gatewayId: [gatewayId, number()],
      sipPeerId: [sipPeerId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.gatewayId}/products/termination/hosts/${mapped.sipPeerId}/settings`;
    return req.callAsXml(
      'SipPeerGatewayAttributesResponse',
      sipPeerGatewayAttributesResponseSchema,
      requestOptions
    );
  }

  /**
   * get gateway attribute by id
   *
   * @param accountId
   * @param siteId
   * @param gatewayId
   * @param attributeId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerTerminationGatewayAttribute(
    accountId: number,
    siteId: number,
    gatewayId: number,
    attributeId: number,
    sipPeerId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayAttributeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
      sipPeerId: [sipPeerId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.gatewayId}/products/termination/hosts/${mapped.attributeId}/settings/${mapped.sipPeerId}`;
    return req.callAsXml(
      'SipPeerGatewayAttributeResponse',
      sipPeerGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve termination settings for sippeer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async retrieveSipPeerTerminationGateway1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTerminationSettingsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/settings`;
    return req.callAsXml(
      'SipPeerTerminationSettingsResponse',
      sipPeerTerminationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * update termination settings<br>Note: Changing the Voice Protocol from SIP to HTTP will remove Voice
   * Hosts or Voice Host Groups and Termination Hosts, which are configured using API
   * /accounts/{accountId}/sites/{siteId}/sippeers/{sippeerId}.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSipPeerTerminationGateway1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerTerminationSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTerminationSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerTerminationSettings',
      optional(sipPeerTerminationSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/settings`;
    return req.callAsXml(
      'SipPeerTerminationSettingsResponse',
      sipPeerTerminationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Set sippeer termination settings<br><ul>    <li>VoiceProtocol is required with possible values: HTTP,
   * SIP</li>    <li>HttpSettings and HttpVoiceV2AppId are optional fields and only allowed if
   * VoiceProtocol is HTTP</li></ul>
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTerminationGateway1(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerTerminationSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTerminationSettingsResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerTerminationSettings',
      optional(sipPeerTerminationSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/settings`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Account level settings don`t exist</li></ul>');
    return req.callAsXml(
      'SipPeerTerminationSettingsResponse',
      sipPeerTerminationSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve a the data associated with a Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeer(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnSipPeerResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}`;
    req.throwOn(400, ApiError, 'Bad request - Sip Peer id is wrong');
    return req.callAsXml(
      'SipPeerResponse',
      tnSipPeerResponseSchema,
      requestOptions
    );
  }

  /**
   * Update a Sip PeerThere are a few rules used to eliminate IP address collisions.  The primary
   * restriction is on the ability to share Term IP addresses across the Bandwidth Dashboard API
   * structural elements. Essentially...<ul><li>Term Addresses cannot be shared
   * anywhere</li><li>VoiceHost and VoiceHostGroup addresses can be shared between SIP Peers, and can be
   * different than or the same as Term IP Addresses </li></ul>
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSipPeer(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: TnSipPeer,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnSipPeerResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml('body', body, 'SipPeer', optional(tnSipPeerSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>12113 "The provided street address could not be verified. Please submit a valid street address."</li>   <li>13569 "A termination host with HostName = 2.1.1.9 is already in use"</li>   <li>13509 "\'wrong.ip\' is not a valid host. Provide valid IP or domain name"</li>   <li>13553 "Duplicate host (and port) in VoiceHosts"</li>   <li>13510 "\'wrong.url\' is not a valid Destination URI"</li>   <li>13522 "IsDefaultPeer cannot be false right now. The account requires at least one Default Sip Peer"</li>   <li>13552 "A termination host with HostName = %s and Port = %s is already in use"</li>   <li>12024 "Region with state \'%s\' and country \'%s\' does not exist"</li>   <li>13576 "Account 9999999 has no CNAM product feature"</li>   <li>13581 "Display option is missing"</li>   <li>13582 "Enforce option is missing"</li>   <li>13563 "Sip Peer \'316167\' account \'9999999\' and site \'45\' does not exist"</li>   <li>13590 "The supplied CustomerTrafficAllowed value on host %s:%s are not allowed for this sippeer"</li>   <li>13591 "Termination Settings at the SIP Peer level are not allowed for accounts with the \'DedicatedPrivateNetworkTopology\' product."</li>   <li>13592 "Calling name \'Display\' and \'Enforced\' values can\'t be updated for \'DedicatedPrivateNetworkTopology\' account.</li>   <li>13593 "%s has invalid mask. Valid mask values: 24-32"</li>   <li>13594 "%s is not valid host"</li>   <li>13595 "The IP address provided: %s contains a non zero subnet portion. An equivalent IP address such as %s with a zero subnet value must be provided."</li></ul>');
    req.throwOn(409, ApiError, 'address couldn\'t be geocoded perfectly and needs some changes');
    return req.callAsXml(
      'SipPeerResponse',
      tnSipPeerResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete a Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async deleteSipPeer(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnSipPeerResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Delete not allowed while a SIP Peer has SMS feature</li></ul>');
    req.throwOn(404, ApiError, 'Sip Peer not found');
    return req.callAsXml(
      'SipPeerResponse',
      tnSipPeerResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about a Sip Peer or set of Sip Peers
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSipPeers(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers`;
    return req.callAsXml(
      'TNSipPeersResponse',
      sipPeersResponseSchema,
      requestOptions
    );
  }

  /**
   * Create a Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async createSipPeer(
    accountId: number,
    siteId: number,
    body?: TnSipPeer,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnSipPeerResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'SipPeer', optional(tnSipPeerSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:   Possible errors in response:   <ul>        <li>12113 "The provided street address could not be verified. Please submit a valid street address."</li>        <li>13569 "A termination host with HostName = 2.1.1.9 is already in use"</li>        <li>13509 "\'wrong.ip\' is not a valid host. Provide valid IP or domain name"</li>        <li>13553 "Duplicate host (and port) in VoiceHosts"</li>        <li>13510 "\'wrong.url\' is not a valid Destination URI"</li>        <li>13522 "IsDefaultPeer cannot be false right now. The account requires at least one Default Sip Peer"</li>        <li>13552 "A termination host with HostName = %s and Port = %s is already in use"</li>        <li>12024 "Region with state \'%s\' and country \'%s\' does not exist"</li>        <li>13576 "Account 9999999 has no CNAM product feature"</li>        <li>13581 "Display option is missing"</li>        <li>13582 "Enforce option is missing"</li>        <li>13590 "The supplied CustomerTrafficAllowed value on host %s:%s are not allowed for this sippeer"</li>        <li>13591 "Termination Settings at the SIP Peer level are not allowed for accounts with the \'DedicatedPrivateNetworkTopology\' product."</li>        <li>13592 "Calling name \'Display\' and \'Enforced\' values can\'t be updated for \'DedicatedPrivateNetworkTopology\' account.</li>        <li>13593 "%s has invalid mask. Valid mask values: 20-32"</li>        <li>13594 "%s is not valid host"</li>        <li>13595 "The IP address provided: %s contains a non zero subnet portion. An equivalent IP address such as %s with a zero subnet value must be provided."</li>   </ul>');
    req.throwOn(409, ApiError, 'Conflict - Sip Peer with such name already exists; address couldn\'t be geocoded perfectly and needs some changes');
    req.throwOn(503, ApiError, 'Service unavailable');
    return req.callAsXml(
      'SipPeerResponse',
      tnSipPeerResponseSchema,
      requestOptions
    );
  }

  /**
   * The POST method moves all telephone numbers specified in the body to the given SIP peer.<br>The
   * source SIP peer is determined by the Telephone Number, i.e. the PUT method can move multiple numbers
   * from different source SIP peers.<br>The destination SIP peer is specified in the URL.<br>NOTE: only
   * a maximum of 5000 Telephone Numbers can be moved in one operation.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTelephoneNumberBulk(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerTelephoneNumberBulk,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumberBulkResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerTelephoneNumbers',
      optional(sipPeerTelephoneNumberBulkSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/movetns`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>    <li>Shared TNs with messaging cannot be moved to a sippeer without the SMS feature enabled.</li>    <li>Shared TNs with voice cannot be moved to a sippeer with the SMS feature enabled.</li></ul>');
    return req.callAsXml(
      'SipPeerTelephoneNumberMoveResponse',
      sipPeerTelephoneNumberBulkResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about a Telephone number or set of Telephone numbers
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param page
   * @param size
   * @param includeAttributes
   * @param tnStatus
   * @return Response from the API call
   */
  async getSipPeerTelephoneNumbers(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    page?: string,
    size?: number,
    includeAttributes?: string,
    tnStatus?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumbersResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      page: [page, optional(string())],
      size: [size, optional(number())],
      includeAttributes: [includeAttributes, optional(string())],
      tnStatus: [tnStatus, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('includeAttributes', mapped.includeAttributes);
    req.query('tnStatus', mapped.tnStatus);
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/tns`;
    return req.callAsXml(
      'SipPeerTelephoneNumbersResponse',
      sipPeerTelephoneNumbersResponseSchema,
      requestOptions
    );
  }

  /**
   * <strong>As of MARCH 2nd, 2020 this endpoint will go into sunset and be deactivated.
   * </strong><br/>Moves an existing TN on the account to the specified SIP Peer, and sets the various TN-
   * related options.This API call remains unpublished externally.  /movetns is preferred for TN moving.
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTelephoneNumber(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerTelephoneNumber,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumberResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'SipPeerTelephoneNumber',
      optional(sipPeerTelephoneNumberSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/tns`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>13513 "Call Forwarding number \'%s\' is not a valid 10-digit telephone number"</li>   <li>13514 "Number Format \'%s\' is invalid for telephone number \'%s\'"</li>   <li>13515 "Rewrite User \'%s\' is invalid for telephone number \'%s\'"</li>   <li>13516 "RPID Format \'%s\' is invalid for telephone number \'%s\'"</li>   <li>13517 "Telephone number \'%s\' is not available"</li>   <li>13518 "Telephone number \'%s\' is not available"</li>   <li>13519 "There is an issue with telephone number \'%s\'. Please contact Customer Service"</li>   <li>13575 "CallingNameDisplay \'%s\' is invalid. Valid values are: \'true\', \'false\'"</li>   <li>13576 "Account \'%s\' has no [CallForwarding|CNAM] product feature"</li>   <li>13583 "CNAM for \'%s\' is applied at the Location level and it is not applicable at the TN level."</li>   <li>5166 "Sip Peer doesn\'t have Sms feature."</li>   <li>13670 "Updating of sms attribute is not allowed for %TN"</li></ul>');
    req.throwOn(404, ApiError, 'Bad Request. Possible errors in response:   13536 "Telephone number %s does not exist on Account %s, Site %s, and Sip Peer %s"   13563 "Sip Peer \'%s\' account \'%s\' and site \'%s\' does not exist"');
    req.throwOn(409, ApiError, 'Conflict - Telephone number exists on Sip Peer');
    return req.callAsXml(
      'SipPeerTelephoneNumberResponse',
      sipPeerTelephoneNumberResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param fullNumber
   * @return Response from the API call
   */
  async getSipPeerTelephoneNumber(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    fullNumber: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumberResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      fullNumber: [fullNumber, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/tns/${mapped.fullNumber}`;
    return req.callAsXml(
      'SipPeerTelephoneNumberResponse',
      sipPeerTelephoneNumberResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param fullNumber
   * @param body
   * @return Response from the API call
   */
  async updateReplaceSipPeerTelephoneNumber(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    fullNumber: string,
    body?: SipPeerTelephoneNumber,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerTelephoneNumberResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      fullNumber: [fullNumber, string()],
    });
    req.xml(
      'body',
      body,
      'SipPeerTelephoneNumber',
      optional(sipPeerTelephoneNumberSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/tns/${mapped.fullNumber}`;
    return req.callAsXml(
      'SipPeerTelephoneNumberResponse',
      sipPeerTelephoneNumberResponseSchema,
      requestOptions
    );
  }
}
